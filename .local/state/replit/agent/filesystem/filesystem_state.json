{"file_contents":{"README.md":{"content":"# LangSense Telegram Bot\n\nA comprehensive Telegram bot for financial services with multi-language support, admin panel, broadcasting, and transaction management built with Python and Aiogram v3.\n\n## Features\n\n### 🌐 Multi-Language Support\n- Arabic (RTL) and English interfaces\n- Dynamic language switching\n- Localized content and keyboards\n- Country-specific settings\n\n### 👥 User Management\n- Phone number verification\n- Automatic customer code generation\n- User profiles and preferences\n- Activity tracking\n\n### 💰 Financial Services\n- Deposit requests with receipt uploads\n- Withdrawal processing\n- Complaint handling system\n- Transaction workflow management\n\n### 🛠️ Admin Panel\n- User management and statistics\n- Language and country administration\n- Broadcasting system with targeting\n- Request inbox and approval workflow\n\n### 📢 Broadcasting & Announcements\n- Mass messaging with rate limiting\n- Target filtering by language/country\n- Scheduled announcements\n- Delivery tracking and retry logic\n\n### 🔒 Security & Authentication\n- Admin-only access controls\n- Secure database operations\n- Input validation and sanitization\n- Error handling and logging\n\n## Technology Stack\n\n- **Framework**: Aiogram v3 (Telegram Bot API)\n- **Database**: SQLAlchemy with async support\n- **Storage**: SQLite (dev) / PostgreSQL (prod)\n- **Internationalization**: JSON-based translations\n- **Task Scheduling**: APScheduler\n- **Image Processing**: Pillow\n- **Environment**: python-dotenv\n\n## Quick Start\n\n### Prerequisites\n- Python 3.8 or higher\n- Telegram Bot Token from [@BotFather](https://t.me/BotFather)\n- Your Telegram User ID\n\n### Windows Setup\n1. Download/clone this repository\n2. Double-click `run_windows.bat`\n3. Follow the setup instructions\n4. Create `.env` file with your bot token and admin ID\n5. The bot will start automatically\n\n### Linux/macOS Setup\n```bash\n# Make the script executable\nchmod +x run_linux.sh\n\n# Run the setup script\n./run_linux.sh\n","size_bytes":1965},"advanced_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nLangSense Bot - نظام متكامل متقدم\nإدارة شاملة للمستخدمين والمعاملات ووسائل الدفع\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nimport csv\nfrom datetime import datetime\nimport urllib.request\nimport urllib.parse\nimport urllib.error\n\n# إعداد التسجيل\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass AdvancedLangSenseBot:\n    def __init__(self, token):\n        self.token = token\n        self.api_url = f\"https://api.telegram.org/bot{token}\"\n        self.offset = 0\n        self.user_states = {}  # لحفظ حالات المستخدمين\n        self.init_files()\n        self.admin_ids = self.get_admin_ids()  # جلب معرفات الأدمن\n        \n    def init_files(self):\n        \"\"\"إنشاء جميع ملفات النظام\"\"\"\n        # ملف المستخدمين\n        if not os.path.exists('users.csv'):\n            with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason'])\n        \n        # ملف المعاملات المتقدم\n        if not os.path.exists('transactions.csv'):\n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'telegram_id', 'name', 'type', 'amount', 'status', 'date', 'admin_note', 'payment_method', 'receipt_info', 'processed_by'])\n        \n        # ملف وسائل الدفع\n        if not os.path.exists('payment_methods.csv'):\n            with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'name', 'type', 'details', 'is_active', 'created_date'])\n                # وسائل افتراضية\n                default_methods = [\n                    ['1', 'البنك الأهلي', 'deposit', 'رقم الحساب: 1234567890\\nاسم المستفيد: شركة النظام المالي', 'active'],\n                    ['2', 'بنك الراجحي', 'deposit', 'رقم الحساب: 0987654321\\nاسم المستفيد: شركة النظام المالي', 'active'],  \n                    ['3', 'STC Pay', 'withdraw', 'رقم الجوال: 0501234567', 'active'],\n                    ['4', 'مدى البنك الأهلي', 'withdraw', 'رقم الحساب: 1111222233334444', 'active']\n                ]\n                for method in default_methods:\n                    writer.writerow(method + [datetime.now().strftime('%Y-%m-%d')])\n        \n        # إنشاء ملف الشكاوى\n        if not os.path.exists('complaints.csv'):\n            with open('complaints.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'message', 'status', 'date'])\n        \n        # إنشاء ملف إعدادات النظام\n        if not os.path.exists('system_settings.csv'):\n            with open('system_settings.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['setting_key', 'setting_value', 'description'])\n                # إعدادات افتراضية\n                default_settings = [\n                    ['support_phone', '+966501234567', 'رقم هاتف الدعم الفني'],\n                    ['support_email', 'support@langsense.com', 'بريد الدعم الإلكتروني'], \n                    ['company_name', 'شركة LangSense المالية', 'اسم الشركة'],\n                    ['min_deposit', '50', 'أقل مبلغ إيداع مسموح'],\n                    ['min_withdrawal', '100', 'أقل مبلغ سحب مسموح'],\n                    ['max_daily_withdrawal', '10000', 'أقصى مبلغ سحب يومي'],\n                    ['support_hours', '24/7', 'ساعات عمل الدعم'],\n                    ['welcome_message', 'مرحباً بك في نظام LangSense المالي المتقدم', 'رسالة الترحيب']\n                ]\n                for setting in default_settings:\n                    writer.writerow(setting)\n        \n        logger.info(\"تم إنشاء جميع ملفات النظام بنجاح\")\n        \n    def api_call(self, method, data=None):\n        \"\"\"استدعاء API مُحسن\"\"\"\n        url = f\"{self.api_url}/{method}\"\n        try:\n            if data:\n                json_data = json.dumps(data).encode('utf-8')\n                req = urllib.request.Request(url, data=json_data)\n                req.add_header('Content-Type', 'application/json')\n            else:\n                req = urllib.request.Request(url)\n            \n            with urllib.request.urlopen(req, timeout=10) as response:\n                return json.loads(response.read().decode('utf-8'))\n                \n        except Exception as e:\n            logger.error(f\"خطأ في API: {e}\")\n            return None\n    \n    def send_message(self, chat_id, text, keyboard=None):\n        \"\"\"إرسال رسالة\"\"\"\n        data = {'chat_id': chat_id, 'text': text, 'parse_mode': 'HTML'}\n        if keyboard:\n            data['reply_markup'] = keyboard\n        return self.api_call('sendMessage', data)\n    \n    def get_updates(self):\n        \"\"\"جلب التحديثات\"\"\"\n        url = f\"{self.api_url}/getUpdates?offset={self.offset + 1}&timeout=10\"\n        try:\n            with urllib.request.urlopen(url, timeout=15) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في جلب التحديثات: {e}\")\n            return None\n    \n    def get_admin_ids(self):\n        \"\"\"جلب معرفات الأدمن\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        return [admin_id.strip() for admin_id in admin_ids if admin_id.strip()]\n    \n    def is_admin(self, telegram_id):\n        \"\"\"فحص صلاحية الأدمن\"\"\"\n        return str(telegram_id) in self.admin_ids\n    \n    def notify_admins(self, message):\n        \"\"\"إشعار فوري لجميع الأدمن\"\"\"\n        for admin_id in self.admin_ids:\n            try:\n                self.send_message(admin_id, message)\n            except:\n                pass\n    \n    def is_user_banned(self, telegram_id):\n        \"\"\"فحص حظر المستخدم\"\"\"\n        user = self.find_user(telegram_id)\n        return user and user.get('is_banned', 'no') == 'yes'\n    \n    def find_user(self, telegram_id):\n        \"\"\"البحث عن مستخدم\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['telegram_id'] == str(telegram_id):\n                        return row\n        except:\n            pass\n        return None\n    \n    def search_users(self, query):\n        \"\"\"البحث في المستخدمين\"\"\"\n        results = []\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if (query.lower() in row['name'].lower() or \n                        query in row['customer_id'] or \n                        query in row['phone']):\n                        results.append(row)\n        except:\n            pass\n        return results\n    \n    def get_payment_methods(self, method_type=None):\n        \"\"\"جلب وسائل الدفع\"\"\"\n        methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if method_type is None or row['type'] == method_type:\n                        if row['is_active'] == 'active':\n                            methods.append(row)\n        except:\n            pass\n        return methods\n    \n    def get_pending_transactions(self):\n        \"\"\"جلب المعاملات المعلقة\"\"\"\n        pending = []\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['status'] == 'pending':\n                        pending.append(row)\n        except:\n            pass\n        return pending\n    \n    def update_transaction_status(self, trans_id, new_status, admin_note='', admin_id=''):\n        \"\"\"تحديث حالة المعاملة\"\"\"\n        transactions = []\n        try:\n            # قراءة جميع المعاملات\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        row['status'] = new_status\n                        if admin_note:\n                            row['admin_note'] = admin_note\n                        row['processed_by'] = admin_id\n                    transactions.append(row)\n            \n            # إعادة كتابة الملف\n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['id', 'customer_id', 'telegram_id', 'name', 'type', 'amount', 'status', 'date', 'admin_note', 'payment_method', 'receipt_info', 'processed_by']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(transactions)\n            return True\n        except:\n            return False\n    \n    def ban_user(self, customer_id, reason, admin_id):\n        \"\"\"حظر مستخدم\"\"\"\n        users = []\n        success = False\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        row['is_banned'] = 'yes'\n                        row['ban_reason'] = reason\n                        success = True\n                    users.append(row)\n            \n            if success:\n                with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(users)\n        except:\n            pass\n        return success\n    \n    def main_keyboard(self, lang='ar'):\n        \"\"\"القائمة الرئيسية\"\"\"\n        if lang == 'ar':\n            return {\n                'keyboard': [\n                    [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}],\n                    [{'text': '📋 طلباتي'}, {'text': '👤 حسابي'}],\n                    [{'text': '📨 شكوى'}, {'text': '🆘 دعم'}],\n                    [{'text': '🇺🇸 English'}, {'text': '/admin'}]\n                ],\n                'resize_keyboard': True\n            }\n        else:\n            return {\n                'keyboard': [\n                    [{'text': '💰 Deposit Request'}, {'text': '💸 Withdrawal Request'}],\n                    [{'text': '📋 My Requests'}, {'text': '👤 Profile'}],\n                    [{'text': '📨 Complaint'}, {'text': '🆘 Support'}],\n                    [{'text': '🇸🇦 العربية'}, {'text': '/admin'}]\n                ],\n                'resize_keyboard': True\n            }\n    \n    def create_deposit_request(self, message):\n        \"\"\"إنشاء طلب إيداع متقدم\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        # عرض وسائل الإيداع المتاحة\n        deposit_methods = self.get_payment_methods('deposit')\n        if not deposit_methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد وسائل إيداع متاحة حالياً\")\n            return\n        \n        methods_text = \"💰 طلب إيداع جديد\\n\\nوسائل الإيداع المتاحة:\\n\\n\"\n        keyboard_buttons = []\n        \n        for method in deposit_methods:\n            methods_text += f\"🏦 {method['name']}\\n{method['details']}\\n\\n\"\n            keyboard_buttons.append([{'text': f\"💳 {method['name']}\"}])\n        \n        keyboard_buttons.append([{'text': '🔙 العودة للقائمة الرئيسية'}])\n        \n        methods_text += \"اختر وسيلة الإيداع المناسبة:\"\n        \n        self.send_message(message['chat']['id'], methods_text, {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        })\n        \n        # حفظ حالة المستخدم\n        self.user_states[message['from']['id']] = 'selecting_deposit_method'\n    \n    def process_deposit_method_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الإيداع\"\"\"\n        user = self.find_user(message['from']['id'])\n        selected_method = message['text'].replace('💳 ', '')\n        \n        # البحث عن الوسيلة المختارة\n        deposit_methods = self.get_payment_methods('deposit')\n        selected_method_info = None\n        for method in deposit_methods:\n            if method['name'] == selected_method:\n                selected_method_info = method\n                break\n        \n        if not selected_method_info:\n            self.send_message(message['chat']['id'], \"❌ وسيلة الدفع غير صحيحة\")\n            return\n        \n        # إنشاء المعاملة\n        trans_id = f\"DEP{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        \n        response = f\"\"\"✅ تم اختيار الشركة: {selected_method}\n\n🆔 رقم المعاملة: {trans_id}\n📱 العميل: {user['name']} ({user['customer_id']})\n🏢 الشركة: {selected_method}\n💳 التفاصيل: {selected_method_info['details']}\n\nالآن، يرجى كتابة رقم حسابك/محفظتك في {selected_method}:\n\n📋 تفاصيل التحويل:\n{selected_method_info['details']}\n\n📝 لإتمام الطلب، يرجى إرسال:\n1️⃣ المبلغ المراد إيداعه (رقم فقط)\n2️⃣ صورة إيصال التحويل\n\nمثال: 1000\"\"\"\n        \n        # حفظ المعاملة\n        with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n            writer = csv.writer(f)\n            writer.writerow([\n                trans_id, user['customer_id'], user['telegram_id'], user['name'], \n                'deposit', '0', 'pending', datetime.now().strftime('%Y-%m-%d %H:%M'), \n                '', selected_method, 'awaiting_details', ''\n            ])\n        \n        # إشعار فوري شامل للأدمن\n        admin_notification = f\"\"\"🚨 طلب إيداع جديد - مرحلة 1\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n📱 تيليجرام: @{message['from'].get('username', 'غير متوفر')} ({user['telegram_id']})\n📞 الهاتف: {user['phone']}\n🏦 وسيلة الدفع المختارة: {selected_method}\n📅 الوقت: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n🔢 المرحلة: انتظار إدخال المبلغ\n\n📋 تفاصيل وسيلة الدفع:\n{selected_method_info['details']}\n\n⏳ العميل الآن يدخل المبلغ المطلوب...\"\"\"\n        \n        self.notify_admins(admin_notification)\n        \n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = f'deposit_wallet_{trans_id}_{selected_method}'\n    \n    def process_deposit_wallet(self, message):\n        \"\"\"معالجة رقم المحفظة/الحساب للإيداع\"\"\"\n        state_parts = self.user_states[message['from']['id']].split('_')\n        trans_id = state_parts[2]\n        selected_method = '_'.join(state_parts[3:])\n        \n        wallet_number = message['text'].strip()\n        \n        if not wallet_number or len(wallet_number) < 5:\n            self.send_message(message['chat']['id'], \n                \"❌ رقم المحفظة/الحساب غير صحيح. يرجى إدخال رقم صحيح:\")\n            return\n        \n        # تحديث المعاملة برقم المحفظة\n        transactions = []\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        row['receipt_info'] = f\"رقم المحفظة: {wallet_number}\"\n                        row['status'] = 'amount_pending'\n                    transactions.append(row)\n            \n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['id', 'customer_id', 'telegram_id', 'name', 'type', 'amount', 'status', 'date', 'admin_note', 'payment_method', 'receipt_info', 'processed_by']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(transactions)\n        except:\n            pass\n        \n        response = f\"\"\"✅ تم حفظ رقم المحفظة: {wallet_number}\n\n🆔 رقم المعاملة: {trans_id}\n🏢 الشركة: {selected_method}\n💳 رقم المحفظة: {wallet_number}\n\nالآن أدخل المبلغ المطلوب إيداعه (بالريال السعودي):\"\"\"\n        \n        self.send_message(message['chat']['id'], response)\n        \n        # تحديث الحالة لإدخال المبلغ\n        self.user_states[message['from']['id']] = f'deposit_amount_{trans_id}'\n        \n        # إشعار محدث للأدمن\n        user = self.find_user(message['from']['id'])\n        admin_msg = f\"\"\"🔔 تحديث طلب إيداع - مرحلة 2\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n🏢 الشركة: {selected_method}\n💳 رقم المحفظة: {wallet_number}\n⏰ الوقت: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n⏳ في انتظار إدخال المبلغ...\"\"\"\n        \n        self.notify_admins(admin_msg)\n    \n    def handle_admin_search(self, message):\n        \"\"\"البحث في المستخدمين للأدمن\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        parts = message['text'].split(' ', 1)\n        if len(parts) < 2:\n            self.send_message(message['chat']['id'], \"استخدم: /search اسم_أو_رقم_العميل\")\n            return\n        \n        query = parts[1]\n        results = self.search_users(query)\n        \n        if not results:\n            self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على نتائج للبحث: {query}\")\n            return\n        \n        response = f\"🔍 نتائج البحث عن: {query}\\n\\n\"\n        for user in results:\n            ban_status = \"🚫 محظور\" if user.get('is_banned') == 'yes' else \"✅ نشط\"\n            response += f\"👤 {user['name']}\\n🆔 {user['customer_id']}\\n📱 {user['phone']}\\n🔸 {ban_status}\\n\\n\"\n        \n        self.send_message(message['chat']['id'], response)\n    \n    def handle_admin_ban(self, message):\n        \"\"\"حظر مستخدم\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        parts = message['text'].split(' ', 2)\n        if len(parts) < 3:\n            self.send_message(message['chat']['id'], \"استخدم: /ban رقم_العميل سبب_الحظر\")\n            return\n        \n        customer_id = parts[1]\n        reason = parts[2]\n        \n        if self.ban_user(customer_id, reason, str(message['from']['id'])):\n            # إشعار المستخدم بالحظر\n            user = None\n            try:\n                with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['customer_id'] == customer_id:\n                            user = row\n                            break\n            except:\n                pass\n            \n            if user:\n                self.send_message(user['telegram_id'], f\"🚫 تم حظر حسابك\\n\\nالسبب: {reason}\\n\\nللاستفسار تواصل مع الإدارة\")\n            \n            self.send_message(message['chat']['id'], f\"✅ تم حظر العميل {customer_id} بنجاح\")\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في حظر العميل {customer_id}\")\n    \n    def handle_admin_pending(self, message):\n        \"\"\"عرض الطلبات المعلقة\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        pending = self.get_pending_transactions()\n        if not pending:\n            self.send_message(message['chat']['id'], \"✅ لا توجد طلبات معلقة\")\n            return\n        \n        response = f\"⏳ الطلبات المعلقة ({len(pending)}):\\n\\n\"\n        for trans in pending:\n            response += f\"🆔 {trans['id']}\\n👤 {trans['name']} ({trans['customer_id']})\\n💰 {trans['type']}: {trans['amount']} ريال\\n📅 {trans['date']}\\n\\n\"\n        \n        response += \"\\n💡 للموافقة: /approve رقم_المعاملة\\n💡 للرفض: /reject رقم_المعاملة سبب\"\n        \n        self.send_message(message['chat']['id'], response)\n    \n    def handle_text(self, message):\n        \"\"\"معالجة الرسائل النصية الرئيسية\"\"\"\n        if self.is_user_banned(message['from']['id']):\n            self.send_message(message['chat']['id'], \"🚫 حسابك محظور. تواصل مع الإدارة للاستفسار.\")\n            return\n        \n        text = message['text']\n        chat_id = message['chat']['id']\n        user_id = message['from']['id']\n        \n        # فحص الأوامر الإدارية\n        if self.is_admin(user_id):\n            if text.startswith('/search '):\n                self.handle_admin_search(message)\n                return\n            elif text.startswith('/ban '):\n                self.handle_admin_ban(message)\n                return\n            elif text == '/pending':\n                self.handle_admin_pending(message)\n                return\n            elif text.startswith('/approve '):\n                self.handle_admin_approve(message)\n                return\n            elif text.startswith('/reject '):\n                self.handle_admin_reject(message)\n                return\n            # معالجة أزرار الأدمن\n            elif text == '📋 الطلبات المعلقة':\n                self.handle_admin_pending(message)\n                return\n            elif text == '✅ طلبات مُوافقة':\n                self.show_approved_transactions(message)\n                return\n            elif text == '👥 إدارة المستخدمين':\n                self.show_users_management(message)\n                return\n            elif text == '🔍 البحث':\n                self.prompt_admin_search(message)\n                return\n            elif text == '💳 وسائل الدفع':\n                self.show_payment_methods_admin(message)\n                return\n            elif text == '📊 الإحصائيات':\n                self.show_detailed_stats(message)\n                return\n            elif text == '📢 إرسال جماعي':\n                self.prompt_broadcast(message)\n                return\n            elif text == '🚫 حظر مستخدم':\n                self.prompt_ban_user(message)\n                return\n            elif text == '✅ إلغاء حظر':\n                self.prompt_unban_user(message)\n                return\n            elif text == '📝 إضافة وسيلة دفع':\n                self.prompt_add_payment_method(message)\n                return\n            elif text == '⚙️ تعديل وسائل الدفع':\n                self.show_edit_payment_methods(message)\n                return\n            elif text == '⚙️ إدارة إعدادات النظام':\n                self.show_system_settings(message)\n                return\n            elif text.startswith('/editsetting '):\n                self.handle_edit_setting(message)\n                return\n            elif text.startswith('/editcompany '):\n                self.handle_edit_company(message)\n                return\n            elif text.startswith('/addcompany '):\n                self.handle_add_company(message)\n                return\n            elif text.startswith('/deletecompany '):\n                self.handle_delete_company(message)\n                return\n            elif text == '🏠 القائمة الرئيسية':\n                user = self.find_user(user_id)\n                lang = user.get('language', 'ar') if user else 'ar'\n                welcome_text = f\"مرحباً! 👋\\nتم العودة للقائمة الرئيسية\"\n                self.send_message(chat_id, welcome_text, self.main_keyboard(lang))\n                return\n        \n        # فحص حالات المستخدم\n        if user_id in self.user_states:\n            state = self.user_states[user_id]\n            if state == 'selecting_deposit_method':\n                self.process_deposit_method_selection(message)\n                return\n            elif state.startswith('deposit_wallet_'):\n                self.process_deposit_wallet(message)\n                return\n            elif state.startswith('deposit_amount_'):\n                self.process_deposit_amount(message)\n                return\n            elif state == 'admin_searching':\n                self.process_admin_search(message)\n                return\n            elif state == 'admin_broadcasting':\n                self.process_admin_broadcast(message)\n                return\n            elif state == 'admin_banning':\n                self.process_admin_ban(message)\n                return\n            elif state == 'admin_unbanning':\n                self.process_admin_unban(message)\n                return\n            elif state == 'selecting_withdraw_method':\n                self.process_withdrawal_method_selection(message)\n                return\n            elif state.startswith('withdraw_wallet_'):\n                self.process_withdrawal_wallet(message)\n                return\n            elif state.startswith('withdraw_amount_'):\n                self.process_withdrawal_amount(message)\n                return\n            elif state == 'admin_adding_payment':\n                self.process_admin_add_payment(message)\n                return\n            elif state == 'admin_editing_payment':\n                self.process_admin_edit_payment(message)\n                return\n        \n        user = self.find_user(user_id)\n        if not user:\n            self.handle_start(message)\n            return\n        \n        lang = user.get('language', 'ar')\n        \n        # معالجة القوائم\n        if text in ['💰 طلب إيداع', '💰 Deposit Request']:\n            self.create_deposit_request(message)\n        elif text in ['💸 طلب سحب', '💸 Withdrawal Request']:\n            self.create_withdrawal_request(message)\n        elif text in ['📋 طلباتي', '📋 My Requests']:\n            self.show_user_transactions(message)\n        elif text == '/admin' and self.is_admin(user_id):\n            self.handle_admin_panel(message)\n        else:\n            self.send_message(chat_id, \"اختر من القائمة:\", self.main_keyboard(lang))\n    \n    def show_user_transactions(self, message):\n        \"\"\"عرض طلبات المستخدم\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        transactions = []\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == user['customer_id']:\n                        transactions.append(row)\n        except:\n            pass\n        \n        if not transactions:\n            self.send_message(message['chat']['id'], \"📋 لا توجد طلبات سابقة\")\n            return\n        \n        response = f\"📋 طلباتك ({len(transactions)}):\\n\\n\"\n        for trans in transactions[-10:]:  # آخر 10 طلبات\n            status_emoji = {\"pending\": \"⏳\", \"approved\": \"✅\", \"rejected\": \"❌\"}.get(trans['status'], \"❓\")\n            response += f\"{status_emoji} {trans['id']}\\n💰 {trans['type']}: {trans['amount']} ريال\\n📅 {trans['date']}\\n\"\n            if trans.get('admin_note'):\n                response += f\"📝 ملاحظة: {trans['admin_note']}\\n\"\n            response += \"\\n\"\n        \n        self.send_message(message['chat']['id'], response)\n    \n    def get_transaction_info(self, trans_id):\n        \"\"\"جلب معلومات معاملة\"\"\"\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        return row\n        except:\n            pass\n        return None\n    \n    def handle_admin_approve(self, message):\n        \"\"\"موافقة الأدمن على طلب مع إشعار فوري\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        parts = message['text'].split(' ', 1)\n        if len(parts) < 2:\n            return\n        \n        trans_id = parts[1]\n        admin_name = message['from'].get('first_name', 'الإدارة')\n        \n        if self.update_transaction_status(trans_id, 'approved', f'تمت الموافقة من {admin_name}', str(message['from']['id'])):\n            # إشعار فوري للمستخدم مع تفاصيل كاملة\n            trans_info = self.get_transaction_info(trans_id)\n            if trans_info:\n                user_notification = f\"\"\"🎉 تمت الموافقة على طلبك!\n\n🆔 رقم المعاملة: {trans_id}\n💰 النوع: {trans_info['type']}\n💵 المبلغ: {trans_info['amount']} ريال\n⏰ وقت الموافقة: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n👤 معالج بواسطة: {admin_name}\n\n✅ تم معالجة طلبك بنجاح\nشكراً لاستخدام خدماتنا\"\"\"\n                \n                try:\n                    self.send_message(trans_info['telegram_id'], user_notification)\n                except:\n                    pass\n            \n            admin_response = f\"✅ تمت الموافقة على الطلب {trans_id}\\n📱 تم إشعار العميل فوراً\"\n            self.send_message(message['chat']['id'], admin_response, self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في الموافقة على الطلب {trans_id}\", self.admin_keyboard())\n    \n    def handle_admin_reject(self, message):\n        \"\"\"رفض طلب مع إشعار فوري محسن\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        parts = message['text'].split(' ', 2)\n        if len(parts) < 3:\n            self.send_message(message['chat']['id'], \"استخدم: /reject رقم_المعاملة السبب\", self.admin_keyboard())\n            return\n        \n        trans_id = parts[1]\n        reason = parts[2]\n        admin_name = message['from'].get('first_name', 'الإدارة')\n        \n        if self.update_transaction_status(trans_id, 'rejected', f'مرفوض: {reason}', str(message['from']['id'])):\n            trans_info = self.get_transaction_info(trans_id)\n            if trans_info:\n                user_notification = f\"\"\"❌ تم رفض طلبك\n\n🆔 رقم المعاملة: {trans_id}\n💰 النوع: {trans_info['type']}\n💵 المبلغ: {trans_info['amount']} ريال\n⏰ وقت الرفض: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n📝 سبب الرفض: {reason}\n\n💡 يمكنك إنشاء طلب جديد إذا أردت\nللاستفسار تواصل مع الإدارة\"\"\"\n                \n                try:\n                    self.send_message(trans_info['telegram_id'], user_notification)\n                except:\n                    pass\n            \n            admin_response = f\"✅ تم رفض الطلب {trans_id}\\n📱 تم إشعار العميل بالسبب فوراً\"\n            self.send_message(message['chat']['id'], admin_response, self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في رفض الطلب {trans_id}\", self.admin_keyboard())\n    \n    def admin_keyboard(self):\n        \"\"\"لوحة أزرار الأدمن الشاملة\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '📋 الطلبات المعلقة'}, {'text': '✅ طلبات مُوافقة'}],\n                [{'text': '👥 إدارة المستخدمين'}, {'text': '🔍 البحث'}],\n                [{'text': '💳 وسائل الدفع'}, {'text': '📊 الإحصائيات'}],\n                [{'text': '📢 إرسال جماعي'}, {'text': '🔧 إعدادات'}],\n                [{'text': '🚫 حظر مستخدم'}, {'text': '✅ إلغاء حظر'}],\n                [{'text': '📝 إضافة وسيلة دفع'}, {'text': '⚙️ تعديل وسائل الدفع'}],\n                [{'text': '🏠 القائمة الرئيسية'}]\n            ],\n            'resize_keyboard': True\n        }\n    \n    def handle_admin_panel(self, message):\n        \"\"\"لوحة إدارة شاملة بالأزرار\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        # إحصائيات شاملة\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                users = list(csv.DictReader(f))\n                total_users = len(users)\n                banned_users = len([u for u in users if u.get('is_banned') == 'yes'])\n                active_users = total_users - banned_users\n        except:\n            total_users = banned_users = active_users = 0\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                transactions = list(csv.DictReader(f))\n                total_trans = len(transactions)\n                pending_trans = len([t for t in transactions if t['status'] == 'pending'])\n                approved_trans = len([t for t in transactions if t['status'] == 'approved'])\n                rejected_trans = len([t for t in transactions if t['status'] == 'rejected'])\n                \n                # حساب إجمالي المبالغ\n                total_amount = sum(float(t.get('amount', 0)) for t in transactions if t['status'] == 'approved')\n        except:\n            total_trans = pending_trans = approved_trans = rejected_trans = 0\n            total_amount = 0\n        \n        admin_text = f\"\"\"🛠️ لوحة التحكم الشاملة\n\n📊 الإحصائيات الحية:\n👥 المستخدمين: {total_users}\n   ✅ نشطين: {active_users}\n   🚫 محظورين: {banned_users}\n\n💰 المعاملات: {total_trans}\n   ⏳ معلقة: {pending_trans}\n   ✅ مُوافقة: {approved_trans}\n   ❌ مرفوضة: {rejected_trans}\n   💵 إجمالي المبالغ: {total_amount:,.0f} ريال\n\nاستخدم الأزرار أدناه للتحكم الكامل:\"\"\"\n        \n        self.send_message(message['chat']['id'], admin_text, self.admin_keyboard())\n    \n    def show_approved_transactions(self, message):\n        \"\"\"عرض الطلبات المُوافقة\"\"\"\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                transactions = [t for t in csv.DictReader(f) if t['status'] == 'approved']\n        except:\n            transactions = []\n        \n        if not transactions:\n            self.send_message(message['chat']['id'], \"✅ لا توجد طلبات مُوافقة\", self.admin_keyboard())\n            return\n        \n        response = f\"✅ الطلبات المُوافقة ({len(transactions)}):\\n\\n\"\n        for trans in transactions[-10:]:\n            response += f\"🆔 {trans['id']}\\n👤 {trans['name']}\\n💰 {trans['type']}: {trans['amount']} ريال\\n📅 {trans['date']}\\n\\n\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def show_users_management(self, message):\n        \"\"\"إدارة المستخدمين\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                users = list(csv.DictReader(f))\n        except:\n            users = []\n        \n        if not users:\n            self.send_message(message['chat']['id'], \"👥 لا توجد مستخدمين\", self.admin_keyboard())\n            return\n        \n        active = [u for u in users if u.get('is_banned', 'no') == 'no']\n        banned = [u for u in users if u.get('is_banned', 'no') == 'yes']\n        \n        response = f\"\"\"👥 إدارة المستخدمين\n\n📊 الإحصائيات:\n✅ نشطين: {len(active)}\n🚫 محظورين: {len(banned)}\n📋 المجموع: {len(users)}\n\nآخر 5 مستخدمين:\n\"\"\"\n        for user in users[-5:]:\n            status = \"🚫\" if user.get('is_banned') == 'yes' else \"✅\"\n            response += f\"{status} {user['name']} ({user['customer_id']})\\n\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def prompt_admin_search(self, message):\n        \"\"\"طلب البحث من الأدمن\"\"\"\n        response = \"🔍 البحث في المستخدمين\\n\\nأرسل اسم العميل أو رقم العميل للبحث:\"\n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = 'admin_searching'\n    \n    def show_payment_methods_admin(self, message):\n        \"\"\"عرض وسائل الدفع للأدمن\"\"\"\n        deposit_methods = self.get_payment_methods('deposit')\n        withdraw_methods = self.get_payment_methods('withdraw')\n        \n        response = \"💳 وسائل الدفع الحالية\\n\\n\"\n        \n        response += \"💰 وسائل الإيداع:\\n\"\n        for method in deposit_methods:\n            response += f\"🏦 {method['name']}\\n\"\n        \n        response += f\"\\n💸 وسائل السحب:\\n\"\n        for method in withdraw_methods:\n            response += f\"💳 {method['name']}\\n\"\n        \n        response += f\"\\n📝 المجموع: {len(deposit_methods + withdraw_methods)}\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def show_detailed_stats(self, message):\n        \"\"\"إحصائيات تفصيلية\"\"\"\n        # إحصائيات المستخدمين\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                users = list(csv.DictReader(f))\n                total_users = len(users)\n                banned_users = len([u for u in users if u.get('is_banned') == 'yes'])\n                today_users = len([u for u in users if u['date'].startswith(datetime.now().strftime('%Y-%m-%d'))])\n        except:\n            total_users = banned_users = today_users = 0\n        \n        # إحصائيات المعاملات\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                transactions = list(csv.DictReader(f))\n                total_trans = len(transactions)\n                pending_trans = len([t for t in transactions if t['status'] == 'pending'])\n                approved_trans = len([t for t in transactions if t['status'] == 'approved'])\n                rejected_trans = len([t for t in transactions if t['status'] == 'rejected'])\n                \n                # المبالغ\n                total_amount = sum(float(t.get('amount', 0)) for t in transactions if t['status'] == 'approved')\n                pending_amount = sum(float(t.get('amount', 0)) for t in transactions if t['status'] == 'pending')\n                \n                # اليوم\n                today = datetime.now().strftime('%Y-%m-%d')\n                today_trans = [t for t in transactions if t['date'].startswith(today)]\n                today_count = len(today_trans)\n                today_amount = sum(float(t.get('amount', 0)) for t in today_trans if t['status'] == 'approved')\n        except:\n            total_trans = pending_trans = approved_trans = rejected_trans = 0\n            total_amount = pending_amount = today_count = today_amount = 0\n        \n        response = f\"\"\"📊 الإحصائيات التفصيلية\n\n👥 المستخدمين:\n📋 المجموع: {total_users}\n✅ نشطين: {total_users - banned_users}\n🚫 محظورين: {banned_users}\n🆕 اليوم: {today_users}\n\n💰 المعاملات:\n📋 المجموع: {total_trans}\n⏳ معلقة: {pending_trans}\n✅ مُوافقة: {approved_trans}\n❌ مرفوضة: {rejected_trans}\n\n💵 المبالغ:\n✅ إجمالي مُوافق: {total_amount:,.0f} ريال\n⏳ معلق: {pending_amount:,.0f} ريال\n\n📈 إحصائيات اليوم:\n📋 معاملات: {today_count}\n💵 مبالغ: {today_amount:,.0f} ريال\n\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\"\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def prompt_broadcast(self, message):\n        \"\"\"طلب الإرسال الجماعي\"\"\"\n        response = \"📢 الإرسال الجماعي\\n\\nأرسل الرسالة التي تريد إرسالها لجميع المستخدمين:\"\n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = 'admin_broadcasting'\n    \n    def prompt_ban_user(self, message):\n        \"\"\"طلب حظر مستخدم\"\"\"\n        response = \"🚫 حظر مستخدم\\n\\nأرسل رقم العميل والسبب:\\nمثال: C000001 مخالفة الشروط\"\n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = 'admin_banning'\n    \n    def prompt_unban_user(self, message):\n        \"\"\"طلب إلغاء حظر مستخدم\"\"\"\n        response = \"✅ إلغاء حظر مستخدم\\n\\nأرسل رقم العميل:\\nمثال: C000001\"\n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = 'admin_unbanning'\n    \n    def create_withdrawal_request(self, message):\n        \"\"\"إنشاء طلب سحب متقدم مع اختيار الشركة\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        # عرض شركات السحب المتاحة\n        withdraw_methods = self.get_payment_methods('withdraw')\n        if not withdraw_methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد شركات سحب متاحة حالياً\")\n            return\n        \n        methods_text = \"💸 طلب سحب جديد\\n\\nالشركات المتاحة للسحب:\\n\\n\"\n        keyboard_buttons = []\n        \n        for method in withdraw_methods:\n            methods_text += f\"💳 {method['name']}\\n📝 {method['details']}\\n\\n\"\n            keyboard_buttons.append([{'text': f\"💸 {method['name']}\"}])\n        \n        keyboard_buttons.append([{'text': '🔙 العودة للقائمة الرئيسية'}])\n        \n        methods_text += \"اختر الشركة المناسبة للسحب:\"\n        \n        self.send_message(message['chat']['id'], methods_text, {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        })\n        \n        self.user_states[message['from']['id']] = 'selecting_withdraw_method'\n    \n    def process_withdrawal_method_selection(self, message):\n        \"\"\"معالجة اختيار شركة السحب\"\"\"\n        user = self.find_user(message['from']['id'])\n        selected_method = message['text'].replace('💸 ', '')\n        \n        # البحث عن الشركة المختارة\n        withdraw_methods = self.get_payment_methods('withdraw')\n        selected_method_info = None\n        for method in withdraw_methods:\n            if method['name'] == selected_method:\n                selected_method_info = method\n                break\n        \n        if not selected_method_info:\n            self.send_message(message['chat']['id'], \"❌ شركة السحب غير صحيحة\")\n            return\n        \n        response = f\"\"\"💸 تم اختيار شركة السحب: {selected_method}\n\n📝 تفاصيل الشركة:\n{selected_method_info['details']}\n\n💡 الآن يرجى إدخال رقم محفظتك أو حسابك في {selected_method}:\n\nمثال: 0501234567\"\"\"\n        \n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = f'withdraw_wallet_{selected_method}'\n    \n    def process_withdrawal_wallet(self, message):\n        \"\"\"معالجة رقم المحفظة\"\"\"\n        user = self.find_user(message['from']['id'])\n        wallet_number = message['text'].strip()\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        \n        if not state.startswith('withdraw_wallet_'):\n            return\n        \n        selected_method = state.replace('withdraw_wallet_', '')\n        \n        response = f\"\"\"✅ تم استلام رقم المحفظة: {wallet_number}\n🏦 الشركة: {selected_method}\n\n💰 الآن يرجى إدخال المبلغ المطلوب سحبه:\n\nمثال: 500\"\"\"\n        \n        self.send_message(message['chat']['id'], response)\n        self.user_states[user_id] = f'withdraw_amount_{selected_method}_{wallet_number}'\n    \n    def process_withdrawal_amount(self, message):\n        \"\"\"معالجة مبلغ السحب وإنشاء الطلب\"\"\"\n        if not message['text'].isdigit():\n            self.send_message(message['chat']['id'], \"❌ يرجى إدخال مبلغ صحيح (أرقام فقط)\")\n            return\n        \n        amount = message['text']\n        user_id = message['from']['id']\n        user = self.find_user(user_id)\n        state = self.user_states.get(user_id, '')\n        \n        if not state.startswith('withdraw_amount_'):\n            return\n        \n        parts = state.replace('withdraw_amount_', '').split('_', 1)\n        selected_method = parts[0]\n        wallet_number = parts[1]\n        \n        # إنشاء المعاملة\n        trans_id = f\"WTH{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        \n        # حفظ المعاملة\n        with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n            writer = csv.writer(f)\n            writer.writerow([\n                trans_id, user['customer_id'], user['telegram_id'], user['name'], \n                'withdrawal', amount, 'pending', datetime.now().strftime('%Y-%m-%d %H:%M'), \n                '', selected_method, wallet_number, ''\n            ])\n        \n        # رسالة التأكيد للعميل\n        confirmation = f\"\"\"✅ تم إنشاء طلب السحب بنجاح!\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n🏦 الشركة: {selected_method}\n💳 المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n⏳ سيتم مراجعة طلبك خلال 24 ساعة\n🔔 سيتم إشعارك فور تغيير حالة الطلب\"\"\"\n        \n        # إشعار شامل فوري للأدمن\n        admin_notification = f\"\"\"💸 طلب سحب جديد - مكتمل!\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n📱 تيليجرام: @{message['from'].get('username', 'غير متوفر')} ({user['telegram_id']})\n📞 الهاتف: {user['phone']}\n🏦 شركة السحب: {selected_method}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ المطلوب: {amount} ريال\n📅 الوقت: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n🎯 الطلب جاهز للمعالجة:\n✅ استخدم: /approve {trans_id} للموافقة\n❌ استخدم: /reject {trans_id} السبب للرفض\n📋 استخدم: /pending للمراجعة\"\"\"\n        \n        self.notify_admins(admin_notification)\n        \n        self.send_message(message['chat']['id'], confirmation, self.main_keyboard(user.get('language', 'ar')))\n        \n        # حذف حالة المستخدم\n        if user_id in self.user_states:\n            del self.user_states[user_id]\n    \n    def prompt_add_payment_method(self, message):\n        \"\"\"طلب إضافة وسيلة دفع جديدة\"\"\"\n        response = \"\"\"📝 إضافة وسيلة دفع جديدة\n\nأرسل التفاصيل بالتنسيق التالي:\ndeposit اسم_البنك تفاصيل_الحساب\nأو\nwithdraw اسم_الشركة تفاصيل_المحفظة\n\nأمثلة:\ndeposit بنك الأهلي رقم الحساب: 1234567890, اسم المستفيد: شركة النظام\n\nwithdraw فودافون كاش رقم المحفظة: 01012345678\"\"\"\n        \n        self.send_message(message['chat']['id'], response)\n        self.user_states[message['from']['id']] = 'admin_adding_payment'\n    \n    def show_edit_payment_methods(self, message):\n        \"\"\"عرض وسائل الدفع للتعديل\"\"\"\n        all_methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                all_methods = list(csv.DictReader(f))\n        except:\n            pass\n        \n        if not all_methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد وسائل دفع\", self.admin_keyboard())\n            return\n        \n        response = \"⚙️ تعديل وسائل الدفع\\n\\n\"\n        \n        deposit_methods = [m for m in all_methods if m['type'] == 'deposit']\n        withdraw_methods = [m for m in all_methods if m['type'] == 'withdraw']\n        \n        response += \"💰 وسائل الإيداع:\\n\"\n        for i, method in enumerate(deposit_methods, 1):\n            status = \"🟢\" if method['is_active'] == 'active' else \"🔴\"\n            response += f\"{status} {i}. {method['name']}\\n\"\n        \n        response += f\"\\n💸 وسائل السحب:\\n\"\n        for i, method in enumerate(withdraw_methods, 1):\n            status = \"🟢\" if method['is_active'] == 'active' else \"🔴\"\n            response += f\"{status} {i}. {method['name']}\\n\"\n        \n        response += f\"\\n💡 لحذف وسيلة دفع: delete رقم_الوسيلة\\nمثال: delete 1\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n        self.user_states[message['from']['id']] = 'admin_editing_payment'\n    \n    def handle_start(self, message):\n        \"\"\"بدء التسجيل\"\"\"\n        user_info = message['from']\n        user = self.find_user(user_info['id'])\n        \n        if not user:\n            text = f\"مرحباً {user_info['first_name']}! 🎉\\n\\nمرحباً بك في نظام LangSense المالي المتقدم\\n\\nيرجى مشاركة رقم هاتفك لإكمال التسجيل\"\n            keyboard = {\n                'keyboard': [[{'text': '📱 مشاركة رقم الهاتف', 'request_contact': True}]],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            self.send_message(message['chat']['id'], text, keyboard)\n        else:\n            if self.is_user_banned(user_info['id']):\n                self.send_message(message['chat']['id'], f\"🚫 حسابك محظور\\nالسبب: {user.get('ban_reason', 'غير محدد')}\\n\\nتواصل مع الإدارة\")\n                return\n            \n            lang = user.get('language', 'ar')\n            text = f\"مرحباً {user['name']}! 👋\\n🆔 رقم العميل: {user['customer_id']}\\n\\nاختر الخدمة المطلوبة:\"\n            self.send_message(message['chat']['id'], text, self.main_keyboard(lang))\n    \n    def handle_contact(self, message):\n        \"\"\"معالجة مشاركة الهاتف\"\"\"\n        contact = message['contact']\n        user_info = message['from']\n        \n        if contact['user_id'] == user_info['id']:\n            customer_id = f\"C{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n            \n            with open('users.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([\n                    user_info['id'], user_info['first_name'], contact['phone_number'], \n                    customer_id, 'ar', datetime.now().strftime('%Y-%m-%d %H:%M'), 'no', ''\n                ])\n            \n            text = f\"✅ تم التسجيل بنجاح!\\n📱 الهاتف: {contact['phone_number']}\\n🆔 رقم العميل: {customer_id}\\n\\nيمكنك الآن استخدام جميع خدمات النظام\"\n            self.send_message(message['chat']['id'], text, self.main_keyboard())\n    \n    def process_deposit_amount(self, message):\n        \"\"\"معالجة مبلغ الإيداع\"\"\"\n        if not message['text'].isdigit():\n            self.send_message(message['chat']['id'], \"❌ يرجى إدخال مبلغ صحيح (أرقام فقط)\")\n            return\n        \n        amount = message['text']\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        \n        if not state.startswith('deposit_amount_'):\n            return\n        \n        trans_id = state.replace('deposit_amount_', '')\n        \n        # تحديث المعاملة بالمبلغ\n        transactions = []\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        row['amount'] = amount\n                        row['status'] = 'pending'\n                        row['receipt_info'] = 'awaiting_receipt'\n                    transactions.append(row)\n            \n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['id', 'customer_id', 'telegram_id', 'name', 'type', 'amount', 'status', 'date', 'admin_note', 'payment_method', 'receipt_info', 'processed_by']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(transactions)\n        except:\n            pass\n        \n        # إشعار فوري محسن للأدمن مع تفاصيل كاملة\n        user = self.find_user(user_id)\n        admin_notification = f\"\"\"💰 طلب إيداع محدث - مرحلة 2\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n📱 تيليجرام: {user['telegram_id']}\n💵 المبلغ المطلوب: {amount} ريال\n📅 الوقت: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n🔢 المرحلة: انتظار إيصال التحويل\n\n🎯 الطلب جاهز للمراجعة النهائية\n📋 استخدم: /pending للمراجعة\n✅ استخدم: /approve {trans_id} للموافقة\n❌ استخدم: /reject {trans_id} السبب للرفض\n\n🔔 سيتم إشعارك فور استلام الإيصال\"\"\"\n        \n        self.notify_admins(admin_notification)\n        \n        response = f\"✅ تم استلام المبلغ: {amount} ريال\\n\\n📸 الآن يرجى إرسال صورة إيصال التحويل\\n\\nبعد إرسال الإيصال، سيتم مراجعة طلبك خلال 24 ساعة\"\n        \n        self.send_message(message['chat']['id'], response)\n        self.user_states[user_id] = f'deposit_receipt_{trans_id}'\n    \n    def process_admin_search(self, message):\n        \"\"\"معالجة البحث من الأدمن\"\"\"\n        query = message['text']\n        results = self.search_users(query)\n        \n        if not results:\n            response = f\"❌ لم يتم العثور على نتائج للبحث: {query}\"\n        else:\n            response = f\"🔍 نتائج البحث عن: {query}\\n\\n\"\n            for user in results:\n                ban_status = \"🚫 محظور\" if user.get('is_banned') == 'yes' else \"✅ نشط\"\n                response += f\"👤 {user['name']}\\n🆔 {user['customer_id']}\\n📱 {user['phone']}\\n🔸 {ban_status}\\n\\n\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n        del self.user_states[message['from']['id']]\n    \n    def process_admin_broadcast(self, message):\n        \"\"\"معالجة الإرسال الجماعي\"\"\"\n        broadcast_message = message['text']\n        users_count = 0\n        success_count = 0\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                users = list(csv.DictReader(f))\n                users_count = len(users)\n                \n                for user in users:\n                    if user.get('is_banned', 'no') == 'no':\n                        try:\n                            self.send_message(user['telegram_id'], f\"📢 إعلان من الإدارة:\\n\\n{broadcast_message}\")\n                            success_count += 1\n                        except:\n                            pass\n        except:\n            pass\n        \n        response = f\"✅ تم إرسال الرسالة الجماعية\\n\\n📊 الإحصائيات:\\n👥 إجمالي المستخدمين: {users_count}\\n✅ تم الإرسال: {success_count}\\n❌ فشل: {users_count - success_count}\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n        del self.user_states[message['from']['id']]\n    \n    def process_admin_ban(self, message):\n        \"\"\"معالجة حظر مستخدم\"\"\"\n        parts = message['text'].split(' ', 1)\n        if len(parts) < 2:\n            self.send_message(message['chat']['id'], \"❌ يرجى إدخال رقم العميل والسبب\\nمثال: C000001 مخالفة الشروط\", self.admin_keyboard())\n            del self.user_states[message['from']['id']]\n            return\n        \n        customer_id = parts[0]\n        reason = parts[1] if len(parts) > 1 else 'لم يذكر سبب'\n        \n        if self.ban_user(customer_id, reason, str(message['from']['id'])):\n            # البحث عن المستخدم لإرسال إشعار له\n            user = None\n            try:\n                with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['customer_id'] == customer_id:\n                            user = row\n                            break\n            except:\n                pass\n            \n            if user:\n                try:\n                    self.send_message(user['telegram_id'], f\"🚫 تم حظر حسابك\\n\\nالسبب: {reason}\\n\\nللاستفسار تواصل مع الإدارة\")\n                except:\n                    pass\n            \n            response = f\"✅ تم حظر العميل {customer_id} بنجاح\\nالسبب: {reason}\"\n        else:\n            response = f\"❌ فشل في حظر العميل {customer_id}\\nتأكد من رقم العميل\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n        del self.user_states[message['from']['id']]\n    \n    def process_admin_unban(self, message):\n        \"\"\"معالجة إلغاء حظر مستخدم\"\"\"\n        customer_id = message['text'].strip()\n        \n        if self.unban_user(customer_id):\n            # البحث عن المستخدم لإرسال إشعار له\n            user = None\n            try:\n                with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['customer_id'] == customer_id:\n                            user = row\n                            break\n            except:\n                pass\n            \n            if user:\n                try:\n                    self.send_message(user['telegram_id'], f\"✅ تم إلغاء حظر حسابك\\n\\nيمكنك الآن استخدام جميع الخدمات\")\n                except:\n                    pass\n            \n            response = f\"✅ تم إلغاء حظر العميل {customer_id} بنجاح\"\n        else:\n            response = f\"❌ فشل في إلغاء حظر العميل {customer_id}\\nتأكد من رقم العميل\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n        del self.user_states[message['from']['id']]\n    \n    def unban_user(self, customer_id):\n        \"\"\"إلغاء حظر مستخدم\"\"\"\n        users = []\n        success = False\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        row['is_banned'] = 'no'\n                        row['ban_reason'] = ''\n                        success = True\n                    users.append(row)\n            \n            if success:\n                with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(users)\n        except:\n            pass\n        return success\n    \n    def process_admin_add_payment(self, message):\n        \"\"\"معالجة إضافة وسيلة دفع\"\"\"\n        try:\n            parts = message['text'].split(' ', 2)\n            if len(parts) < 3:\n                self.send_message(message['chat']['id'], \"❌ تنسيق خاطئ. استخدم:\\ndeposit اسم_البنك التفاصيل\", self.admin_keyboard())\n                del self.user_states[message['from']['id']]\n                return\n            \n            method_type = parts[0]\n            method_name = parts[1]\n            method_details = parts[2]\n            \n            if method_type not in ['deposit', 'withdraw']:\n                self.send_message(message['chat']['id'], \"❌ النوع يجب أن يكون deposit أو withdraw\", self.admin_keyboard())\n                del self.user_states[message['from']['id']]\n                return\n            \n            # إنشاء معرف جديد\n            new_id = str(int(datetime.now().timestamp()))\n            \n            with open('payment_methods.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([new_id, method_name, method_type, method_details, 'active', datetime.now().strftime('%Y-%m-%d')])\n            \n            response = f\"✅ تم إضافة وسيلة الدفع بنجاح!\\n🆔 المعرف: {new_id}\\n📝 {method_name} ({method_type})\"\n            \n            self.send_message(message['chat']['id'], response, self.admin_keyboard())\n            del self.user_states[message['from']['id']]\n            \n        except Exception as e:\n            self.send_message(message['chat']['id'], f\"❌ حدث خطأ: {str(e)}\", self.admin_keyboard())\n            del self.user_states[message['from']['id']]\n    \n    def process_admin_edit_payment(self, message):\n        \"\"\"معالجة تعديل/حذف وسائل الدفع\"\"\"\n        text = message['text'].strip().lower()\n        \n        if text.startswith('delete '):\n            try:\n                method_id = text.split(' ')[1]\n                \n                # قراءة جميع الوسائل\n                methods = []\n                found = False\n                with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['id'] != method_id:\n                            methods.append(row)\n                        else:\n                            found = True\n                \n                if found:\n                    # إعادة كتابة الملف بدون الوسيلة المحذوفة\n                    with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                        fieldnames = ['id', 'name', 'type', 'details', 'is_active', 'created_date']\n                        writer = csv.DictWriter(f, fieldnames=fieldnames)\n                        writer.writeheader()\n                        writer.writerows(methods)\n                    \n                    response = f\"✅ تم حذف وسيلة الدفع رقم {method_id}\"\n                else:\n                    response = f\"❌ لم يتم العثور على وسيلة دفع برقم {method_id}\"\n                    \n            except:\n                response = \"❌ خطأ في الحذف. تأكد من الرقم\"\n        else:\n            response = \"❌ أمر غير مفهوم. استخدم: delete رقم_الوسيلة\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n        del self.user_states[message['from']['id']]\n\n    def show_system_settings(self, message):\n        \"\"\"عرض إعدادات النظام\"\"\"\n        try:\n            settings_text = \"⚙️ إعدادات النظام الحالية:\\n\\n\"\n            \n            with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    settings_text += f\"🔹 <b>{row['description']}</b>\\n\"\n                    settings_text += f\"📝 المفتاح: <code>{row['setting_key']}</code>\\n\"\n                    settings_text += f\"💬 القيمة: {row['setting_value']}\\n\\n\"\n            \n            settings_text += \"\\n📖 الأوامر المتاحة:\\n\"\n            settings_text += \"/editsetting مفتاح_الإعداد القيمة_الجديدة\\n\"\n            settings_text += \"\\nمثال:\\n/editsetting support_phone +966502345678\"\n            \n            self.send_message(message['chat']['id'], settings_text, self.admin_keyboard())\n            \n        except Exception as e:\n            self.send_message(message['chat']['id'], f\"❌ خطأ في عرض الإعدادات: {str(e)}\", self.admin_keyboard())\n    \n    def handle_edit_setting(self, message):\n        \"\"\"تعديل إعداد النظام\"\"\"\n        try:\n            parts = message['text'].split(' ', 2)\n            if len(parts) < 3:\n                self.send_message(message['chat']['id'], \"❌ تنسيق خاطئ. استخدم:\\n/editsetting مفتاح_الإعداد القيمة_الجديدة\", self.admin_keyboard())\n                return\n            \n            setting_key = parts[1]\n            new_value = parts[2]\n            \n            # قراءة الإعدادات\n            settings = []\n            found = False\n            with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['setting_key'] == setting_key:\n                        row['setting_value'] = new_value\n                        found = True\n                    settings.append(row)\n            \n            if found:\n                # كتابة الإعدادات المحدثة\n                with open('system_settings.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['setting_key', 'setting_value', 'description']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(settings)\n                \n                response = f\"✅ تم تحديث {setting_key} إلى: {new_value}\"\n            else:\n                response = f\"❌ لم يتم العثور على إعداد بالمفتاح: {setting_key}\"\n                \n        except Exception as e:\n            response = f\"❌ خطأ في التعديل: {str(e)}\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def handle_add_company(self, message):\n        \"\"\"إضافة شركة جديدة\"\"\"\n        try:\n            parts = message['text'].split(' ', 3)\n            if len(parts) < 4:\n                self.send_message(message['chat']['id'], \n                    \"❌ تنسيق خاطئ. استخدم:\\n/addcompany اسم_الشركة نوع_الخدمة تفاصيل_الشركة\\n\\n\"\n                    \"مثال:\\n/addcompany \\\"فودافون كاش\\\" withdraw \\\"محفظة إلكترونية\\\"\", \n                    self.admin_keyboard())\n                return\n            \n            company_name = parts[1].strip('\"')\n            service_type = parts[2]\n            company_details = parts[3].strip('\"')\n            \n            if service_type not in ['deposit', 'withdraw', 'both']:\n                self.send_message(message['chat']['id'], \"❌ نوع الخدمة يجب أن يكون: deposit, withdraw, أو both\", self.admin_keyboard())\n                return\n            \n            # إنشاء معرف جديد\n            new_id = str(int(datetime.now().timestamp()))\n            \n            # إضافة الشركة لملف وسائل الدفع\n            with open('payment_methods.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([new_id, company_name, service_type, company_details, 'active', datetime.now().strftime('%Y-%m-%d')])\n            \n            response = f\"✅ تم إضافة الشركة بنجاح!\\n🆔 المعرف: {new_id}\\n🏢 الاسم: {company_name}\\n⚡ نوع الخدمة: {service_type}\"\n            \n        except Exception as e:\n            response = f\"❌ خطأ في إضافة الشركة: {str(e)}\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def handle_edit_company(self, message):\n        \"\"\"تعديل شركة موجودة\"\"\"\n        try:\n            parts = message['text'].split(' ', 4)\n            if len(parts) < 5:\n                self.send_message(message['chat']['id'], \n                    \"❌ تنسيق خاطئ. استخدم:\\n/editcompany معرف_الشركة اسم_جديد نوع_الخدمة تفاصيل_جديدة\", \n                    self.admin_keyboard())\n                return\n            \n            company_id = parts[1]\n            new_name = parts[2].strip('\"')\n            new_type = parts[3]\n            new_details = parts[4].strip('\"')\n            \n            # قراءة وتعديل الشركات\n            companies = []\n            found = False\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == company_id:\n                        row['name'] = new_name\n                        row['type'] = new_type\n                        row['details'] = new_details\n                        found = True\n                    companies.append(row)\n            \n            if found:\n                # إعادة كتابة الملف\n                with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'name', 'type', 'details', 'is_active', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(companies)\n                \n                response = f\"✅ تم تحديث الشركة رقم {company_id}\\n🏢 الاسم الجديد: {new_name}\"\n            else:\n                response = f\"❌ لم يتم العثور على شركة برقم {company_id}\"\n                \n        except Exception as e:\n            response = f\"❌ خطأ في تعديل الشركة: {str(e)}\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def handle_delete_company(self, message):\n        \"\"\"حذف شركة\"\"\"\n        try:\n            parts = message['text'].split(' ')\n            if len(parts) < 2:\n                self.send_message(message['chat']['id'], \"❌ استخدم: /deletecompany معرف_الشركة\", self.admin_keyboard())\n                return\n            \n            company_id = parts[1]\n            \n            # قراءة وحذف الشركة\n            companies = []\n            found = False\n            deleted_name = \"\"\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] != company_id:\n                        companies.append(row)\n                    else:\n                        found = True\n                        deleted_name = row['name']\n            \n            if found:\n                # إعادة كتابة الملف بدون الشركة المحذوفة\n                with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'name', 'type', 'details', 'is_active', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(companies)\n                \n                response = f\"✅ تم حذف الشركة: {deleted_name}\"\n            else:\n                response = f\"❌ لم يتم العثور على شركة برقم {company_id}\"\n                \n        except Exception as e:\n            response = f\"❌ خطأ في حذف الشركة: {str(e)}\"\n        \n        self.send_message(message['chat']['id'], response, self.admin_keyboard())\n    \n    def run(self):\n        \"\"\"تشغيل البوت\"\"\"\n        test_result = self.api_call('getMe')\n        if not test_result or not test_result.get('ok'):\n            logger.error(\"❌ خطأ في التوكن!\")\n            return\n        \n        bot_info = test_result['result']\n        logger.info(f\"✅ النظام المتقدم يعمل: @{bot_info['username']}\")\n        \n        while True:\n            try:\n                updates = self.get_updates()\n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        self.offset = update['update_id']\n                        if 'message' in update:\n                            message = update['message']\n                            if 'text' in message:\n                                if message['text'] == '/start':\n                                    self.handle_start(message)\n                                else:\n                                    self.handle_text(message)\n                            elif 'contact' in message:\n                                self.handle_contact(message)\n                time.sleep(1)\n            except KeyboardInterrupt:\n                logger.info(\"تم إيقاف النظام\")\n                break\n            except Exception as e:\n                logger.error(f\"خطأ: {e}\")\n                time.sleep(3)\n\nif __name__ == '__main__':\n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        print(\"❌ يرجى تعيين BOT_TOKEN\")\n        exit(1)\n    \n    bot = AdvancedLangSenseBot(bot_token)\n    bot.run()","size_bytes":76433},"bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMain bot module with Aiogram v3 setup\nHandles bot initialization, router registration, and polling\n\"\"\"\n\nimport asyncio\nimport logging\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\nfrom aiogram.fsm.storage.memory import MemoryStorage\n\nfrom config import BOT_TOKEN\nfrom handlers import start, admin, broadcast, user_settings, announcements\nfrom services.broadcast_service import BroadcastService\n\nlogger = logging.getLogger(__name__)\n\n# Global variables for dependency injection\nbot_instance = None\nsession_maker = None\nbroadcast_service = None\n\nasync def main(async_session):\n    \"\"\"Main bot function\"\"\"\n    global bot_instance, session_maker, broadcast_service\n    \n    try:\n        # Validate bot token\n        if not BOT_TOKEN:\n            raise ValueError(\"BOT_TOKEN is not set in environment variables\")\n        \n        # Initialize bot and dispatcher\n        bot_instance = Bot(\n            token=BOT_TOKEN,\n            default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n        )\n        \n        # Test bot token\n        bot_info = await bot_instance.get_me()\n        logger.info(f\"Bot initialized: @{bot_info.username} ({bot_info.first_name})\")\n        \n        # Set session maker for handlers\n        session_maker = async_session\n        \n        # Initialize dispatcher with memory storage\n        storage = MemoryStorage()\n        dp = Dispatcher(storage=storage)\n        \n        # Initialize broadcast service\n        broadcast_service = BroadcastService(bot_instance, async_session)\n        \n        # Register routers\n        dp.include_routers(\n            start.router,\n            user_settings.router,\n            admin.router,\n            broadcast.router,\n            announcements.router\n        )\n        \n        # Set session maker and services for handlers\n        for router in [start.router, user_settings.router, admin.router, \n                      broadcast.router, announcements.router]:\n            router.message.middleware.register(SessionMiddleware(async_session))\n            router.callback_query.middleware.register(SessionMiddleware(async_session))\n        \n        # Start broadcast service worker\n        asyncio.create_task(broadcast_service.worker())\n        logger.info(\"Broadcast service worker started\")\n        \n        # Start polling\n        logger.info(\"Starting bot polling...\")\n        await dp.start_polling(bot_instance)\n        \n    except Exception as e:\n        logger.error(f\"Bot startup failed: {e}\")\n        raise\n    finally:\n        if bot_instance:\n            await bot_instance.session.close()\n\nclass SessionMiddleware:\n    \"\"\"Middleware to inject database session into handlers\"\"\"\n    \n    def __init__(self, session_maker):\n        self.session_maker = session_maker\n    \n    async def __call__(self, handler, event, data):\n        data['session_maker'] = self.session_maker\n        data['broadcast_service'] = broadcast_service\n        return await handler(event, data)\n\ndef get_bot():\n    \"\"\"Get bot instance for external use\"\"\"\n    return bot_instance\n\ndef get_session_maker():\n    \"\"\"Get session maker for external use\"\"\"\n    return session_maker\n\ndef get_broadcast_service():\n    \"\"\"Get broadcast service for external use\"\"\"\n    return broadcast_service\n","size_bytes":3344},"comprehensive_bot.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport json\nimport csv\nimport urllib.request\nimport urllib.parse\nimport logging\nimport threading\nimport time\nimport zipfile\nfrom datetime import datetime\n\n# إعداد التسجيل\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass ComprehensiveDUXBot:\n    def __init__(self, token):\n        self.token = token\n        self.api_url = f\"https://api.telegram.org/bot{token}\"\n        self.offset = 0\n        self.user_states = {}\n        self.temp_company_data = {}  # إضافة المتغير المفقود\n        self.init_files()\n        self.admin_ids = self.get_admin_ids()\n        \n        # بدء نظام النسخ الاحتياطي التلقائي\n        self.start_backup_scheduler()\n        \n    def init_files(self):\n        \"\"\"إنشاء جميع ملفات النظام\"\"\"\n        # ملف المستخدمين\n        if not os.path.exists('users.csv'):\n            with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason'])\n        \n        # ملف المعاملات المتقدم\n        if not os.path.exists('transactions.csv'):\n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'telegram_id', 'name', 'type', 'company', 'wallet_number', 'amount', 'exchange_address', 'status', 'date', 'admin_note', 'processed_by'])\n        \n        # ملف الشركات\n        if not os.path.exists('companies.csv'):\n            with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'name', 'type', 'details', 'is_active'])\n                # شركات افتراضية\n                companies = [\n                    ['1', 'STC Pay', 'both', 'محفظة إلكترونية', 'active'],\n                    ['2', 'البنك الأهلي', 'deposit', 'حساب بنكي رقم: 1234567890', 'active'],\n                    ['3', 'فودافون كاش', 'both', 'محفظة إلكترونية', 'active'],\n                    ['4', 'بنك الراجحي', 'deposit', 'حساب بنكي رقم: 0987654321', 'active'],\n                    ['5', 'مدى البنك الأهلي', 'withdraw', 'رقم الحساب للسحب', 'active']\n                ]\n                for company in companies:\n                    writer.writerow(company)\n        \n        # ملف عناوين الصرافة\n        if not os.path.exists('exchange_addresses.csv'):\n            with open('exchange_addresses.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'address', 'is_active'])\n                writer.writerow(['1', 'شارع الملك فهد، الرياض، مقابل مول الرياض - الدور الأول', 'yes'])\n        \n        # ملف الشكاوى\n        if not os.path.exists('complaints.csv'):\n            with open('complaints.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'message', 'status', 'date', 'admin_response'])\n        \n        # ملف إعدادات النظام\n        if not os.path.exists('system_settings.csv'):\n            with open('system_settings.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['setting_key', 'setting_value', 'description'])\n                settings = [\n                    ['min_deposit', '50', 'أقل مبلغ إيداع'],\n                    ['min_withdrawal', '100', 'أقل مبلغ سحب'],\n                    ['max_daily_withdrawal', '10000', 'أقصى سحب يومي'],\n                    ['support_phone', '+966501234567', 'رقم الدعم'],\n                    ['company_name', 'DUX', 'اسم الشركة']\n                ]\n                for setting in settings:\n                    writer.writerow(setting)\n        \n        logger.info(\"تم إنشاء جميع ملفات النظام بنجاح\")\n        \n    def api_call(self, method, data=None):\n        \"\"\"استدعاء API مُحسن\"\"\"\n        url = f\"{self.api_url}/{method}\"\n        try:\n            if data:\n                json_data = json.dumps(data).encode('utf-8')\n                req = urllib.request.Request(url, data=json_data)\n                req.add_header('Content-Type', 'application/json')\n            else:\n                req = urllib.request.Request(url)\n            \n            with urllib.request.urlopen(req, timeout=10) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في API: {e}\")\n            return None\n    \n    def send_message(self, chat_id, text, keyboard=None):\n        \"\"\"إرسال رسالة\"\"\"\n        data = {'chat_id': chat_id, 'text': text, 'parse_mode': 'HTML'}\n        if keyboard:\n            data['reply_markup'] = keyboard\n        return self.api_call('sendMessage', data)\n    \n    def get_updates(self):\n        \"\"\"جلب التحديثات\"\"\"\n        url = f\"{self.api_url}/getUpdates?offset={self.offset + 1}&timeout=10\"\n        try:\n            with urllib.request.urlopen(url, timeout=15) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في جلب التحديثات: {e}\")\n            return None\n    \n    def get_admin_ids(self):\n        \"\"\"جلب معرفات الأدمن\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        return [admin_id.strip() for admin_id in admin_ids if admin_id.strip()]\n    \n    def is_admin(self, telegram_id):\n        \"\"\"فحص صلاحية الأدمن\"\"\"\n        return str(telegram_id) in self.admin_ids\n    \n    def notify_admins(self, message):\n        \"\"\"إشعار جميع الأدمن\"\"\"\n        for admin_id in self.admin_ids:\n            try:\n                self.send_message(admin_id, message, self.admin_keyboard())\n            except:\n                pass\n    \n    def find_user(self, telegram_id):\n        \"\"\"البحث عن مستخدم\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['telegram_id'] == str(telegram_id):\n                        return row\n        except:\n            pass\n        return None\n    \n    def get_companies(self, service_type=None):\n        \"\"\"جلب الشركات النشطة\"\"\"\n        companies = []\n        try:\n            # التأكد من وجود الملف\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    # التأكد من أن الشركة نشطة\n                    if row.get('is_active', '').lower() in ['active', 'yes', '1', 'true']:\n                        # فلترة حسب نوع الخدمة\n                        if not service_type:\n                            companies.append(row)\n                        elif row['type'] == service_type or row['type'] == 'both':\n                            companies.append(row)\n        except FileNotFoundError:\n            # إنشاء ملف الشركات إذا لم يكن موجوداً\n            with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'name', 'type', 'details', 'is_active'])\n        except Exception as e:\n            # تسجيل الخطأ للتشخيص\n            logger.error(f\"خطأ في قراءة ملف الشركات: {e}\")\n        \n        return companies\n    \n    def get_exchange_address(self):\n        \"\"\"جلب عنوان الصرافة النشط\"\"\"\n        try:\n            with open('exchange_addresses.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['is_active'] == 'yes':\n                        return row['address']\n        except:\n            pass\n        return \"العنوان غير متوفر حالياً\"\n    \n    def get_setting(self, key):\n        \"\"\"جلب إعداد النظام\"\"\"\n        try:\n            with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['setting_key'] == key:\n                        return row['setting_value']\n        except:\n            pass\n        return None\n    \n    def main_keyboard(self, lang='ar'):\n        \"\"\"القائمة الرئيسية\"\"\"\n        if lang == 'ar':\n            return {\n                'keyboard': [\n                    [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}],\n                    [{'text': '📋 طلباتي'}, {'text': '👤 حسابي'}],\n                    [{'text': '📨 شكوى'}, {'text': '🆘 دعم'}],\n                    [{'text': '🔄 إعادة تعيين'}, {'text': '🇺🇸 English'}],\n                    [{'text': '/admin'}]\n                ],\n                'resize_keyboard': True\n            }\n        else:\n            return {\n                'keyboard': [\n                    [{'text': '💰 Deposit Request'}, {'text': '💸 Withdrawal Request'}],\n                    [{'text': '📋 My Requests'}, {'text': '👤 Profile'}],\n                    [{'text': '📨 Complaint'}, {'text': '🆘 Support'}],\n                    [{'text': '🔄 Reset System'}, {'text': '🇸🇦 العربية'}],\n                    [{'text': '/admin'}]\n                ],\n                'resize_keyboard': True\n            }\n    \n    def admin_keyboard(self):\n        \"\"\"لوحة مفاتيح الأدمن الشاملة\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '📋 الطلبات المعلقة'}, {'text': '✅ طلبات مُوافقة'}],\n                [{'text': '👥 إدارة المستخدمين'}, {'text': '🔍 البحث'}],\n                [{'text': '💳 وسائل الدفع'}, {'text': '📊 الإحصائيات'}],\n                [{'text': '📢 إرسال جماعي'}, {'text': '🚫 حظر مستخدم'}],\n                [{'text': '✅ إلغاء حظر'}, {'text': '📝 إضافة شركة'}],\n                [{'text': '⚙️ إدارة الشركات'}, {'text': '📍 إدارة العناوين'}],\n                [{'text': '🛠️ تعديل بيانات الدعم'}],\n                [{'text': '⚙️ إعدادات النظام'}, {'text': '📨 الشكاوى'}],\n                [{'text': '📋 نسخ أوامر سريعة'}, {'text': '📧 إرسال رسالة لعميل'}],\n                [{'text': '💾 نسخة احتياطية فورية'}, {'text': '🔄 إعادة تعيين النظام'}],\n                [{'text': '🏠 القائمة الرئيسية'}]\n            ],\n            'resize_keyboard': True,\n            'one_time_keyboard': False\n        }\n    \n    def companies_keyboard(self, service_type):\n        \"\"\"لوحة اختيار الشركات مع تحديث فوري\"\"\"\n        companies = self.get_companies(service_type)\n        keyboard = []\n        \n        # إضافة أزرار الشركات\n        for company in companies:\n            keyboard.append([{'text': f\"🏢 {company['name']}\"}])\n        \n        # إضافة أزرار العودة وإعادة التعيين\n        keyboard.append([{'text': '🔙 العودة للقائمة الرئيسية'}, {'text': '🔄 إعادة تعيين النظام'}])\n        \n        return {'keyboard': keyboard, 'resize_keyboard': True, 'one_time_keyboard': True}\n    \n    def handle_start(self, message):\n        \"\"\"معالج بداية المحادثة\"\"\"\n        chat_id = message['chat']['id']\n        user_id = message['from']['id']\n        \n        # فحص إذا كان المستخدم موجود\n        user = self.find_user(user_id)\n        if user:\n            if user.get('is_banned') == 'yes':\n                ban_reason = user.get('ban_reason', 'غير محدد')\n                self.send_message(chat_id, f\"❌ تم حظر حسابك\\nالسبب: {ban_reason}\\n\\nللاستفسار تواصل مع الإدارة\")\n                return\n            \n            welcome_text = f\"مرحباً بعودتك {user['name']}! 👋\\n🆔 رقم العميل: {user['customer_id']}\"\n            self.send_message(chat_id, welcome_text, self.main_keyboard(user.get('language', 'ar')))\n        else:\n            welcome_text = \"\"\"مرحباً بك في نظام DUX المالي المتقدم! 👋\n\n🔹 خدمات الإيداع والسحب\n🔹 دعم فني متخصص\n🔹 أمان وموثوقية عالية\n\nيرجى إرسال اسمك الكامل للتسجيل:\"\"\"\n            self.send_message(chat_id, welcome_text)\n            self.user_states[user_id] = 'registering_name'\n    \n    def handle_registration(self, message):\n        \"\"\"معالجة التسجيل\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id)\n        \n        if state == 'registering_name':\n            name = message['text'].strip()\n            if len(name) < 2:\n                self.send_message(message['chat']['id'], \"❌ اسم قصير جداً. يرجى إدخال اسم صحيح:\")\n                return\n            \n            self.user_states[user_id] = f'registering_phone_{name}'\n            \n            # كيبورد مشاركة جهة الاتصال\n            contact_keyboard = {\n                'keyboard': [\n                    [{'text': '📱 مشاركة رقم الهاتف', 'request_contact': True}],\n                    [{'text': '✍️ كتابة الرقم يدوياً'}],\n                    [{'text': '🔄 إعادة تعيين النظام'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            phone_message = \"\"\"ممتاز! الآن أرسل رقم هاتفك:\n\n📱 يمكنك مشاركة رقمك مباشرة بالضغط على \"📱 مشاركة رقم الهاتف\"\n✍️ أو اكتب الرقم يدوياً مع رمز البلد (مثال: +966501234567)\"\"\"\n            \n            self.send_message(message['chat']['id'], phone_message, contact_keyboard)\n            \n        elif state.startswith('registering_phone_'):\n            name = state.replace('registering_phone_', '')\n            \n            # التحقق من نوع الرسالة\n            if 'contact' in message:\n                # مشاركة جهة الاتصال\n                phone = message['contact']['phone_number']\n                if not phone.startswith('+'):\n                    phone = '+' + phone\n            elif 'text' in message:\n                text = message['text'].strip()\n                \n                if text == '✍️ كتابة الرقم يدوياً':\n                    manual_text = \"\"\"✍️ اكتب رقم هاتفك مع رمز البلد:\n\nمثال: +966501234567\nمثال: +201234567890\"\"\"\n                    self.send_message(message['chat']['id'], manual_text)\n                    return\n                \n                phone = text\n                if len(phone) < 10:\n                    self.send_message(message['chat']['id'], \"❌ رقم هاتف غير صحيح. يرجى إدخال رقم صحيح مع رمز البلد:\")\n                    return\n            else:\n                self.send_message(message['chat']['id'], \"❌ يرجى مشاركة جهة الاتصال أو كتابة الرقم:\")\n                return\n            \n            # إنشاء رقم عميل تلقائي\n            customer_id = f\"C{str(int(datetime.now().timestamp()))[-6:]}\"\n            \n            # حفظ المستخدم\n            with open('users.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([user_id, name, phone, customer_id, 'ar', \n                               datetime.now().strftime('%Y-%m-%d'), 'no', ''])\n            \n            welcome_text = f\"\"\"✅ تم التسجيل بنجاح!\n\n👤 الاسم: {name}\n📱 الهاتف: {phone}\n🆔 رقم العميل: {customer_id}\n📅 تاريخ التسجيل: {datetime.now().strftime('%Y-%m-%d')}\n\nيمكنك الآن استخدام جميع الخدمات المالية:\"\"\"\n            \n            self.send_message(message['chat']['id'], welcome_text, self.main_keyboard())\n            del self.user_states[user_id]\n            \n            # إشعار الأدمن بعضو جديد\n            admin_msg = f\"\"\"🆕 عضو جديد انضم للنظام\n\n👤 الاسم: {name}\n📱 الهاتف: {phone}\n🆔 رقم العميل: {customer_id}\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\"\"\n            self.notify_admins(admin_msg)\n    \n    def create_deposit_request(self, message):\n        \"\"\"إنشاء طلب إيداع\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        # عرض الشركات المتاحة للإيداع مع تحديث فوري\n        deposit_companies = self.get_companies('deposit')\n        if not deposit_companies:\n            self.send_message(message['chat']['id'], \"❌ لا توجد شركات متاحة للإيداع حالياً\\n\\nتواصل مع الإدارة لإضافة شركات الإيداع\")\n            return\n        \n        companies_text = \"💰 طلب إيداع جديد\\n\\n🏢 اختر الشركة للإيداع:\\n\\n\"\n        for company in deposit_companies:\n            type_display = {'deposit': 'إيداع', 'withdraw': 'سحب', 'both': 'الكل'}.get(company['type'], company['type'])\n            companies_text += f\"🔹 {company['name']} ({type_display}) - {company['details']}\\n\"\n        \n        companies_text += f\"\\n📊 إجمالي الشركات المتاحة: {len(deposit_companies)}\"\n        \n        self.send_message(message['chat']['id'], companies_text, self.companies_keyboard('deposit'))\n        self.user_states[message['from']['id']] = 'selecting_deposit_company'\n    \n    def create_withdrawal_request(self, message):\n        \"\"\"إنشاء طلب سحب\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        # عرض الشركات المتاحة للسحب مع تحديث فوري\n        withdraw_companies = self.get_companies('withdraw')\n        if not withdraw_companies:\n            self.send_message(message['chat']['id'], \"❌ لا توجد شركات متاحة للسحب حالياً\\n\\nتواصل مع الإدارة لإضافة شركات السحب\")\n            return\n        \n        companies_text = \"💸 طلب سحب جديد\\n\\n🏢 اختر الشركة للسحب:\\n\\n\"\n        for company in withdraw_companies:\n            type_display = {'deposit': 'إيداع', 'withdraw': 'سحب', 'both': 'الكل'}.get(company['type'], company['type'])\n            companies_text += f\"🔹 {company['name']} ({type_display}) - {company['details']}\\n\"\n        \n        companies_text += f\"\\n📊 إجمالي الشركات المتاحة: {len(withdraw_companies)}\"\n        \n        self.send_message(message['chat']['id'], companies_text, self.companies_keyboard('withdraw'))\n        self.user_states[message['from']['id']] = 'selecting_withdraw_company'\n    \n    def process_deposit_flow(self, message):\n        \"\"\"معالجة تدفق الإيداع الكامل\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        text = message['text']\n        \n        if state == 'selecting_deposit_company':\n            # إزالة الرمز التعبيري من اسم الشركة\n            selected_company_name = text.replace('🏢 ', '')\n            \n            # البحث عن الشركة المختارة\n            companies = self.get_companies('deposit')\n            selected_company = None\n            for company in companies:\n                if company['name'] == selected_company_name:\n                    selected_company = company\n                    break\n            \n            if not selected_company:\n                self.send_message(message['chat']['id'], \"❌ اختيار غير صحيح. يرجى اختيار شركة من القائمة:\")\n                return\n            \n            # عرض وسائل الدفع للشركة المختارة\n            self.show_payment_method_selection(message, selected_company['id'], 'deposit')\n            \n        elif state.startswith('deposit_wallet_'):\n            parts = state.split('_', 3)\n            company_id = parts[2]\n            company_name = parts[3] if len(parts) > 3 else ''\n            method_id = parts[4] if len(parts) > 4 else ''\n            wallet_number = text.strip()\n            \n            if len(wallet_number) < 5:\n                self.send_message(message['chat']['id'], \"❌ رقم المحفظة/الحساب قصير جداً. يرجى إدخال رقم صحيح:\")\n                return\n            \n            # الانتقال لمرحلة إدخال المبلغ\n            min_deposit = self.get_setting('min_deposit') or '50'\n            amount_text = f\"\"\"✅ تم حفظ رقم المحفظة: {wallet_number}\n\n💰 الآن أدخل المبلغ المطلوب إيداعه:\n\n📌 أقل مبلغ للإيداع: {min_deposit} ريال\n💡 أدخل المبلغ بالأرقام فقط (مثال: 500)\"\"\"\n            \n            self.send_message(message['chat']['id'], amount_text)\n            self.user_states[user_id] = f'deposit_amount_{company_id}_{company_name}_{method_id}_{wallet_number}'\n            \n        elif state.startswith('deposit_amount_'):\n            parts = state.split('_', 4)\n            company_id = parts[2]\n            company_name = parts[3]\n            method_id = parts[4] if len(parts) > 4 else ''\n            wallet_number = parts[5] if len(parts) > 5 else ''\n            \n            try:\n                amount = float(text.strip())\n                min_deposit = float(self.get_setting('min_deposit') or '50')\n                \n                if amount < min_deposit:\n                    self.send_message(message['chat']['id'], f\"❌ أقل مبلغ للإيداع {min_deposit} ريال. يرجى إدخال مبلغ أكبر:\")\n                    return\n                    \n            except ValueError:\n                self.send_message(message['chat']['id'], \"❌ مبلغ غير صحيح. يرجى إدخال رقم صحيح:\")\n                return\n            \n            # إنشاء المعاملة\n            user = self.find_user(user_id)\n            trans_id = f\"DEP{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n            \n            # حفظ المعاملة\n            with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([trans_id, user['customer_id'], user['telegram_id'], user['name'], \n                               'deposit', company_name, wallet_number, amount, '', 'pending', \n                               datetime.now().strftime('%Y-%m-%d %H:%M'), '', ''])\n            \n            # رسالة تأكيد للعميل\n            confirmation = f\"\"\"✅ تم إرسال طلب الإيداع بنجاح\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n⏳ الحالة: في انتظار المراجعة\n\nسيتم إشعارك فور مراجعة طلبك.\"\"\"\n            \n            self.send_message(message['chat']['id'], confirmation, self.main_keyboard(user.get('language', 'ar')))\n            del self.user_states[user_id]\n            \n            # إشعار فوري للأدمن بطلب الإيداع\n            for admin_id in self.admin_ids:\n                try:\n                    admin_notification = f\"\"\"🔔 طلب إيداع جديد\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nلمراجعة الطلب: موافقة {trans_id} أو رفض {trans_id} [سبب]\"\"\"\n                    self.send_message(admin_id, admin_notification)\n                except:\n                    pass\n    \n    def process_withdrawal_flow(self, message):\n        \"\"\"معالجة تدفق السحب الكامل\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        text = message['text']\n        \n        if state == 'selecting_withdraw_company':\n            # إزالة الرمز التعبيري من اسم الشركة\n            selected_company_name = text.replace('🏢 ', '')\n            \n            # البحث عن الشركة المختارة\n            companies = self.get_companies('withdraw')\n            selected_company = None\n            for company in companies:\n                if company['name'] == selected_company_name:\n                    selected_company = company\n                    break\n            \n            if not selected_company:\n                self.send_message(message['chat']['id'], \"❌ اختيار غير صحيح. يرجى اختيار شركة من القائمة:\")\n                return\n            \n            # عرض وسائل الدفع للشركة المختارة\n            self.show_payment_method_selection(message, selected_company['id'], 'withdraw')\n            \n        elif state.startswith('withdraw_wallet_'):\n            parts = state.split('_', 3)\n            company_id = parts[2]\n            company_name = parts[3] if len(parts) > 3 else ''\n            method_id = parts[4] if len(parts) > 4 else ''\n            wallet_number = text.strip()\n            \n            if len(wallet_number) < 5:\n                self.send_message(message['chat']['id'], \"❌ رقم المحفظة/الحساب قصير جداً. يرجى إدخال رقم صحيح:\")\n                return\n            \n            # الانتقال لمرحلة إدخال المبلغ\n            min_withdrawal = self.get_setting('min_withdrawal') or '100'\n            max_withdrawal = self.get_setting('max_daily_withdrawal') or '10000'\n            amount_text = f\"\"\"✅ تم حفظ رقم المحفظة: {wallet_number}\n\n💰 الآن أدخل المبلغ المطلوب سحبه:\n\n📌 أقل مبلغ للسحب: {min_withdrawal} ريال\n📌 أقصى مبلغ يومي: {max_withdrawal} ريال\n💡 أدخل المبلغ بالأرقام فقط (مثال: 1000)\"\"\"\n            \n            self.send_message(message['chat']['id'], amount_text)\n            self.user_states[user_id] = f'withdraw_amount_{company_id}_{company_name}_{method_id}_{wallet_number}'\n            \n        elif state.startswith('withdraw_amount_'):\n            parts = state.split('_', 4)\n            company_id = parts[2]\n            company_name = parts[3]\n            method_id = parts[4] if len(parts) > 4 else ''\n            wallet_number = parts[5] if len(parts) > 5 else ''\n            \n            try:\n                amount = float(text.strip())\n                min_withdrawal = float(self.get_setting('min_withdrawal') or '100')\n                max_withdrawal = float(self.get_setting('max_daily_withdrawal') or '10000')\n                \n                if amount < min_withdrawal:\n                    self.send_message(message['chat']['id'], f\"❌ أقل مبلغ للسحب {min_withdrawal} ريال. يرجى إدخال مبلغ أكبر:\")\n                    return\n                \n                if amount > max_withdrawal:\n                    self.send_message(message['chat']['id'], f\"❌ أقصى مبلغ للسحب اليومي {max_withdrawal} ريال. يرجى إدخال مبلغ أقل:\")\n                    return\n                    \n            except ValueError:\n                self.send_message(message['chat']['id'], \"❌ مبلغ غير صحيح. يرجى إدخال رقم صحيح:\")\n                return\n            \n            # عرض عنوان السحب الثابت وطلب كود التأكيد\n            withdrawal_address = self.get_exchange_address()\n            \n            confirm_text = f\"\"\"✅ تم تأكيد المبلغ: {amount} ريال\n\n📍 عنوان السحب: \n{withdrawal_address}\n\n🔐 يرجى إرسال كود التأكيد:\"\"\"\n            \n            self.send_message(message['chat']['id'], confirm_text)\n            self.user_states[user_id] = f'withdraw_confirmation_code_{company_id}_{company_name}_{wallet_number}_{amount}_{withdrawal_address}'\n            \n\n        elif state.startswith('withdraw_confirmation_code_'):\n            # فصل البيانات من الحالة\n            data_part = state.replace('withdraw_confirmation_code_', '')\n            parts = data_part.split('_')\n            company_id = parts[0] if len(parts) > 0 else ''\n            company_name = parts[1] if len(parts) > 1 else ''\n            wallet_number = parts[2] if len(parts) > 2 else ''\n            amount = parts[3] if len(parts) > 3 else ''\n            withdrawal_address = parts[4] if len(parts) > 4 else ''\n            confirmation_code = text.strip()\n            \n            if len(confirmation_code) < 3:\n                self.send_message(message['chat']['id'], \"❌ كود التأكيد قصير جداً. يرجى إدخال كود صحيح:\")\n                return\n            \n            # التأكيد النهائي مع أزرار\n            final_confirm_text = f\"\"\"📋 مراجعة نهائية لطلب السحب:\n\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📍 عنوان السحب: {withdrawal_address}\n🔐 كود التأكيد: {confirmation_code}\n\nاختر من الأزرار أدناه:\"\"\"\n            \n            # إنشاء لوحة مفاتيح التأكيد\n            confirm_keyboard = {\n                'keyboard': [\n                    [{'text': '✅ تأكيد الطلب'}, {'text': '❌ إلغاء'}],\n                    [{'text': '🔄 إعادة تعيين النظام'}, {'text': '🏠 القائمة الرئيسية'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            self.send_message(message['chat']['id'], final_confirm_text, confirm_keyboard)\n            self.user_states[user_id] = f'withdraw_final_confirm_{company_id}_{company_name}_{wallet_number}_{amount}_{withdrawal_address}_{confirmation_code}'\n            \n        elif state.startswith('withdraw_final_confirm_'):\n            # فصل البيانات من الحالة\n            data_part = state.replace('withdraw_final_confirm_', '')\n            parts = data_part.split('_')\n            company_id = parts[0] if len(parts) > 0 else ''\n            company_name = parts[1] if len(parts) > 1 else ''\n            wallet_number = parts[2] if len(parts) > 2 else ''\n            amount = parts[3] if len(parts) > 3 else ''\n            withdrawal_address = parts[4] if len(parts) > 4 else ''\n            confirmation_code = parts[5] if len(parts) > 5 else ''\n            \n            # معالجة أزرار التأكيد والإلغاء\n            if text == '✅ تأكيد الطلب':\n                # إنشاء المعاملة\n                user = self.find_user(user_id)\n                trans_id = f\"WTH{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n                \n                # حفظ المعاملة مع عنوان السحب وكود التأكيد\n                with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow([trans_id, user['customer_id'], user['telegram_id'], user['name'], \n                                   'withdraw', company_name, wallet_number, amount, withdrawal_address, 'pending', \n                                   datetime.now().strftime('%Y-%m-%d %H:%M'), confirmation_code, ''])\n                \n                # رسالة تأكيد للعميل\n                confirmation_msg = f\"\"\"✅ تم إرسال طلب السحب بنجاح\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📍 عنوان السحب: {withdrawal_address}\n🔐 كود التأكيد: {confirmation_code}\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n⏳ الحالة: في انتظار المراجعة\n\nسيتم إشعارك فور الموافقة على طلبك.\"\"\"\n                \n                self.send_message(message['chat']['id'], confirmation_msg, self.main_keyboard(user.get('language', 'ar')))\n                del self.user_states[user_id]\n                \n                # إشعار فوري للأدمن\n                for admin_id in self.admin_ids:\n                    try:\n                        admin_notification = f\"\"\"🔔 طلب سحب جديد\n\n🆔 رقم المعاملة: {trans_id}\n👤 العميل: {user['name']} ({user['customer_id']})\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📍 عنوان السحب: {withdrawal_address}\n🔐 كود التأكيد: {confirmation_code}\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nلمراجعة الطلب: موافقة {trans_id} أو رفض {trans_id} [سبب]\"\"\"\n                        self.send_message(admin_id, admin_notification)\n                    except:\n                        pass\n                \n            elif text == '❌ إلغاء':\n                user = self.find_user(user_id)\n                self.send_message(message['chat']['id'], \"❌ تم إلغاء طلب السحب\", self.main_keyboard(user.get('language', 'ar')))\n                del self.user_states[user_id]\n                \n            elif text == '🏠 القائمة الرئيسية':\n                user = self.find_user(user_id)\n                del self.user_states[user_id]\n                welcome_text = f\"\"\"🏠 مرحباً بك في النظام المالي\n\n👤 العميل: {user.get('name', 'غير محدد')}\n🆔 رقم العميل: {user.get('customer_id', 'غير محدد')}\n\nاختر الخدمة المطلوبة:\"\"\"\n                self.send_message(message['chat']['id'], welcome_text, self.main_keyboard(user.get('language', 'ar')))\n                \n            else:\n                self.send_message(message['chat']['id'], \"❌ يرجى اختيار من الأزرار المتاحة\")\n            \n        # (معالج قديم محذوف لأن نظام السحب تم تحديثه)\n    \n    def show_user_transactions(self, message):\n        \"\"\"عرض معاملات المستخدم\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        transactions_text = f\"📋 طلبات العميل: {user['name']}\\n\\n\"\n        found_transactions = False\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == user['customer_id']:\n                        found_transactions = True\n                        status_emoji = \"⏳\" if row['status'] == 'pending' else \"✅\" if row['status'] == 'approved' else \"❌\"\n                        type_emoji = \"💰\" if row['type'] == 'deposit' else \"💸\"\n                        \n                        transactions_text += f\"{status_emoji} {type_emoji} {row['id']}\\n\"\n                        transactions_text += f\"🏢 {row['company']}\\n\"\n                        transactions_text += f\"💰 {row['amount']} ريال\\n\"\n                        transactions_text += f\"📅 {row['date']}\\n\"\n                        \n                        if row['status'] == 'rejected' and row.get('admin_note'):\n                            transactions_text += f\"📝 السبب: {row['admin_note']}\\n\"\n                        elif row['status'] == 'approved':\n                            transactions_text += f\"✅ تمت الموافقة\\n\"\n                        elif row['status'] == 'pending':\n                            transactions_text += f\"⏳ قيد المراجعة\\n\"\n                        \n                        transactions_text += \"\\n\"\n        except:\n            pass\n        \n        if not found_transactions:\n            transactions_text += \"لا توجد معاملات سابقة\"\n        \n        self.send_message(message['chat']['id'], transactions_text, self.main_keyboard(user.get('language', 'ar')))\n    \n    def show_user_profile(self, message):\n        \"\"\"عرض ملف المستخدم\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        profile_text = f\"\"\"👤 ملف العميل\n\n🆔 رقم العميل: {user['customer_id']}\n📛 الاسم: {user['name']}\n📱 الهاتف: {user['phone']}\n📅 تاريخ التسجيل: {user['date']}\n🌐 اللغة: {'العربية' if user.get('language') == 'ar' else 'English'}\n\n🔸 حالة الحساب: {'🚫 محظور' if user.get('is_banned') == 'yes' else '✅ نشط'}\"\"\"\n        \n        if user.get('is_banned') == 'yes' and user.get('ban_reason'):\n            profile_text += f\"\\n📝 سبب الحظر: {user['ban_reason']}\"\n        \n        self.send_message(message['chat']['id'], profile_text, self.main_keyboard(user.get('language', 'ar')))\n    \n    def handle_admin_panel(self, message):\n        \"\"\"لوحة تحكم الأدمن الرئيسية\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        admin_welcome = \"\"\"🔧 لوحة تحكم الأدمن\n\nمرحباً بك في لوحة التحكم الشاملة\nاستخدم الأزرار أدناه للتنقل\"\"\"\n        \n        self.send_message(message['chat']['id'], admin_welcome, self.admin_keyboard())\n    \n    def process_message(self, message):\n        \"\"\"معالج الرسائل الرئيسي\"\"\"\n        if 'text' not in message and 'contact' not in message:\n            return\n        \n        text = message.get('text', '')\n        chat_id = message['chat']['id']\n        user_id = message['from']['id']\n        \n        # بداية المحادثة\n        if text == '/start':\n            self.handle_start(message)\n            return\n            \n        # معالجة زر إعادة التعيين أولاً (أولوية عالية)\n        if text in ['🔄 إعادة تعيين النظام', '🔄 Reset System', '🔄 إعادة تعيين', '🆘 إصلاح شامل']:\n            user = self.find_user(user_id)\n            if user:\n                self.super_reset_user_system(user_id, chat_id, user)\n            else:\n                self.handle_start(message)\n            return\n        \n        # معالجة الحالات المختلفة\n        if user_id in self.user_states:\n            state = self.user_states[user_id]\n            \n            # معالجة التسجيل\n            if isinstance(state, str) and state.startswith('registering'):\n                self.handle_registration(message)\n                return\n            \n            # معالجة الإيداع والسحب\n            elif isinstance(state, str) and ('deposit' in state or 'withdraw' in state):\n                if 'deposit' in state:\n                    self.process_deposit_flow(message)\n                else:\n                    self.process_withdrawal_flow(message)\n                return\n            \n            # معالجة اختيار وسيلة الدفع\n            elif isinstance(state, dict) and state.get('step') == 'selecting_payment_method':\n                self.handle_payment_method_selection(message, text)\n                return\n        \n        # فحص المستخدم المسجل\n        user = self.find_user(user_id)\n        if not user:\n            self.handle_start(message)\n            return\n        \n        # فحص الحظر\n        if user.get('is_banned') == 'yes':\n            ban_reason = user.get('ban_reason', 'غير محدد')\n            self.send_message(chat_id, f\"❌ تم حظر حسابك\\nالسبب: {ban_reason}\")\n            return\n        \n        # معالجة أوامر الأدمن\n        if self.is_admin(user_id):\n            if text == '/admin':\n                self.handle_admin_panel(message)\n                return\n            \n            # معالجة حالات الأدمن الخاصة\n            if user_id in self.user_states:\n                admin_state = self.user_states[user_id]\n                if isinstance(admin_state, str):\n                    if admin_state == 'admin_broadcasting':\n                        self.send_broadcast_message(message, text)\n                        return\n                    elif admin_state.startswith('adding_company_'):\n                        self.handle_company_wizard(message)\n                        return\n                    elif admin_state.startswith('editing_company_') or admin_state == 'selecting_company_edit':\n                        self.handle_company_edit_wizard(message)\n                        return\n                    elif admin_state == 'confirming_company_delete':\n                        self.handle_company_delete_confirmation(message)\n                        return\n                    elif admin_state.startswith('deleting_company_'):\n                        company_id = admin_state.replace('deleting_company_', '')\n                        self.finalize_company_delete(message, company_id)\n                        return\n                    elif admin_state == 'sending_user_message_id':\n                        self.handle_user_message_id(message)\n                        return\n                    elif admin_state.startswith('sending_user_message_'):\n                        customer_id = admin_state.replace('sending_user_message_', '')\n                        self.handle_user_message_content(message, customer_id)\n                        return\n                    elif admin_state == 'selecting_method_to_edit':\n                        self.handle_method_edit_selection(message)\n                        return\n                    elif admin_state == 'selecting_method_to_delete':\n                        self.handle_method_delete_selection(message)\n                        return\n                    elif admin_state.startswith('editing_method_'):\n                        method_id = admin_state.replace('editing_method_', '')\n                        self.handle_method_edit_data(message, method_id)\n                        return\n                    elif admin_state == 'adding_payment_simple':\n                        self.handle_simple_payment_company_selection(message)\n                        return\n                    elif admin_state.startswith('adding_payment_method_'):\n                        self.handle_simple_payment_method_data(message)\n                        return\n                    elif admin_state == 'selecting_method_to_edit_simple':\n                        self.handle_simple_method_edit_selection(message)\n                        return\n                    elif admin_state == 'selecting_method_to_delete_simple':\n                        self.handle_simple_method_delete_selection(message)\n                        return\n                    elif admin_state.startswith('editing_method_simple_'):\n                        method_id = admin_state.replace('editing_method_simple_', '')\n                        self.handle_simple_method_edit_data(message, method_id)\n                        return\n                    elif admin_state == 'selecting_method_to_disable':\n                        self.handle_method_disable_selection(message)\n                        return\n                    elif admin_state == 'selecting_method_to_enable':\n                        self.handle_method_enable_selection(message)\n                        return\n                    elif admin_state.startswith('replying_to_complaint_'):\n                        complaint_id = admin_state.replace('replying_to_complaint_', '')\n                        self.handle_complaint_reply_buttons(message, complaint_id)\n                        return\n                    elif admin_state.startswith('editing_support_'):\n                        self.handle_support_data_edit(message, admin_state)\n                        return\n\n            \n            # معالجة النصوص والأزرار للأدمن\n            self.handle_admin_actions(message)\n            return\n        \n        # معالجة القوائم الرئيسية للمستخدمين\n        if text in ['💰 طلب إيداع', '💰 Deposit Request']:\n            logger.info(f\"معالجة طلب إيداع من {user_id}\")\n            self.create_deposit_request(message)\n        elif text in ['💸 طلب سحب', '💸 Withdrawal Request']:\n            logger.info(f\"معالجة طلب سحب من {user_id}\")\n            self.create_withdrawal_request(message)\n        elif text in ['📋 طلباتي', '📋 My Requests']:\n            self.show_user_transactions(message)\n        elif text in ['👤 حسابي', '👤 Profile']:\n            self.show_user_profile(message)\n        elif text in ['📨 شكوى', '📨 Complaint']:\n            self.handle_complaint_start(message)\n        elif text in ['🆘 دعم', '🆘 Support']:\n            support_text = f\"\"\"🆘 الدعم الفني\n\n📞 رقم الهاتف: {self.get_setting('support_phone') or '+966501234567'}\n⏰ ساعات العمل: 24/7\n🏢 الشركة: DUX\n\nيمكنك أيضاً إرسال شكوى من خلال النظام\"\"\"\n            self.send_message(chat_id, support_text, self.main_keyboard(user.get('language', 'ar')))\n        elif text in ['🇺🇸 English', '🇸🇦 العربية']:\n            self.handle_language_change(message, text)\n        elif text in ['🔙 العودة للقائمة الرئيسية', '🔙 العودة', '⬅️ العودة', '🏠 الرئيسية', '🏠 القائمة الرئيسية', '🔄 إعادة تعيين', '🔄 إعادة تعيين النظام', '🆘 إصلاح', 'reset', 'fix', '🔄 Reset System', '🆘 إصلاح شامل']:\n            # إجراء إعادة تعيين شاملة وقوية\n            self.super_reset_user_system(user_id, chat_id, user)\n        else:\n            # معالجة حالات المستخدم الخاصة\n            if user_id in self.user_states:\n                state = self.user_states[user_id]\n                if state == 'writing_complaint':\n                    self.save_complaint(message, text)\n                    return\n            \n            # رسالة خطأ محسنة مع زر إصلاح قوي\n            error_keyboard = {\n                'keyboard': [\n                    [{'text': '🔄 إعادة تعيين النظام'}, {'text': '🆘 إصلاح شامل'}],\n                    [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}],\n                    [{'text': '📋 طلباتي'}, {'text': '👤 حسابي'}],\n                    [{'text': '🏠 القائمة الرئيسية'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            error_msg = f\"\"\"❌ أمر غير مفهوم أو خطأ في النظام\n\n🔧 لحل أي مشكلة، اختر:\n• 🔄 إعادة تعيين النظام - إصلاح بسيط\n• 🆘 إصلاح شامل - حل جميع المشاكل\n\nأو اختر من الخدمات المتاحة:\"\"\"\n            \n            self.send_message(chat_id, error_msg, error_keyboard)\n    \n    def super_reset_user_system(self, user_id, chat_id, user):\n        \"\"\"إعادة تعيين شاملة وقوية للنظام\"\"\"\n        try:\n            logger.info(f\"بدء إعادة تعيين شاملة للمستخدم: {user_id}\")\n            \n            # 1. تنظيف جميع حالات المستخدم\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n                logger.info(f\"تم حذف حالة المستخدم: {user_id}\")\n            \n            # 2. تنظيف البيانات المؤقتة\n            temp_data_attrs = [\n                'temp_company_data',\n                'edit_company_data', \n                'temp_deposit_data',\n                'temp_withdrawal_data',\n                'temp_complaint_data',\n                'temp_payment_data',\n                'admin_temp_data'\n            ]\n            \n            for attr in temp_data_attrs:\n                if hasattr(self, attr) and user_id in getattr(self, attr, {}):\n                    del getattr(self, attr)[user_id]\n                    logger.info(f\"تم حذف {attr} للمستخدم: {user_id}\")\n            \n            # 3. إعادة تحميل بيانات المستخدم من الملف\n            fresh_user = self.find_user(user_id)\n            if fresh_user:\n                user.update(fresh_user)\n                logger.info(f\"تم إعادة تحميل بيانات المستخدم: {user_id}\")\n            \n            # 4. التحقق من سلامة الملفات الأساسية وإصلاحها\n            self.verify_and_fix_system_files()\n            \n            # 5. إرسال رسالة نجاح مع معلومات محدثة\n            welcome_text = f\"\"\"✅ تم إعادة تعيين النظام بنجاح!\n\n🔧 تم إجراء التالي:\n• تنظيف جميع الحالات المؤقتة\n• إعادة تحميل البيانات الشخصية\n• فحص سلامة النظام\n• إصلاح أي أخطاء محتملة\n\n👤 بياناتك المحدثة:\n🏷️ الاسم: {user.get('name', 'غير محدد')}\n🆔 رقم العميل: {user.get('customer_id', 'غير محدد')}\n📱 الهاتف: {user.get('phone', 'غير محدد')}\n🌐 اللغة: {'العربية' if user.get('language', 'ar') == 'ar' else 'English'}\n\n🏠 النظام جاهز للاستخدام - اختر الخدمة المطلوبة:\"\"\"\n            \n            # إرسال الرسالة مع الكيبورد المناسب\n            if self.is_admin(user_id):\n                keyboard = self.admin_keyboard()\n            else:\n                keyboard = self.main_keyboard(user.get('language', 'ar'))\n                \n            self.send_message(chat_id, welcome_text, keyboard)\n            logger.info(f\"تمت إعادة التعيين الشاملة بنجاح للمستخدم: {user_id}\")\n            \n        except Exception as e:\n            logger.error(f\"خطأ في إعادة التعيين الشاملة للمستخدم {user_id}: {e}\")\n            \n            # في حالة فشل إعادة التعيين، إرسال رسالة طوارئ\n            emergency_text = \"\"\"🚨 حدث خطأ في إعادة التعيين\n\n🔧 يرجى المحاولة مرة أخرى أو التواصل مع الدعم الفني\n\n⚡ رقم الدعم: +966501234567\"\"\"\n            \n            emergency_keyboard = {\n                'keyboard': [\n                    [{'text': '🆘 إصلاح شامل'}, {'text': '🔄 إعادة تعيين النظام'}],\n                    [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}]\n                ],\n                'resize_keyboard': True\n            }\n            \n            self.send_message(chat_id, emergency_text, emergency_keyboard)\n    \n    def verify_and_fix_system_files(self):\n        \"\"\"فحص وإصلاح ملفات النظام الأساسية\"\"\"\n        try:\n            # التحقق من وجود الملفات الأساسية وإنشاؤها إذا لزم الأمر\n            required_files = [\n                'users.csv',\n                'transactions.csv', \n                'companies.csv',\n                'complaints.csv',\n                'payment_methods.csv',\n                'exchange_addresses.csv'\n            ]\n            \n            for file_name in required_files:\n                if not os.path.exists(file_name):\n                    logger.warning(f\"ملف مفقود يتم إنشاؤه: {file_name}\")\n                    self.init_files()  # إعادة إنشاء جميع الملفات\n                    break\n                    \n            logger.info(\"تم فحص سلامة ملفات النظام بنجاح\")\n            \n        except Exception as e:\n            logger.error(f\"خطأ في فحص ملفات النظام: {e}\")\n\n    def handle_admin_actions(self, message):\n        \"\"\"معالجة إجراءات الأدمن\"\"\"\n        text = message['text']\n        chat_id = message['chat']['id']\n        user_id = message['from']['id']\n        \n        # الأزرار الرئيسية\n        if text == '📋 الطلبات المعلقة':\n            self.show_pending_requests(message)\n        elif text == '✅ طلبات مُوافقة':\n            self.show_approved_transactions(message)\n        elif text == '👥 إدارة المستخدمين':\n            self.show_users_management(message)\n        elif text == '🔍 البحث':\n            self.prompt_admin_search(message)\n        elif text == '💳 وسائل الدفع':\n            self.show_payment_methods_management(message)\n        elif text == '📊 الإحصائيات':\n            self.show_detailed_stats(message)\n        elif text == '📢 إرسال جماعي':\n            self.prompt_broadcast(message)\n        elif text == '🚫 حظر مستخدم':\n            self.prompt_ban_user(message)\n        elif text == '✅ إلغاء حظر':\n            self.prompt_unban_user(message)\n        \n        # معالجة أوامر النص المباشرة\n        elif text.startswith('حظر '):\n            parts = text.split(' ', 2)\n            if len(parts) >= 3:\n                customer_id = parts[1]\n                reason = parts[2]\n                self.ban_user_admin(message, customer_id, reason)\n            else:\n                self.send_message(chat_id, \"❌ الصيغة الصحيحة:\\nحظر [رقم_العميل] [سبب_الحظر]\\nمثال: حظر C810563 مخالفة الشروط\", self.admin_keyboard())\n        \n        elif text.startswith('الغاء_حظر ') or text.startswith('الغاء حظر '):\n            customer_id = text.replace('الغاء_حظر ', '').replace('الغاء حظر ', '').strip()\n            if customer_id:\n                self.unban_user_admin(message, customer_id)\n            else:\n                self.send_message(chat_id, \"❌ الصيغة الصحيحة:\\nالغاء_حظر [رقم_العميل]\\nمثال: الغاء_حظر C810563\", self.admin_keyboard())\n        elif text == '📝 إضافة شركة':\n            self.start_add_company_wizard(message)\n        elif text == '⚙️ إدارة الشركات':\n            self.show_companies_management_enhanced(message)\n        elif text == '🔄 تحديث القائمة':\n            self.show_companies_management_enhanced(message)\n        elif text == '➕ إضافة شركة جديدة':\n            self.prompt_add_company(message)\n        elif text == '✏️ تعديل شركة':\n            self.prompt_edit_company(message)\n        elif text == '🗑️ حذف شركة':\n            self.prompt_delete_company(message)\n        elif text == '🔄 تحديث القائمة':\n            self.show_companies_management_enhanced(message)\n        elif text in ['↩️ العودة للوحة الأدمن', '🏠 لوحة الأدمن']:\n            self.handle_admin_panel(message)\n        elif text in ['↩️ العودة', '🔙 العودة', '⬅️ العودة']:\n            # تحديد السياق المناسب للعودة حسب الحالة\n            user_state = self.user_states.get(message['from']['id'])\n            if user_state:\n                if 'payment' in str(user_state) or 'method' in str(user_state):\n                    self.show_payment_methods_management(message)\n                elif 'company' in str(user_state):\n                    self.show_companies_management_enhanced(message)\n                else:\n                    self.handle_admin_panel(message)\n            else:\n                self.handle_admin_panel(message)\n        elif text == '📍 إدارة العناوين':\n            self.show_addresses_management(message)\n        elif text == '🛠️ تعديل بيانات الدعم':\n            self.show_support_data_editor(message)\n        elif text == '📞 تعديل رقم الهاتف':\n            self.start_phone_edit_wizard(message)\n        elif text == '💬 تعديل حساب التليجرام':\n            self.start_telegram_edit_wizard(message)\n        elif text == '📧 تعديل البريد الإلكتروني':\n            self.start_email_edit_wizard(message)\n        elif text == '🕒 تعديل ساعات العمل':\n            self.start_hours_edit_wizard(message)\n        elif text == '🔄 تحديث بيانات الدعم':\n            self.show_support_data_editor(message)\n        elif text == '⚙️ إعدادات النظام':\n            self.show_system_settings(message)\n        elif text == '📨 الشكاوى':\n            self.show_complaints_admin(message)\n        elif text in ['🔄 تحديث الشكاوى', '🔄 تحديث']:\n            self.show_complaints_admin(message)\n        elif text.startswith('📞 رد على '):\n            complaint_id = text.replace('📞 رد على ', '').strip()\n            self.start_complaint_reply_wizard(message, complaint_id)\n        elif text == '📋 نسخ أوامر سريعة':\n            self.show_quick_copy_commands(message)\n        elif text == '📧 إرسال رسالة لعميل':\n            self.start_send_user_message(message)\n        elif text == '💾 نسخة احتياطية فورية':\n            self.manual_backup_command(message)\n        elif text == '➕ إضافة وسيلة دفع':\n            self.start_simple_payment_method_wizard(message)\n        elif text == '✏️ تعديل وسيلة دفع':\n            self.start_edit_payment_method_wizard(message)\n        elif text == '🗑️ حذف وسيلة دفع':\n            self.start_delete_payment_method_wizard(message)\n        elif text == '📊 عرض وسائل الدفع':\n            self.show_all_payment_methods_simplified(message)\n        elif text == '⏹️ إيقاف وسيلة دفع':\n            self.start_disable_payment_method_wizard(message)\n        elif text == '▶️ تشغيل وسيلة دفع':\n            self.start_enable_payment_method_wizard(message)\n        elif text in ['🏠 القائمة الرئيسية', '🏠 الرئيسية']:\n            # إنهاء جلسة الأدمن والعودة للقائمة الرئيسية\n            if message['from']['id'] in self.user_states:\n                del self.user_states[message['from']['id']]\n            user = self.find_user(message['from']['id'])\n            if user:\n                welcome_text = f\"\"\"🏠 مرحباً بك مرة أخرى\n\n👤 العميل: {user.get('name', 'غير محدد')}\n🆔 رقم العميل: {user.get('customer_id', 'غير محدد')}\n\nاختر الخدمة المطلوبة:\"\"\"\n                self.send_message(chat_id, welcome_text, self.main_keyboard(user.get('language', 'ar')))\n        \n        # أوامر نصية للأدمن (مبسطة مع احتمالات متعددة)\n        elif any(word in text.lower() for word in ['موافقة', 'موافق', 'اوافق', 'أوافق', 'قبول', 'مقبول', 'تأكيد', 'تاكيد', 'نعم']):\n            # استخراج رقم المعاملة\n            words = text.split()\n            trans_id = None\n            for word in words:\n                if any(word.startswith(prefix) for prefix in ['DEP', 'WTH']):\n                    trans_id = word\n                    break\n            \n            if trans_id:\n                self.approve_transaction(message, trans_id)\n            else:\n                self.send_message(message['chat']['id'], \"❌ لم يتم العثور على رقم المعاملة. مثال: موافقة DEP123456\", self.admin_keyboard())\n                \n        elif any(word in text.lower() for word in ['رفض', 'رافض', 'لا', 'مرفوض', 'إلغاء', 'الغاء', 'منع']):\n            # استخراج رقم المعاملة والسبب\n            words = text.split()\n            trans_id = None\n            reason_start = -1\n            \n            for i, word in enumerate(words):\n                if any(word.startswith(prefix) for prefix in ['DEP', 'WTH']):\n                    trans_id = word\n                    reason_start = i + 1\n                    break\n            \n            if trans_id:\n                reason = ' '.join(words[reason_start:]) if reason_start != -1 and reason_start < len(words) else 'غير محدد'\n                self.reject_transaction(message, trans_id, reason)\n            else:\n                self.send_message(message['chat']['id'], \"❌ لم يتم العثور على رقم المعاملة. مثال: رفض DEP123456 سبب الرفض\", self.admin_keyboard())\n        elif text.startswith('بحث '):\n            query = text.replace('بحث ', '')\n            self.search_users_admin(message, query)\n        elif text.startswith('حظر '):\n            parts = text.replace('حظر ', '').split(' ', 1)\n            customer_id = parts[0]\n            reason = parts[1] if len(parts) > 1 else 'مخالفة الشروط'\n            self.ban_user_admin(message, customer_id, reason)\n        elif text.startswith('الغاء_حظر '):\n            customer_id = text.replace('الغاء_حظر ', '')\n            self.unban_user_admin(message, customer_id)\n        elif text.startswith('اضافة_شركة '):\n            self.add_company_simple_with_display(message, text)\n        elif text.startswith('حذف_شركة '):\n            company_id = text.replace('حذف_شركة ', '')\n            self.delete_company_simple(message, company_id)\n        elif text.startswith('عنوان_جديد '):\n            new_address = text.replace('عنوان_جديد ', '')\n            self.update_address_simple(message, new_address)\n        elif any(word in text.lower() for word in ['عنوان', 'العنوان', 'تحديث_عنوان']):\n            # استخراج العنوان الجديد\n            new_address = text\n            for word in ['عنوان', 'العنوان', 'تحديث_عنوان']:\n                new_address = new_address.replace(word, '').strip()\n            if new_address:\n                self.update_address_simple(message, new_address)\n            else:\n                self.send_message(message['chat']['id'], \"يرجى كتابة العنوان الجديد. مثال: عنوان شارع الملك فهد\", self.admin_keyboard())\n        elif text.startswith('تعديل_اعداد '):\n            self.update_setting_simple(message, text)\n        elif text == '✅ حفظ الشركة':\n            # التعامل مع حفظ الشركة - تنفيذ مباشر\n            if user_id in self.user_states and self.user_states[user_id] == 'confirming_company':\n                if user_id in self.temp_company_data:\n                    company_data = self.temp_company_data[user_id]\n                    company_id = str(int(datetime.now().timestamp()))\n                    \n                    try:\n                        # حفظ الشركة في الملف\n                        with open('companies.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                            writer = csv.writer(f)\n                            writer.writerow([company_id, company_data['name'], company_data['type'], company_data['details'], 'active'])\n                        \n                        success_msg = f\"\"\"🎉 تم إضافة الشركة بنجاح!\n\n🆔 المعرف: {company_id}\n🏢 الاسم: {company_data['name']}\n⚡ النوع: {company_data['type_display']}\n📋 التفاصيل: {company_data['details']}\n\nالشركة متاحة الآن للعملاء ✅\"\"\"\n                        \n                        self.send_message(chat_id, success_msg, self.admin_keyboard())\n                        \n                        # تنظيف البيانات المؤقتة\n                        del self.user_states[user_id]\n                        del self.temp_company_data[user_id]\n                        \n                    except Exception as e:\n                        self.send_message(chat_id, f\"❌ فشل في حفظ الشركة: {str(e)}\", self.admin_keyboard())\n                else:\n                    self.send_message(chat_id, \"❌ لا توجد بيانات شركة محفوظة\", self.admin_keyboard())\n            else:\n                self.send_message(chat_id, \"❌ لا توجد شركة للحفظ. ابدأ بإضافة شركة جديدة أولاً.\", self.admin_keyboard())\n        elif text == '✅ حفظ التغييرات':\n            # التعامل مع حفظ تغييرات الشركة\n            if user_id in self.user_states and self.user_states[user_id] == 'editing_company_menu':\n                self.save_company_changes(message)\n            else:\n                self.send_message(chat_id, \"❌ لا توجد تغييرات للحفظ. ابدأ بتعديل شركة أولاً.\", self.admin_keyboard())\n        elif text in ['❌ إلغاء', 'إلغاء', 'الغاء']:\n            # إلغاء العملية الحالية\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            if user_id in self.edit_company_data:\n                del self.edit_company_data[user_id]\n            self.send_message(chat_id, \"❌ تم إلغاء العملية\", self.admin_keyboard())\n        else:\n            self.send_message(chat_id, \"أمر غير مفهوم. استخدم الأزرار أو الأوامر الصحيحة.\", self.admin_keyboard())\n    \n    def show_pending_requests(self, message):\n        \"\"\"عرض الطلبات المعلقة للأدمن مع أوامر نسخ سهلة\"\"\"\n        pending_text = \"📋 الطلبات المعلقة:\\n\\n\"\n        found_pending = False\n        copy_commands = []\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['status'] == 'pending':\n                        found_pending = True\n                        type_emoji = \"💰\" if row['type'] == 'deposit' else \"💸\"\n                        \n                        pending_text += f\"{type_emoji} **{row['id']}**\\n\"\n                        pending_text += f\"👤 {row['name']} ({row['customer_id']})\\n\"\n                        pending_text += f\"🏢 {row['company']}\\n\"\n                        pending_text += f\"💳 {row['wallet_number']}\\n\"\n                        pending_text += f\"💰 {row['amount']} ريال\\n\"\n                        \n                        if row.get('exchange_address'):\n                            pending_text += f\"📍 {row['exchange_address']}\\n\"\n                        \n                        pending_text += f\"📅 {row['date']}\\n\"\n                        \n                        # إضافة أوامر النسخ السريع\n                        pending_text += f\"\\n📋 **أوامر سريعة للنسخ:**\\n\"\n                        pending_text += f\"✅ `موافقة {row['id']}`\\n\"\n                        pending_text += f\"❌ `رفض {row['id']} السبب_هنا`\\n\"\n                        pending_text += f\"▫️▫️▫️▫️▫️▫️▫️▫️▫️▫️\\n\\n\"\n                        \n                        # حفظ الأوامر للنسخ الجماعي\n                        copy_commands.append({\n                            'id': row['id'],\n                            'approve': f\"موافقة {row['id']}\",\n                            'reject': f\"رفض {row['id']} السبب_هنا\"\n                        })\n        except:\n            pass\n        \n        if not found_pending:\n            pending_text += \"✅ لا توجد طلبات معلقة\"\n        else:\n            # إضافة قسم الأوامر الجاهزة للنسخ\n            pending_text += \"\\n🔥 **أوامر جاهزة للنسخ المباشر:**\\n\\n\"\n            \n            for cmd in copy_commands:\n                pending_text += f\"**{cmd['id']}:**\\n\"\n                pending_text += f\"✅ `{cmd['approve']}`\\n\"\n                pending_text += f\"❌ `{cmd['reject']}`\\n\\n\"\n            \n            pending_text += \"💡 **طرق سهلة للاستخدام:**\\n\"\n            pending_text += \"• انقر على الأمر واختر 'نسخ'\\n\"\n            pending_text += \"• أو اكتب مباشرة: موافقة + رقم المعاملة\\n\"\n            pending_text += \"• للرفض: رفض + رقم المعاملة + السبب\\n\\n\"\n            \n            pending_text += \"📝 **أمثلة أوامر الموافقة:**\\n\"\n            pending_text += \"`موافقة` أو `موافق` أو `تأكيد` أو `نعم`\\n\\n\"\n            \n            pending_text += \"📝 **أمثلة أوامر الرفض:**\\n\"\n            pending_text += \"`رفض` أو `لا` أو `مرفوض` أو `إلغاء`\"\n        \n        self.send_message(message['chat']['id'], pending_text, self.admin_keyboard())\n    \n    def approve_transaction(self, message, trans_id):\n        \"\"\"الموافقة على معاملة\"\"\"\n        success = self.update_transaction_status(trans_id, 'approved', '', str(message['from']['id']))\n        \n        if success:\n            # إشعار العميل\n            transaction = self.get_transaction(trans_id)\n            if transaction:\n                customer_telegram_id = transaction.get('telegram_id')\n                if customer_telegram_id:\n                    type_text = \"الإيداع\" if transaction['type'] == 'deposit' else \"السحب\"\n                    customer_msg = f\"\"\"✅ تمت الموافقة على طلب {type_text}\n\n🆔 {trans_id}\n💰 {transaction['amount']} ريال\n🏢 {transaction['company']}\n📅 {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n{'شكراً لك! تم تأكيد إيداعك.' if transaction['type'] == 'deposit' else 'يرجى زيارة مكتب الصرافة لاستلام المبلغ.'}\"\"\"\n                    \n                    user = self.find_user(customer_telegram_id)\n                    lang = user.get('language', 'ar') if user else 'ar'\n                    self.send_message(customer_telegram_id, customer_msg, self.main_keyboard(lang))\n            \n            self.send_message(message['chat']['id'], f\"✅ تمت الموافقة على {trans_id}\", self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في الموافقة على {trans_id}\", self.admin_keyboard())\n    \n    def reject_transaction(self, message, trans_id, reason):\n        \"\"\"رفض معاملة\"\"\"\n        success = self.update_transaction_status(trans_id, 'rejected', reason, str(message['from']['id']))\n        \n        if success:\n            # إشعار العميل\n            transaction = self.get_transaction(trans_id)\n            if transaction:\n                customer_telegram_id = transaction.get('telegram_id')\n                if customer_telegram_id:\n                    type_text = \"الإيداع\" if transaction['type'] == 'deposit' else \"السحب\"\n                    customer_msg = f\"\"\"❌ تم رفض طلب {type_text}\n\n🆔 {trans_id}\n💰 {transaction['amount']} ريال\n📝 السبب: {reason}\n📅 {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nيمكنك إنشاء طلب جديد أو التواصل مع الدعم.\"\"\"\n                    \n                    user = self.find_user(customer_telegram_id)\n                    lang = user.get('language', 'ar') if user else 'ar'\n                    self.send_message(customer_telegram_id, customer_msg, self.main_keyboard(lang))\n            \n            self.send_message(message['chat']['id'], f\"✅ تم رفض {trans_id}\\nالسبب: {reason}\", self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في رفض {trans_id}\", self.admin_keyboard())\n    \n    def update_transaction_status(self, trans_id, new_status, note='', admin_id=''):\n        \"\"\"تحديث حالة المعاملة\"\"\"\n        transactions = []\n        success = False\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        row['status'] = new_status\n                        if note:\n                            row['admin_note'] = note\n                        if admin_id:\n                            row['processed_by'] = admin_id\n                        success = True\n                    transactions.append(row)\n            \n            if success:\n                with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'customer_id', 'telegram_id', 'name', 'type', 'company', 'wallet_number', 'amount', 'exchange_address', 'status', 'date', 'admin_note', 'processed_by']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(transactions)\n        except:\n            pass\n        \n        return success\n    \n    def get_transaction(self, trans_id):\n        \"\"\"جلب معاملة محددة\"\"\"\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        return row\n        except:\n            pass\n        return None\n    \n    def show_detailed_stats(self, message):\n        \"\"\"عرض إحصائيات مفصلة\"\"\"\n        stats_text = \"📊 إحصائيات النظام الشاملة\\n\\n\"\n        \n        # إحصائيات المستخدمين\n        total_users = 0\n        banned_users = 0\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    total_users += 1\n                    if row.get('is_banned') == 'yes':\n                        banned_users += 1\n        except:\n            pass\n        \n        # إحصائيات المعاملات\n        total_transactions = 0\n        pending_count = 0\n        approved_count = 0\n        rejected_count = 0\n        total_deposit_amount = 0\n        total_withdraw_amount = 0\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    total_transactions += 1\n                    amount = float(row.get('amount', 0))\n                    \n                    if row['status'] == 'pending':\n                        pending_count += 1\n                    elif row['status'] == 'approved':\n                        approved_count += 1\n                        if row['type'] == 'deposit':\n                            total_deposit_amount += amount\n                        else:\n                            total_withdraw_amount += amount\n                    elif row['status'] == 'rejected':\n                        rejected_count += 1\n        except:\n            pass\n        \n        # إحصائيات الشكاوى\n        total_complaints = 0\n        try:\n            with open('complaints.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                total_complaints = sum(1 for row in reader)\n        except:\n            pass\n        \n        stats_text += f\"👥 المستخدمون:\\n\"\n        stats_text += f\"├ إجمالي المستخدمين: {total_users}\\n\"\n        stats_text += f\"├ المستخدمون النشطون: {total_users - banned_users}\\n\"\n        stats_text += f\"└ المستخدمون المحظورون: {banned_users}\\n\\n\"\n        \n        stats_text += f\"💰 المعاملات:\\n\"\n        stats_text += f\"├ إجمالي المعاملات: {total_transactions}\\n\"\n        stats_text += f\"├ معلقة: {pending_count}\\n\"\n        stats_text += f\"├ مُوافق عليها: {approved_count}\\n\"\n        stats_text += f\"└ مرفوضة: {rejected_count}\\n\\n\"\n        \n        stats_text += f\"💵 المبالغ المُوافق عليها:\\n\"\n        stats_text += f\"├ إجمالي الإيداعات: {total_deposit_amount:,.0f} ريال\\n\"\n        stats_text += f\"├ إجمالي السحوبات: {total_withdraw_amount:,.0f} ريال\\n\"\n        stats_text += f\"└ الفرق: {total_deposit_amount - total_withdraw_amount:,.0f} ريال\\n\\n\"\n        \n        stats_text += f\"📨 الشكاوى: {total_complaints}\\n\\n\"\n        stats_text += f\"📅 تاريخ التقرير: {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\n        \n        self.send_message(message['chat']['id'], stats_text, self.admin_keyboard())\n    \n    def add_company_simple_with_display(self, message, text):\n        \"\"\"إضافة شركة مع عرض القائمة المحدثة\"\"\"\n        result = self.add_company_simple(message, text)\n        if result:\n            # عرض قائمة الشركات المحدثة فوراً\n            self.show_companies_management_enhanced(message)\n    \n    def add_company_simple(self, message, text):\n        \"\"\"إضافة شركة بصيغة مبسطة\"\"\"\n        # تنسيق: اضافة_شركة اسم نوع تفاصيل\n        parts = text.replace('اضافة_شركة ', '').split(' ', 2)\n        if len(parts) < 3:\n            help_text = \"\"\"❌ طريقة إضافة الشركة:\n\n📝 اكتب بالضبط:\nاضافة_شركة اسم_الشركة نوع_الخدمة التفاصيل\n\n🔹 أنواع الخدمة (بالإنجليزي):\n• ايداع → deposit\n• سحب → withdraw  \n• ايداع وسحب → both\n\n📋 أمثلة صحيحة:\n▫️ اضافة_شركة مدى both محفظة_رقمية\n▫️ اضافة_شركة البنك_الأهلي deposit حساب_بنكي\n▫️ اضافة_شركة فودافون_كاش withdraw محفظة_الكترونية\n▫️ اضافة_شركة STC_Pay both خدمات_دفع\"\"\"\n            \n            self.send_message(message['chat']['id'], help_text, self.admin_keyboard())\n            return\n        \n        company_name = parts[0].replace('_', ' ')\n        service_type = parts[1].lower()\n        details = parts[2].replace('_', ' ')\n        \n        # قبول الكلمات العربية وتحويلها\n        if service_type in ['ايداع', 'إيداع']:\n            service_type = 'deposit'\n        elif service_type in ['سحب']:\n            service_type = 'withdraw'\n        elif service_type in ['كلاهما', 'الكل', 'ايداع_وسحب']:\n            service_type = 'both'\n        \n        if service_type not in ['deposit', 'withdraw', 'both']:\n            error_text = \"\"\"❌ نوع الخدمة خطأ!\n\n✅ الأنواع المقبولة:\n• deposit (للإيداع فقط)\n• withdraw (للسحب فقط)\n• both (للإيداع والسحب)\n\nأو بالعربي:\n• ايداع → deposit\n• سحب → withdraw\n• كلاهما → both\n\nمثال صحيح:\nاضافة_شركة مدى both محفظة_رقمية\"\"\"\n            \n            self.send_message(message['chat']['id'], error_text, self.admin_keyboard())\n            return\n        \n        # إنشاء معرف جديد\n        company_id = str(int(datetime.now().timestamp()))\n        \n        try:\n            # التأكد من وجود الملف وإنشاؤه إذا لم يكن موجوداً\n            file_exists = True\n            try:\n                with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                    pass\n            except FileNotFoundError:\n                file_exists = False\n            \n            # إنشاء الملف مع الرؤوس إذا لم يكن موجوداً\n            if not file_exists:\n                with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow(['id', 'name', 'type', 'details', 'is_active'])\n            \n            # إضافة الشركة الجديدة\n            with open('companies.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([company_id, company_name, service_type, details, 'active'])\n            \n            # رسالة النجاح مع عرض قائمة الشركات المحدثة\n            success_msg = f\"\"\"✅ تم إضافة الشركة بنجاح!\n\n🆔 المعرف: {company_id}\n🏢 الاسم: {company_name}\n⚡ النوع: {service_type}\n📋 التفاصيل: {details}\n\n📋 قائمة الشركات المحدثة:\"\"\"\n            \n            # عرض جميع الشركات\n            try:\n                with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    company_count = 0\n                    for row in reader:\n                        company_count += 1\n                        status = \"✅\" if row.get('is_active') == 'active' else \"❌\"\n                        type_display = {'deposit': 'إيداع', 'withdraw': 'سحب', 'both': 'الكل'}.get(row['type'], row['type'])\n                        success_msg += f\"\\n{status} {row['name']} (ID: {row['id']}) - {type_display}\"\n                    \n                    success_msg += f\"\\n\\n📊 إجمالي الشركات: {company_count}\"\n            except:\n                pass\n            \n            self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n            return True\n            \n        except Exception as e:\n            self.send_message(message['chat']['id'], f\"❌ فشل في إضافة الشركة: {str(e)}\", self.admin_keyboard())\n            return False\n    \n    def update_address_simple(self, message, new_address):\n        \"\"\"تحديث عنوان الصرافة\"\"\"\n        try:\n            with open('exchange_addresses.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'address', 'is_active'])\n                writer.writerow(['1', new_address, 'yes'])\n            \n            self.send_message(message['chat']['id'], f\"✅ تم تحديث عنوان الصرافة:\\n{new_address}\", self.admin_keyboard())\n        except Exception as e:\n            self.send_message(message['chat']['id'], f\"❌ فشل في تحديث العنوان: {str(e)}\", self.admin_keyboard())\n    \n    def run(self):\n        \"\"\"تشغيل البوت\"\"\"\n        logger.info(f\"✅ نظام DUX الشامل يعمل: @{os.getenv('BOT_TOKEN', 'unknown').split(':')[0] if os.getenv('BOT_TOKEN') else 'unknown'}\")\n        \n        while True:\n            try:\n                updates = self.get_updates()\n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        self.offset = update['update_id']\n                        \n                        if 'message' in update:\n                            message = update['message']\n                            # تسجيل الرسائل للتشخيص\n                            if 'text' in message:\n                                logger.info(f\"رسالة مستلمة: {message['text']} من {message['from']['id']}\")\n                            try:\n                                self.process_message(message)\n                            except Exception as msg_error:\n                                logger.error(f\"خطأ في معالجة الرسالة: {msg_error}\")\n                                # إرسال رسالة خطأ للمستخدم\n                                try:\n                                    error_keyboard = {\n                                        'keyboard': [\n                                            [{'text': '🔄 إعادة تعيين النظام'}],\n                                            [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}]\n                                        ],\n                                        'resize_keyboard': True\n                                    }\n                                    self.send_message(message['chat']['id'], \n                                                    \"❌ حدث خطأ. اضغط على 'إعادة تعيين النظام' للإصلاح\", \n                                                    error_keyboard)\n                                except:\n                                    pass\n                        elif 'callback_query' in update:\n                            pass  # يمكن إضافة معالجة الأزرار المتقدمة لاحقاً\n                            \n            except KeyboardInterrupt:\n                logger.info(\"تم إيقاف البوت\")\n                break\n            except Exception as e:\n                logger.error(f\"خطأ عام: {e}\")\n                import time\n                time.sleep(1)  # انتظار قصير قبل المحاولة مرة أخرى\n                continue\n\n    def handle_complaint_start(self, message):\n        \"\"\"بدء عملية الشكوى\"\"\"\n        self.send_message(message['chat']['id'], \"📨 أرسل شكواك أو استفسارك:\")\n        self.user_states[message['from']['id']] = 'writing_complaint'\n    \n    def handle_language_change(self, message, text):\n        \"\"\"تغيير اللغة\"\"\"\n        user_id = message['from']['id']\n        new_lang = 'en' if '🇺🇸' in text else 'ar'\n        \n        # تحديث لغة المستخدم في الملف\n        users = []\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['telegram_id'] == str(user_id):\n                        row['language'] = new_lang\n                    users.append(row)\n            \n            with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(users)\n            \n            welcome_msg = \"Language changed to English!\" if new_lang == 'en' else \"تم تغيير اللغة إلى العربية!\"\n            self.send_message(message['chat']['id'], welcome_msg, self.main_keyboard(new_lang))\n        except:\n            pass\n    \n    def prompt_admin_search(self, message):\n        \"\"\"طلب البحث من الأدمن\"\"\"\n        search_help = \"\"\"🔍 البحث في النظام\n\nأرسل: بحث متبوعاً بالنص المطلوب\n\nيمكنك البحث بـ:\n• اسم العميل\n• رقم العميل\n• رقم الهاتف\n\nمثال: بحث أحمد\"\"\"\n        self.send_message(message['chat']['id'], search_help, self.admin_keyboard())\n    \n    def prompt_broadcast(self, message):\n        \"\"\"طلب الإرسال الجماعي\"\"\"\n        broadcast_help = \"\"\"📢 الإرسال الجماعي\n\nأرسل رسالة وسيتم إرسالها لجميع المستخدمين النشطين.\nاكتب الرسالة مباشرة:\"\"\"\n        self.send_message(message['chat']['id'], broadcast_help)\n        self.user_states[message['from']['id']] = 'admin_broadcasting'\n    \n    def prompt_ban_user(self, message):\n        \"\"\"طلب حظر مستخدم\"\"\"\n        ban_help = \"\"\"🚫 حظر مستخدم\n\nالصيغة: حظر رقم_العميل السبب\n\nمثال: حظر C123456 مخالفة الشروط\"\"\"\n        self.send_message(message['chat']['id'], ban_help, self.admin_keyboard())\n    \n    def prompt_unban_user(self, message):\n        \"\"\"طلب إلغاء حظر مستخدم مع عرض المستخدمين المحظورين\"\"\"\n        # البحث عن المستخدمين المحظورين\n        banned_users = []\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row.get('is_banned', 'no') == 'yes':\n                        banned_users.append({\n                            'customer_id': row['customer_id'],\n                            'name': row['name'],\n                            'ban_reason': row.get('ban_reason', 'غير محدد')\n                        })\n        except:\n            pass\n        \n        unban_help = \"\"\"✅ إلغاء حظر مستخدم\n\n📝 الصيغة الصحيحة:\nالغاء_حظر [رقم_العميل]\nأو: الغاء حظر [رقم_العميل]\n\nمثال:\nالغاء_حظر C810563\"\"\"\n        \n        if banned_users:\n            unban_help += \"\\n\\n🚫 المستخدمين المحظورين حالياً:\\n\"\n            for user in banned_users:\n                unban_help += f\"\\n🆔 {user['customer_id']}\\n\"\n                unban_help += f\"👤 {user['name']}\\n\"\n                unban_help += f\"📝 السبب: {user['ban_reason']}\\n\"\n                unban_help += f\"⚡ `الغاء_حظر {user['customer_id']}`\\n\"\n                unban_help += \"▫️▫️▫️▫️▫️▫️▫️▫️▫️▫️\\n\"\n        else:\n            unban_help += \"\\n\\n✅ لا يوجد مستخدمين محظورين حالياً\"\n        \n        self.send_message(message['chat']['id'], unban_help, self.admin_keyboard())\n    \n    def prompt_add_company(self, message):\n        \"\"\"بدء معالج إضافة شركة التفاعلي\"\"\"\n        help_text = \"\"\"🏢 معالج إضافة شركة جديدة\n        \nسأطلب منك المعلومات خطوة بخطوة:\n\n📝 أولاً، أرسل اسم الشركة:\nمثال: البنك الأهلي، مدى، STC Pay، فودافون كاش\"\"\"\n        \n        self.send_message(message['chat']['id'], help_text)\n        self.user_states[message['from']['id']] = 'adding_company_name'\n    \n    def handle_company_wizard(self, message):\n        \"\"\"معالج إضافة الشركة التفاعلي\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id)\n        text = message.get('text', '').strip()\n        \n        if state == 'adding_company_name':\n            # حفظ اسم الشركة\n            if not hasattr(self, 'temp_company_data'):\n                self.temp_company_data = {}\n            if user_id not in self.temp_company_data:\n                self.temp_company_data[user_id] = {}\n            \n            self.temp_company_data[user_id]['name'] = text\n            \n            # طلب نوع الخدمة\n            service_keyboard = {\n                'keyboard': [\n                    [{'text': '💳 إيداع فقط'}, {'text': '💰 سحب فقط'}],\n                    [{'text': '🔄 إيداع وسحب معاً'}],\n                    [{'text': '❌ إلغاء'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            self.send_message(message['chat']['id'], \n                f\"✅ تم حفظ اسم الشركة: {text}\\n\\n🔧 الآن اختر نوع الخدمة:\", \n                service_keyboard)\n            self.user_states[user_id] = 'adding_company_type'\n            \n        elif state == 'adding_company_type':\n            # حفظ نوع الخدمة\n            if text == '💳 إيداع فقط':\n                service_type = 'deposit'\n                service_display = 'إيداع فقط'\n            elif text == '💰 سحب فقط':\n                service_type = 'withdraw'\n                service_display = 'سحب فقط'\n            elif text == '🔄 إيداع وسحب معاً':\n                service_type = 'both'\n                service_display = 'إيداع وسحب'\n            elif text == '❌ إلغاء':\n                del self.user_states[user_id]\n                if hasattr(self, 'temp_company_data') and user_id in self.temp_company_data:\n                    del self.temp_company_data[user_id]\n                self.send_message(message['chat']['id'], \"❌ تم إلغاء إضافة الشركة\", self.admin_keyboard())\n                return\n            else:\n                self.send_message(message['chat']['id'], \"❌ اختر نوع الخدمة من الأزرار المتاحة\")\n                return\n            \n            self.temp_company_data[user_id]['type'] = service_type\n            self.temp_company_data[user_id]['type_display'] = service_display\n            \n            # طلب التفاصيل\n            self.send_message(message['chat']['id'], \n                f\"✅ نوع الخدمة: {service_display}\\n\\n📋 الآن أرسل تفاصيل الشركة:\\nمثال: محفظة إلكترونية، حساب بنكي رقم 1234567890، خدمة دفع رقمية\")\n            self.user_states[user_id] = 'adding_company_details'\n            \n        elif state == 'adding_company_details':\n            # حفظ التفاصيل وإنهاء العملية\n            self.temp_company_data[user_id]['details'] = text\n            \n            # عرض ملخص التأكيد\n            company_data = self.temp_company_data[user_id]\n            confirm_text = f\"\"\"📊 ملخص الشركة الجديدة:\n\n🏢 الاسم: {company_data['name']}\n⚡ نوع الخدمة: {company_data['type_display']}\n📋 التفاصيل: {company_data['details']}\n\nهل تريد حفظ هذه الشركة؟\"\"\"\n            \n            confirm_keyboard = {\n                'keyboard': [\n                    [{'text': '✅ حفظ الشركة'}, {'text': '❌ إلغاء'}],\n                    [{'text': '🔄 تعديل الاسم'}, {'text': '🔧 تعديل النوع'}, {'text': '📝 تعديل التفاصيل'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            self.send_message(message['chat']['id'], confirm_text, confirm_keyboard)\n            self.user_states[user_id] = 'confirming_company'\n            \n        elif state == 'confirming_company':\n            company_data = self.temp_company_data[user_id]\n            \n            if text == '✅ حفظ الشركة':\n                # تجنب تشغيل نفس الكود مرتين - هذا يُعالج الآن في handle_admin_actions\n                pass\n                    \n            elif text == '❌ إلغاء':\n                del self.user_states[user_id]\n                if user_id in self.temp_company_data:\n                    del self.temp_company_data[user_id]\n                self.send_message(message['chat']['id'], \"❌ تم إلغاء إضافة الشركة\", self.admin_keyboard())\n                \n            elif text == '🔄 تعديل الاسم':\n                self.send_message(message['chat']['id'], f\"📝 الاسم الحالي: {company_data['name']}\\n\\nأرسل الاسم الجديد:\")\n                self.user_states[user_id] = 'adding_company_name'\n                \n            elif text == '🔧 تعديل النوع':\n                service_keyboard = {\n                    'keyboard': [\n                        [{'text': '💳 إيداع فقط'}, {'text': '💰 سحب فقط'}],\n                        [{'text': '🔄 إيداع وسحب معاً'}],\n                        [{'text': '❌ إلغاء'}]\n                    ],\n                    'resize_keyboard': True,\n                    'one_time_keyboard': True\n                }\n                self.send_message(message['chat']['id'], f\"🔧 النوع الحالي: {company_data['type_display']}\\n\\nاختر النوع الجديد:\", service_keyboard)\n                self.user_states[user_id] = 'adding_company_type'\n                \n            elif text == '📝 تعديل التفاصيل':\n                self.send_message(message['chat']['id'], f\"📋 التفاصيل الحالية: {company_data['details']}\\n\\nأرسل التفاصيل الجديدة:\")\n                self.user_states[user_id] = 'adding_company_details'\n                \n            else:\n                self.send_message(message['chat']['id'], \"❌ اختر من الأزرار المتاحة\")\n    \n    def prompt_edit_company(self, message):\n        \"\"\"بدء معالج تعديل الشركة\"\"\"\n        # عرض الشركات المتاحة للتعديل\n        companies_text = \"🔧 تعديل الشركات:\\n\\n\"\n        \n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    status = \"✅\" if row.get('is_active') == 'active' else \"❌\"\n                    companies_text += f\"{status} {row['id']} - {row['name']}\\n\"\n                    companies_text += f\"   📋 {row['type']} - {row['details']}\\n\\n\"\n        except:\n            companies_text += \"❌ لا توجد شركات\\n\\n\"\n        \n        companies_text += \"📝 أرسل رقم معرف الشركة التي تريد تعديلها:\"\n        \n        self.send_message(message['chat']['id'], companies_text)\n        self.user_states[message['from']['id']] = 'selecting_company_edit'\n    \n    def handle_company_edit_wizard(self, message):\n        \"\"\"معالج تعديل الشركة التفاعلي\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id)\n        text = message.get('text', '').strip()\n        \n        if state == 'selecting_company_edit':\n            # البحث عن الشركة\n            company_found = None\n            try:\n                with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['id'] == text:\n                            company_found = row\n                            break\n            except:\n                pass\n            \n            if not company_found:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على شركة بالمعرف: {text}\")\n                return\n            \n            # حفظ بيانات الشركة للتعديل\n            if not hasattr(self, 'edit_company_data'):\n                self.edit_company_data = {}\n            self.edit_company_data[user_id] = company_found\n            \n            # عرض بيانات الشركة الحالية\n            type_display = {'deposit': 'إيداع فقط', 'withdraw': 'سحب فقط', 'both': 'إيداع وسحب'}.get(company_found['type'], company_found['type'])\n            \n            edit_options = f\"\"\"📊 بيانات الشركة الحالية:\n\n🆔 المعرف: {company_found['id']}\n🏢 الاسم: {company_found['name']}\n⚡ النوع: {type_display}\n📋 التفاصيل: {company_found['details']}\n🔘 الحالة: {'نشط' if company_found.get('is_active') == 'active' else 'غير نشط'}\n\nماذا تريد تعديل؟\"\"\"\n            \n            edit_keyboard = {\n                'keyboard': [\n                    [{'text': '📝 تعديل الاسم'}, {'text': '🔧 تعديل النوع'}],\n                    [{'text': '📋 تعديل التفاصيل'}, {'text': '🔘 تغيير الحالة'}],\n                    [{'text': '✅ حفظ التغييرات'}, {'text': '❌ إلغاء'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            self.send_message(message['chat']['id'], edit_options, edit_keyboard)\n            self.user_states[user_id] = 'editing_company_menu'\n            \n        elif state == 'editing_company_menu':\n            if text == '📝 تعديل الاسم':\n                current_name = self.edit_company_data[user_id]['name']\n                self.send_message(message['chat']['id'], f\"📝 الاسم الحالي: {current_name}\\n\\nأرسل الاسم الجديد:\")\n                self.user_states[user_id] = 'editing_company_name'\n                \n            elif text == '🔧 تعديل النوع':\n                service_keyboard = {\n                    'keyboard': [\n                        [{'text': '💳 إيداع فقط'}, {'text': '💰 سحب فقط'}],\n                        [{'text': '🔄 إيداع وسحب معاً'}],\n                        [{'text': '↩️ العودة للقائمة'}]\n                    ],\n                    'resize_keyboard': True,\n                    'one_time_keyboard': True\n                }\n                current_type = {'deposit': 'إيداع فقط', 'withdraw': 'سحب فقط', 'both': 'إيداع وسحب'}.get(self.edit_company_data[user_id]['type'])\n                self.send_message(message['chat']['id'], f\"🔧 النوع الحالي: {current_type}\\n\\nاختر النوع الجديد:\", service_keyboard)\n                self.user_states[user_id] = 'editing_company_type'\n                \n            elif text == '📋 تعديل التفاصيل':\n                current_details = self.edit_company_data[user_id]['details']\n                self.send_message(message['chat']['id'], f\"📋 التفاصيل الحالية: {current_details}\\n\\nأرسل التفاصيل الجديدة:\")\n                self.user_states[user_id] = 'editing_company_details'\n                \n            elif text == '🔘 تغيير الحالة':\n                current_status = self.edit_company_data[user_id].get('is_active', 'active')\n                new_status = 'inactive' if current_status == 'active' else 'active'\n                status_text = 'نشط' if new_status == 'active' else 'غير نشط'\n                \n                self.edit_company_data[user_id]['is_active'] = new_status\n                self.send_message(message['chat']['id'], f\"✅ تم تغيير حالة الشركة إلى: {status_text}\")\n                \n                # العودة لقائمة التعديل\n                self.show_edit_menu(message, user_id)\n                \n            elif text == '✅ حفظ التغييرات':\n                self.save_company_changes(message)\n                \n            elif text == '❌ إلغاء':\n                del self.user_states[user_id]\n                if user_id in self.edit_company_data:\n                    del self.edit_company_data[user_id]\n                self.send_message(message['chat']['id'], \"❌ تم إلغاء تعديل الشركة\", self.admin_keyboard())\n                \n        elif state == 'editing_company_name':\n            self.edit_company_data[user_id]['name'] = text\n            self.send_message(message['chat']['id'], f\"✅ تم تحديث الاسم إلى: {text}\")\n            self.show_edit_menu(message, user_id)\n            \n        elif state == 'editing_company_type':\n            if text == '💳 إيداع فقط':\n                self.edit_company_data[user_id]['type'] = 'deposit'\n                self.send_message(message['chat']['id'], \"✅ تم تحديث النوع إلى: إيداع فقط\")\n            elif text == '💰 سحب فقط':\n                self.edit_company_data[user_id]['type'] = 'withdraw'\n                self.send_message(message['chat']['id'], \"✅ تم تحديث النوع إلى: سحب فقط\")\n            elif text == '🔄 إيداع وسحب معاً':\n                self.edit_company_data[user_id]['type'] = 'both'\n                self.send_message(message['chat']['id'], \"✅ تم تحديث النوع إلى: إيداع وسحب\")\n            elif text == '↩️ العودة للقائمة':\n                pass\n            else:\n                self.send_message(message['chat']['id'], \"❌ اختر نوع الخدمة من الأزرار المتاحة\")\n                return\n            \n            self.show_edit_menu(message, user_id)\n            \n        elif state == 'editing_company_details':\n            self.edit_company_data[user_id]['details'] = text\n            self.send_message(message['chat']['id'], f\"✅ تم تحديث التفاصيل إلى: {text}\")\n            self.show_edit_menu(message, user_id)\n    \n    def show_edit_menu(self, message, user_id):\n        \"\"\"عرض قائمة تعديل الشركة\"\"\"\n        company_data = self.edit_company_data[user_id]\n        type_display = {'deposit': 'إيداع فقط', 'withdraw': 'سحب فقط', 'both': 'إيداع وسحب'}.get(company_data['type'], company_data['type'])\n        \n        edit_options = f\"\"\"📊 بيانات الشركة المحدثة:\n\n🆔 المعرف: {company_data['id']}\n🏢 الاسم: {company_data['name']}\n⚡ النوع: {type_display}\n📋 التفاصيل: {company_data['details']}\n🔘 الحالة: {'نشط' if company_data.get('is_active') == 'active' else 'غير نشط'}\n\nماذا تريد تعديل؟\"\"\"\n        \n        edit_keyboard = {\n            'keyboard': [\n                [{'text': '📝 تعديل الاسم'}, {'text': '🔧 تعديل النوع'}],\n                [{'text': '📋 تعديل التفاصيل'}, {'text': '🔘 تغيير الحالة'}],\n                [{'text': '✅ حفظ التغييرات'}, {'text': '❌ إلغاء'}]\n            ],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], edit_options, edit_keyboard)\n        self.user_states[user_id] = 'editing_company_menu'\n    \n    def save_company_changes(self, message):\n        \"\"\"حفظ تغييرات الشركة\"\"\"\n        user_id = message['from']['id']\n        try:\n            companies = []\n            updated_company = self.edit_company_data[user_id]\n            \n            # قراءة جميع الشركات\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == updated_company['id']:\n                        companies.append(updated_company)\n                    else:\n                        companies.append(row)\n            \n            # كتابة الملف المحدث\n            with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['id', 'name', 'type', 'details', 'is_active']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(companies)\n            \n            type_display = {'deposit': 'إيداع فقط', 'withdraw': 'سحب فقط', 'both': 'إيداع وسحب'}.get(updated_company['type'])\n            \n            success_msg = f\"\"\"🎉 تم حفظ التغييرات بنجاح!\n\n🆔 المعرف: {updated_company['id']}\n🏢 الاسم: {updated_company['name']}\n⚡ النوع: {type_display}\n📋 التفاصيل: {updated_company['details']}\n🔘 الحالة: {'نشط' if updated_company.get('is_active') == 'active' else 'غير نشط'}\"\"\"\n            \n            self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n            \n        except Exception as e:\n            self.send_message(message['chat']['id'], f\"❌ فشل في حفظ التغييرات: {str(e)}\", self.admin_keyboard())\n        \n        # تنظيف البيانات المؤقتة\n        del self.user_states[user_id]\n        if user_id in self.edit_company_data:\n            del self.edit_company_data[user_id]\n    \n    def show_companies_management_enhanced(self, message):\n        \"\"\"عرض إدارة الشركات المحسن مع تحديث فوري\"\"\"\n        companies_text = \"🏢 إدارة الشركات المتقدمة\\n\\n\"\n        \n        try:\n            # قراءة جميع الشركات من الملف مع إعادة تحميل الملف\n            companies = []\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                companies = list(reader)  # تحويل إلى قائمة فوراً\n            \n            if len(companies) == 0:\n                companies_text += \"❌ لا توجد شركات مسجلة\\n\\n\"\n            else:\n                companies_text += f\"📊 إجمالي الشركات: {len(companies)}\\n\"\n                companies_text += f\"📅 آخر تحديث: {datetime.now().strftime('%H:%M:%S')}\\n\\n\"\n                \n                for i, row in enumerate(companies, 1):\n                    status = \"✅\" if row.get('is_active', '').lower() == 'active' else \"❌\"\n                    type_display = {'deposit': 'إيداع', 'withdraw': 'سحب', 'both': 'الكل'}.get(row.get('type', ''), row.get('type', ''))\n                    companies_text += f\"{i}. {status} **{row.get('name', 'غير محدد')}** (ID: {row.get('id', 'غير محدد')})\\n\"\n                    companies_text += f\"   🔧 {type_display} | 📋 {row.get('details', 'لا توجد تفاصيل')}\\n\\n\"\n                    \n        except Exception as e:\n            companies_text += f\"❌ خطأ في قراءة ملف الشركات: {str(e)}\\n\\n\"\n            # محاولة إظهار محتوى الملف للتشخيص\n            try:\n                with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                    content = f.read()\n                    companies_text += f\"محتوى الملف:\\n{content[:200]}...\\n\\n\"\n            except:\n                companies_text += \"فشل في قراءة محتوى الملف\\n\\n\"\n        \n        # أزرار الإدارة المتقدمة\n        management_keyboard = {\n            'keyboard': [\n                [{'text': '➕ إضافة شركة جديدة'}, {'text': '✏️ تعديل شركة'}],\n                [{'text': '🗑️ حذف شركة'}, {'text': '🔄 تحديث القائمة'}],\n                [{'text': '📋 تصدير البيانات'}, {'text': '↩️ العودة للوحة الأدمن'}]\n            ],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        companies_text += \"\"\"🔧 خيارات الإدارة:\n• ➕ إضافة شركة جديدة - معالج تفاعلي خطوة بخطوة\n• ✏️ تعديل شركة - تعديل البيانات الموجودة\n• 🗑️ حذف شركة - حذف نهائي بأمان\n• 🔄 تحديث القائمة - إعادة تحميل البيانات\"\"\"\n        \n        self.send_message(message['chat']['id'], companies_text, management_keyboard)\n    \n    def prompt_delete_company(self, message):\n        \"\"\"بدء معالج حذف الشركة بأمان\"\"\"\n        companies_text = \"🗑️ حذف الشركات:\\n\\n\"\n        \n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    status = \"✅\" if row.get('is_active') == 'active' else \"❌\"\n                    companies_text += f\"{status} {row['id']} - {row['name']}\\n\"\n                    companies_text += f\"   📋 {row['type']} - {row['details']}\\n\\n\"\n        except:\n            companies_text += \"❌ لا توجد شركات\\n\\n\"\n        \n        companies_text += \"⚠️ أرسل رقم معرف الشركة للحذف:\\n(تحذير: الحذف نهائي ولا يمكن التراجع عنه)\"\n        \n        self.send_message(message['chat']['id'], companies_text)\n        self.user_states[message['from']['id']] = 'confirming_company_delete'\n    \n    def handle_company_delete_confirmation(self, message):\n        \"\"\"معالج تأكيد حذف الشركة\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        company_id = text\n        \n        # البحث عن الشركة\n        company_found = None\n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == company_id:\n                        company_found = row\n                        break\n        except:\n            pass\n        \n        if not company_found:\n            self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على شركة بالمعرف: {company_id}\")\n            del self.user_states[user_id]\n            return\n        \n        # عرض تأكيد الحذف\n        confirm_text = f\"\"\"⚠️ تأكيد حذف الشركة:\n\n🆔 المعرف: {company_found['id']}\n🏢 الاسم: {company_found['name']}\n📋 النوع: {company_found['type']}\n📝 التفاصيل: {company_found['details']}\n\n⚠️ هذا الإجراء نهائي ولا يمكن التراجع عنه!\nهل أنت متأكد من الحذف؟\"\"\"\n        \n        confirm_keyboard = {\n            'keyboard': [\n                [{'text': '🗑️ نعم، احذف الشركة'}, {'text': '❌ إلغاء'}]\n            ],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], confirm_text, confirm_keyboard)\n        self.user_states[user_id] = f'deleting_company_{company_id}'\n    \n    def finalize_company_delete(self, message, company_id):\n        \"\"\"إنهاء حذف الشركة\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text == '🗑️ نعم، احذف الشركة':\n            # تنفيذ الحذف\n            companies = []\n            deleted_company = None\n            \n            try:\n                with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['id'] != company_id:\n                            companies.append(row)\n                        else:\n                            deleted_company = row\n                \n                # كتابة الملف بدون الشركة المحذوفة\n                with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'name', 'type', 'details', 'is_active']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(companies)\n                \n                if deleted_company:\n                    success_msg = f\"\"\"✅ تم حذف الشركة بنجاح!\n\n🗑️ الشركة المحذوفة:\n🆔 المعرف: {deleted_company['id']}\n🏢 الاسم: {deleted_company['name']}\n📋 النوع: {deleted_company['type']}\"\"\"\n                    \n                    self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n                else:\n                    self.send_message(message['chat']['id'], \"❌ فشل في العثور على الشركة للحذف\", self.admin_keyboard())\n                    \n            except Exception as e:\n                self.send_message(message['chat']['id'], f\"❌ فشل في حذف الشركة: {str(e)}\", self.admin_keyboard())\n        \n        elif text == '❌ إلغاء':\n            self.send_message(message['chat']['id'], \"❌ تم إلغاء حذف الشركة\", self.admin_keyboard())\n        \n        # تنظيف الحالة\n        del self.user_states[user_id]\n    \n    def show_quick_copy_commands(self, message):\n        \"\"\"عرض أوامر نسخ سريعة للأدمن\"\"\"\n        commands_text = \"\"\"📋 أوامر نسخ سريعة:\n\n🔥 **أوامر الموافقة والرفض:**\n• `موافقة DEP123456`\n• `موافق DEP123456`\n• `تأكيد DEP123456`\n• `نعم DEP123456`\n\n• `رفض DEP123456 مبلغ غير صحيح`\n• `لا DEP123456 بيانات ناقصة`\n• `مرفوض WTH789012 رقم محفظة خطأ`\n\n💼 **أوامر إدارة الشركات:**\n• `اضافة_شركة البنك_الأهلي deposit حساب_بنكي_123456789`\n• `اضافة_شركة فودافون_كاش both محفظة_الكترونية`\n• `حذف_شركة 1737570855`\n\n💳 **أوامر وسائل الدفع:**\n• `اضافة_وسيلة_دفع 1 بنك_الأهلي حساب_بنكي SA123456789012345678`\n• `حذف_وسيلة_دفع 123456`\n• `تعديل_وسيلة_دفع 123456 SA987654321098765432`\n\n📧 **أوامر الرسائل:**\n• النقر على \"📧 إرسال رسالة لعميل\" ثم إدخال رقم العميل\n\n👥 **أوامر إدارة المستخدمين:**\n• `بحث أحمد`\n• `بحث C123456`\n• `حظر C123456 مخالفة الشروط`\n• `الغاء_حظر C123456`\n\n📨 **أوامر الشكاوى:**\n• `رد_شكوى 123 شكراً لتواصلك`\n• `رد_شكوى 456 تم حل مشكلتك`\n• `رد_شكوى 789 نراجع طلبك`\n\n🏢 **أوامر أخرى:**\n• `عنوان_جديد شارع الملك فهد الرياض`\n• `تعديل_اعداد min_deposit 100`\n\n💡 **نصائح للاستخدام:**\n• انقر على أي أمر واختر 'نسخ'\n• غير الأرقام والنصوص حسب الحاجة\n• استخدم _ بدلاً من المسافات في أسماء الشركات\"\"\"\n        \n        self.send_message(message['chat']['id'], commands_text, self.admin_keyboard())\n    \n    def get_payment_methods_by_company(self, company_id, transaction_type=None):\n        \"\"\"الحصول على وسائل الدفع لشركة معينة\"\"\"\n        methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if (row['company_id'] == str(company_id) and \n                        row['status'] == 'active'):\n                        methods.append(row)\n        except:\n            pass\n        return methods\n    \n    def show_payment_method_selection(self, message, company_id, transaction_type):\n        \"\"\"عرض وسائل الدفع المتاحة للشركة\"\"\"\n        user_id = message['from']['id']\n        methods = self.get_payment_methods_by_company(company_id, transaction_type)\n        \n        if not methods:\n            self.send_message(message['chat']['id'], \n                            \"❌ لا توجد وسائل دفع متاحة لهذه الشركة حالياً\",\n                            self.main_keyboard('ar'))\n            return\n        \n        methods_text = f\"💳 اختر وسيلة الدفع:\\n\\n\"\n        keyboard = []\n        \n        for method in methods:\n            methods_text += f\"🔹 {method['method_name']}\\n\"\n            methods_text += f\"   📋 {method['method_type']}\\n\"\n            if method['additional_info']:\n                methods_text += f\"   💡 {method['additional_info']}\\n\"\n            methods_text += \"\\n\"\n            \n            keyboard.append([{'text': method['method_name']}])\n        \n        keyboard.append([{'text': '🔙 العودة لاختيار الشركة'}])\n        \n        # حفظ الحالة\n        self.user_states[user_id] = {\n            'step': 'selecting_payment_method',\n            'company_id': company_id,\n            'transaction_type': transaction_type,\n            'methods': methods\n        }\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def add_payment_method(self, company_id, method_name, method_type, account_data, additional_info=\"\"):\n        \"\"\"إضافة وسيلة دفع جديدة\"\"\"\n        try:\n            # إنشاء ID جديد  \n            new_id = int(datetime.now().timestamp() * 1000) % 1000000\n            \n            # إضافة الوسيلة الجديدة\n            with open('payment_methods.csv', 'a', encoding='utf-8-sig', newline='') as f:\n                writer = csv.writer(f)\n                writer.writerow([\n                    new_id,\n                    company_id,\n                    method_name,\n                    method_type,\n                    account_data,\n                    additional_info,\n                    'active',\n                    datetime.now().strftime('%Y-%m-%d')\n                ])\n            return True\n        except:\n            return False\n    \n    def edit_payment_method(self, method_id, new_data):\n        \"\"\"تعديل وسيلة دفع موجودة\"\"\"\n        try:\n            methods = []\n            found = False\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        # تحديث البيانات\n                        for key, value in new_data.items():\n                            if key in row:\n                                row[key] = value\n                        found = True\n                    methods.append(row)\n            \n            if found:\n                # كتابة البيانات المحدثة\n                with open('payment_methods.csv', 'w', encoding='utf-8-sig', newline='') as f:\n                    if methods:\n                        fieldnames = methods[0].keys()\n                        writer = csv.DictWriter(f, fieldnames=fieldnames)\n                        writer.writeheader()\n                        writer.writerows(methods)\n                return True\n        except:\n            pass\n        return False\n    \n    def delete_payment_method(self, method_id):\n        \"\"\"حذف وسيلة دفع مع إرجاع البيانات المحذوفة\"\"\"\n        try:\n            methods = []\n            deleted_method = None\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] != str(method_id):\n                        methods.append(row)\n                    else:\n                        deleted_method = row.copy()\n            \n            if deleted_method:\n                # كتابة الملف حتى لو كان فارغ\n                with open('payment_methods.csv', 'w', encoding='utf-8-sig', newline='') as f:\n                    fieldnames = ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    if methods:  # فقط اكتب الصفوف إذا كانت موجودة\n                        writer.writerows(methods)\n                \n                logger.info(f\"تم حذف وسيلة الدفع {method_id}: {deleted_method.get('method_name', 'غير محدد')}\")\n                return True, deleted_method\n            \n            return False, None\n        except Exception as e:\n            logger.error(f\"خطأ في حذف وسيلة الدفع {method_id}: {e}\")\n            return False, None\n    \n    def start_add_company_wizard(self, message):\n        \"\"\"بدء معالج إضافة شركة تفاعلي\"\"\"\n        wizard_text = \"\"\"🧙‍♂️ معالج إضافة الشركة\n\nسأساعدك في إضافة شركة بطريقة سهلة!\n\n📝 أولاً: ما اسم الشركة؟\n(مثال: بنك الراجحي، فودافون كاش، مدى)\"\"\"\n        \n        self.send_message(message['chat']['id'], wizard_text)\n        self.user_states[message['from']['id']] = 'adding_company_name'\n    \n    def handle_add_company_wizard(self, message, text):\n        \"\"\"معالجة معالج إضافة الشركة\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        \n        if state == 'adding_company_name':\n            company_name = text.strip()\n            if len(company_name) < 2:\n                self.send_message(message['chat']['id'], \"❌ اسم قصير جداً. أدخل اسم الشركة:\")\n                return\n            \n            # عرض أنواع الخدمة\n            service_keyboard = {\n                'keyboard': [\n                    [{'text': '💰 إيداع فقط'}, {'text': '💸 سحب فقط'}],\n                    [{'text': '🔄 إيداع وسحب معاً'}],\n                    [{'text': '❌ إلغاء'}, {'text': '🔄 إعادة تعيين النظام'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            self.send_message(message['chat']['id'], f\"✅ اسم الشركة: {company_name}\\n\\n🔹 اختر نوع الخدمة:\", service_keyboard)\n            self.user_states[user_id] = f'adding_company_type_{company_name}'\n            \n        elif state.startswith('adding_company_type_'):\n            company_name = state.replace('adding_company_type_', '')\n            \n            if text == '❌ إلغاء':\n                self.send_message(message['chat']['id'], \"تم إلغاء إضافة الشركة\", self.admin_keyboard())\n                del self.user_states[user_id]\n                return\n            \n            # تحديد نوع الخدمة\n            if text == '💰 إيداع فقط':\n                service_type = 'deposit'\n                service_ar = 'إيداع فقط'\n            elif text == '💸 سحب فقط':\n                service_type = 'withdraw'\n                service_ar = 'سحب فقط'\n            elif text == '🔄 إيداع وسحب معاً':\n                service_type = 'both'\n                service_ar = 'إيداع وسحب'\n            else:\n                self.send_message(message['chat']['id'], \"❌ اختر من الأزرار المتاحة:\")\n                return\n            \n            self.send_message(message['chat']['id'], f\"\"\"✅ تم اختيار: {service_ar}\n\n📝 الآن أدخل تفاصيل الشركة:\n(مثال: حساب بنكي رقم 1234567890، محفظة إلكترونية، خدمات دفع متعددة)\"\"\")\n            \n            self.user_states[user_id] = f'adding_company_details_{company_name}_{service_type}'\n            \n        elif state.startswith('adding_company_details_'):\n            parts = state.replace('adding_company_details_', '').rsplit('_', 1)\n            company_name = parts[0]\n            service_type = parts[1]\n            details = text.strip()\n            \n            if len(details) < 3:\n                self.send_message(message['chat']['id'], \"❌ تفاصيل قصيرة جداً. أدخل وصف مناسب:\")\n                return\n            \n            # إنشاء الشركة\n            company_id = str(int(datetime.now().timestamp()))\n            \n            try:\n                with open('companies.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow([company_id, company_name, service_type, details, 'active'])\n                \n                service_ar = \"إيداع فقط\" if service_type == 'deposit' else \"سحب فقط\" if service_type == 'withdraw' else \"إيداع وسحب\"\n                \n                success_msg = f\"\"\"✅ تم إضافة الشركة بنجاح!\n\n🆔 المعرف: {company_id}\n🏢 الاسم: {company_name}\n⚡ النوع: {service_ar}\n📋 التفاصيل: {details}\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nالشركة أصبحت متاحة الآن للعملاء.\"\"\"\n                \n                self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n                del self.user_states[user_id]\n                \n            except Exception as e:\n                self.send_message(message['chat']['id'], f\"❌ فشل في إضافة الشركة: {str(e)}\", self.admin_keyboard())\n                del self.user_states[user_id]\n    \n    def show_companies_management(self, message):\n        \"\"\"عرض إدارة الشركات\"\"\"\n        companies_text = \"🏢 إدارة الشركات:\\n\\n\"\n        \n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    status = \"✅\" if row.get('is_active') == 'active' else \"❌\"\n                    companies_text += f\"{status} {row['id']} - {row['name']}\\n\"\n                    companies_text += f\"   📋 {row['type']} - {row['details']}\\n\\n\"\n        except:\n            pass\n        \n        companies_text += \"📝 الأوامر:\\n\"\n        companies_text += \"• اضافة_شركة اسم نوع تفاصيل\\n\"\n        companies_text += \"• حذف_شركة رقم_المعرف\\n\"\n        \n        self.send_message(message['chat']['id'], companies_text, self.admin_keyboard())\n    \n    def show_addresses_management(self, message):\n        \"\"\"عرض إدارة العناوين\"\"\"\n        current_address = self.get_exchange_address()\n        \n        address_text = f\"\"\"📍 إدارة عناوين الصرافة\n\nالعنوان الحالي:\n{current_address}\n\nلتغيير العنوان:\nعنوان_جديد النص_الجديد_للعنوان\n\nمثال:\nعنوان_جديد شارع الملك فهد، الرياض، مقابل برج المملكة\"\"\"\n        \n        self.send_message(message['chat']['id'], address_text, self.admin_keyboard())\n    \n    def show_system_settings(self, message):\n        \"\"\"عرض إعدادات النظام\"\"\"\n        settings_text = \"⚙️ إعدادات النظام:\\n\\n\"\n        \n        try:\n            with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    settings_text += f\"🔧 {row['setting_key']}: {row['setting_value']}\\n\"\n                    settings_text += f\"   📝 {row['description']}\\n\\n\"\n        except:\n            pass\n        \n        settings_text += \"📝 لتعديل إعداد:\\n\"\n        settings_text += \"تعديل_اعداد مفتاح_الإعداد القيمة_الجديدة\\n\\n\"\n        settings_text += \"مثال:\\nتعديل_اعداد min_deposit 100\"\n        \n        self.send_message(message['chat']['id'], settings_text, self.admin_keyboard())\n    \n    def show_complaints_admin(self, message):\n        \"\"\"عرض الشكاوى مع أزرار رد سهلة\"\"\"\n        complaints_text = \"📨 الشكاوى:\\n\\n\"\n        keyboard = []\n        \n        try:\n            with open('complaints.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                pending_complaints = [row for row in reader if row['status'] == 'pending']\n                \n                if not pending_complaints:\n                    complaints_text += \"✅ لا توجد شكاوى معلقة\"\n                    keyboard = [\n                        [{'text': '🔄 تحديث'}],\n                        [{'text': '↩️ العودة للوحة الأدمن'}]\n                    ]\n                else:\n                    for complaint in pending_complaints:\n                        complaints_text += f\"🆔 {complaint['id']}\\n\"\n                        complaints_text += f\"👤 {complaint['customer_id']}\\n\"\n                        complaints_text += f\"📝 {complaint['message']}\\n\"\n                        complaints_text += f\"📅 {complaint['date']}\\n\\n\"\n                        \n                        # إضافة أزرار رد سريعة\n                        keyboard.append([{'text': f\"📞 رد على {complaint['id']}\"}])\n                    \n                    keyboard.extend([\n                        [{'text': '🔄 تحديث'}],\n                        [{'text': '↩️ العودة للوحة الأدمن'}]\n                    ])\n                        \n        except Exception as e:\n            complaints_text += f\"❌ خطأ في قراءة الشكاوى: {e}\"\n            keyboard = [\n                [{'text': '🔄 تحديث'}],\n                [{'text': '↩️ العودة للوحة الأدمن'}]\n            ]\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': False\n        }\n        \n        self.send_message(message['chat']['id'], complaints_text, reply_keyboard)\n    \n    def start_complaint_reply_wizard(self, message, complaint_id):\n        \"\"\"بدء معالج الرد على الشكوى\"\"\"\n        # البحث عن الشكوى\n        complaint_found = False\n        complaint_data = None\n        \n        try:\n            with open('complaints.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == complaint_id:\n                        complaint_found = True\n                        complaint_data = row\n                        break\n        except:\n            pass\n        \n        if not complaint_found:\n            self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على الشكوى {complaint_id}\", self.admin_keyboard())\n            return\n        \n        # عرض تفاصيل الشكوى مع أزرار ردود سريعة\n        reply_text = f\"\"\"📞 الرد على الشكوى:\n\n🆔 رقم الشكوى: {complaint_id}\n👤 العميل: {complaint_data['customer_id']}\n📝 الشكوى: {complaint_data['message']}\n📅 التاريخ: {complaint_data['date']}\n\nاختر رد سريع أو اكتب رد مخصص:\"\"\"\n        \n        keyboard = [\n            [{'text': f\"✅ تم الحل - {complaint_id}\"}],\n            [{'text': f\"🔍 قيد المراجعة - {complaint_id}\"}],\n            [{'text': f\"📞 سنتواصل معك - {complaint_id}\"}],\n            [{'text': f\"💡 رد مخصص - {complaint_id}\"}],\n            [{'text': '🔙 العودة للشكاوى'}]\n        ]\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], reply_text, reply_keyboard)\n        self.user_states[message['from']['id']] = f'replying_to_complaint_{complaint_id}'\n    \n    def show_payment_methods_admin(self, message):\n        \"\"\"عرض وسائل الدفع للأدمن\"\"\"\n        payment_text = \"\"\"💳 وسائل الدفع المتاحة\n\nهذا القسم يعرض الشركات المتاحة للإيداع والسحب.\nاستخدم 'إدارة الشركات' لإضافة أو تعديل وسائل الدفع.\"\"\"\n        \n        companies = self.get_companies()\n        for company in companies:\n            service_type = \"إيداع وسحب\" if company['type'] == 'both' else \"إيداع\" if company['type'] == 'deposit' else \"سحب\"\n            payment_text += f\"\\n🏢 {company['name']}\\n\"\n            payment_text += f\"   📋 {service_type} - {company['details']}\\n\"\n        \n        self.send_message(message['chat']['id'], payment_text, self.admin_keyboard())\n    \n    def ban_user_admin(self, message, customer_id, reason):\n        \"\"\"حظر مستخدم من قبل الأدمن\"\"\"\n        users = []\n        success = False\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        row['is_banned'] = 'yes'\n                        row['ban_reason'] = reason\n                        success = True\n                    users.append(row)\n            \n            if success:\n                with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(users)\n                \n                self.send_message(message['chat']['id'], f\"✅ تم حظر العميل {customer_id}\\nالسبب: {reason}\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على العميل {customer_id}\", self.admin_keyboard())\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في حظر المستخدم\", self.admin_keyboard())\n    \n    def unban_user_admin(self, message, customer_id):\n        \"\"\"إلغاء حظر مستخدم من قبل الأدمن\"\"\"\n        users = []\n        success = False\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        row['is_banned'] = 'no'\n                        row['ban_reason'] = ''\n                        success = True\n                    users.append(row)\n            \n            if success:\n                with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(users)\n                \n                self.send_message(message['chat']['id'], f\"✅ تم إلغاء حظر العميل {customer_id}\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على العميل {customer_id}\", self.admin_keyboard())\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في إلغاء حظر المستخدم\", self.admin_keyboard())\n    \n    def delete_company_simple(self, message, company_id):\n        \"\"\"حذف شركة بسيط\"\"\"\n        companies = []\n        deleted = False\n        \n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] != company_id:\n                        companies.append(row)\n                    else:\n                        deleted = True\n                        deleted_name = row.get('name', 'Unknown')\n            \n            if deleted:\n                with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'name', 'type', 'details', 'is_active']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(companies)\n                \n                self.send_message(message['chat']['id'], f\"✅ تم حذف الشركة: {deleted_name} (ID: {company_id})\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على شركة بالمعرف: {company_id}\", self.admin_keyboard())\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في حذف الشركة\", self.admin_keyboard())\n    \n    def update_setting_simple(self, message, text):\n        \"\"\"تحديث إعداد النظام\"\"\"\n        # تنسيق: تعديل_اعداد مفتاح_الإعداد القيمة_الجديدة\n        parts = text.replace('تعديل_اعداد ', '').split(' ', 1)\n        if len(parts) < 2:\n            help_text = \"\"\"❌ تنسيق خاطئ\n\nالصيغة الصحيحة:\nتعديل_اعداد مفتاح_الإعداد القيمة_الجديدة\n\nمثال:\nتعديل_اعداد min_deposit 100\"\"\"\n            self.send_message(message['chat']['id'], help_text, self.admin_keyboard())\n            return\n        \n        setting_key = parts[0]\n        setting_value = parts[1]\n        \n        settings = []\n        updated = False\n        \n        try:\n            with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['setting_key'] == setting_key:\n                        row['setting_value'] = setting_value\n                        updated = True\n                    settings.append(row)\n            \n            if updated:\n                with open('system_settings.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['setting_key', 'setting_value', 'description']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(settings)\n                \n                self.send_message(message['chat']['id'], f\"✅ تم تحديث الإعداد:\\n{setting_key} = {setting_value}\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على الإعداد: {setting_key}\", self.admin_keyboard())\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في تحديث الإعداد\", self.admin_keyboard())\n    \n    def save_complaint(self, message, complaint_text):\n        \"\"\"حفظ شكوى المستخدم\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        complaint_id = f\"COMP{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        \n        try:\n            # إنشاء ملف الشكاوى مع الهيكل الصحيح إذا لم يكن موجوداً\n            if not os.path.exists('complaints.csv'):\n                with open('complaints.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow(['id', 'customer_id', 'subject', 'message', 'status', 'date', 'admin_response'])\n            \n            # إضافة الشكوى الجديدة\n            with open('complaints.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([complaint_id, user['customer_id'], 'شكوى جديدة', complaint_text, 'pending', \n                               datetime.now().strftime('%Y-%m-%d %H:%M'), ''])\n            \n            confirmation = f\"\"\"✅ تم إرسال شكواك بنجاح\n\n🆔 رقم الشكوى: {complaint_id}\n📝 المحتوى: {complaint_text}\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nسيتم الرد عليك في أقرب وقت ممكن.\"\"\"\n            \n            self.send_message(message['chat']['id'], confirmation, self.main_keyboard(user.get('language', 'ar')))\n            if message['from']['id'] in self.user_states:\n                del self.user_states[message['from']['id']]\n            \n            # إشعار الأدمن بالشكوى الجديدة\n            admin_msg = f\"\"\"📨 شكوى جديدة\n\n🆔 {complaint_id}\n👤 {user['name']} ({user['customer_id']})\n📝 الشكوى: {complaint_text}\n📅 {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\"\"\n            \n            self.notify_admins(admin_msg)\n            \n        except Exception as e:\n            logger.error(f\"خطأ في حفظ الشكوى: {e}\")\n            self.send_message(message['chat']['id'], \"❌ فشل في إرسال الشكوى. حاول مرة أخرى\", self.main_keyboard(user.get('language', 'ar')))\n            if message['from']['id'] in self.user_states:\n                del self.user_states[message['from']['id']]\n    \n    def send_broadcast_message(self, message, broadcast_text):\n        \"\"\"إرسال رسالة جماعية\"\"\"\n        sent_count = 0\n        failed_count = 0\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                users = list(reader)\n            \n            # إرسال للمستخدمين النشطين فقط\n            for user in users:\n                if user.get('is_banned') != 'yes':\n                    try:\n                        broadcast_msg = f\"\"\"📢 رسالة من الإدارة\n\n{broadcast_text}\n\n📅 {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\"\"\n                        \n                        # إرسال الرسالة بدون لوحة مفاتيح حتى لا تؤثر على الأزرار الحالية\n                        result = self.send_message(user['telegram_id'], broadcast_msg, None)\n                        if result and result.get('ok'):\n                            sent_count += 1\n                        else:\n                            failed_count += 1\n                    except:\n                        failed_count += 1\n            \n            summary = f\"\"\"✅ تم إرسال الرسالة الجماعية\n\n📊 الإحصائيات:\n• تم الإرسال بنجاح: {sent_count}\n• فشل في الإرسال: {failed_count}\n• إجمالي المحاولات: {sent_count + failed_count}\n\n📝 الرسالة: {broadcast_text}\"\"\"\n            \n            self.send_message(message['chat']['id'], summary, self.admin_keyboard())\n            del self.user_states[message['from']['id']]\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في الإرسال الجماعي\", self.admin_keyboard())\n            del self.user_states[message['from']['id']]\n\n    def show_approved_transactions(self, message):\n        \"\"\"عرض المعاملات المُوافق عليها\"\"\"\n        approved_text = \"✅ المعاملات المُوافق عليها (آخر 20 معاملة):\\n\\n\"\n        found_approved = False\n        count = 0\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                transactions = list(reader)\n                \n                # عكس الترتيب للحصول على أحدث المعاملات\n                for row in reversed(transactions):\n                    if row['status'] == 'approved' and count < 20:\n                        found_approved = True\n                        count += 1\n                        type_emoji = \"💰\" if row['type'] == 'deposit' else \"💸\"\n                        \n                        approved_text += f\"{type_emoji} {row['id']}\\n\"\n                        approved_text += f\"👤 {row['name']}\\n\"\n                        approved_text += f\"💰 {row['amount']} ريال\\n\"\n                        approved_text += f\"📅 {row['date']}\\n\\n\"\n        except:\n            pass\n        \n        if not found_approved:\n            approved_text += \"لا توجد معاملات مُوافق عليها\"\n        \n        self.send_message(message['chat']['id'], approved_text, self.admin_keyboard())\n    \n    def show_users_management(self, message):\n        \"\"\"عرض إدارة المستخدمين\"\"\"\n        users_text = \"👥 إدارة المستخدمين:\\n\\n\"\n        active_count = 0\n        banned_count = 0\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row.get('is_banned') == 'yes':\n                        banned_count += 1\n                    else:\n                        active_count += 1\n        except:\n            pass\n        \n        users_text += f\"✅ مستخدمون نشطون: {active_count}\\n\"\n        users_text += f\"🚫 مستخدمون محظورون: {banned_count}\\n\\n\"\n        \n        users_text += \"📝 الأوامر المتاحة:\\n\"\n        users_text += \"• بحث اسم_أو_رقم_العميل\\n\"\n        users_text += \"• حظر رقم_العميل السبب\\n\"\n        users_text += \"• الغاء_حظر رقم_العميل\\n\\n\"\n        \n        users_text += \"مثال:\\nبحث أحمد\\nحظر C123456 مخالفة_الشروط\"\n        \n        self.send_message(message['chat']['id'], users_text, self.admin_keyboard())\n    \n    def search_users_admin(self, message, query):\n        \"\"\"البحث في المستخدمين للأدمن\"\"\"\n        results = []\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if (query.lower() in row['name'].lower() or \n                        query in row['customer_id'] or \n                        query in row['phone']):\n                        results.append(row)\n        except:\n            pass\n        \n        if not results:\n            self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على نتائج للبحث: {query}\", self.admin_keyboard())\n            return\n        \n        search_text = f\"🔍 نتائج البحث عن: {query}\\n\\n\"\n        for user in results[:10]:  # أول 10 نتائج فقط\n            status = \"🚫 محظور\" if user.get('is_banned') == 'yes' else \"✅ نشط\"\n            search_text += f\"👤 {user['name']}\\n\"\n            search_text += f\"🆔 {user['customer_id']}\\n\"\n            search_text += f\"📱 {user['phone']}\\n\"\n            search_text += f\"🔸 {status}\\n\"\n            if user.get('is_banned') == 'yes' and user.get('ban_reason'):\n                search_text += f\"📝 سبب الحظر: {user['ban_reason']}\\n\"\n            search_text += \"\\n\"\n        \n        self.send_message(message['chat']['id'], search_text, self.admin_keyboard())\n    \n    def start_simple_payment_method_wizard(self, message):\n        \"\"\"معالج مبسط لإضافة وسيلة دفع\"\"\"\n        user_id = message['from']['id']\n        \n        # عرض الشركات المتاحة\n        companies = self.get_companies()\n        if not companies:\n            self.send_message(message['chat']['id'], \n                            \"❌ لا توجد شركات متاحة. يجب إضافة شركة أولاً\", \n                            self.admin_keyboard())\n            return\n        \n        companies_text = \"🏢 اختر الشركة لإضافة وسيلة دفع:\\n\\n\"\n        keyboard = []\n        \n        for company in companies:\n            companies_text += f\"🔹 {company['name']}\\n\"\n            keyboard.append([{'text': f\"🏢 {company['name']}\"}])\n        \n        keyboard.append([{'text': '🔙 العودة'}])\n        \n        self.user_states[user_id] = 'adding_payment_simple'\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], companies_text, reply_keyboard)\n    \n    def start_edit_payment_method_wizard(self, message):\n        \"\"\"معالج مبسط لتعديل وسيلة دفع\"\"\"\n        methods = self.get_all_payment_methods()\n        if not methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد وسائل دفع متاحة\", self.admin_keyboard())\n            return\n        \n        methods_text = \"✏️ اختر وسيلة الدفع للتعديل:\\n\\n\"\n        keyboard = []\n        \n        for method in methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            methods_text += f\"🆔 {method['id']} - {method['method_name']}\\n\"\n            methods_text += f\"   🏢 {company_name}\\n\"\n            methods_text += f\"   💳 {method['method_type']}\\n\\n\"\n            \n            keyboard.append([{'text': f\"تعديل {method['id']}\"}])\n        \n        keyboard.append([{'text': '🔙 العودة'}])\n        \n        self.user_states[message['from']['id']] = 'selecting_method_to_edit_simple'\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def start_delete_payment_method_wizard(self, message):\n        \"\"\"معالج مبسط لحذف وسيلة دفع\"\"\"\n        methods = self.get_all_payment_methods()\n        if not methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد وسائل دفع متاحة\", self.admin_keyboard())\n            return\n        \n        methods_text = \"🗑️ اختر وسيلة الدفع للحذف:\\n\\n\"\n        keyboard = []\n        \n        for method in methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            methods_text += f\"🆔 {method['id']} - {method['method_name']}\\n\"\n            methods_text += f\"   🏢 {company_name}\\n\\n\"\n            \n            keyboard.append([{'text': f\"حذف {method['id']}\"}])\n        \n        keyboard.append([{'text': '🔙 العودة'}])\n        \n        self.user_states[message['from']['id']] = 'selecting_method_to_delete_simple'\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def show_all_payment_methods_simplified(self, message):\n        \"\"\"عرض مبسط لجميع وسائل الدفع\"\"\"\n        methods = self.get_all_payment_methods()\n        \n        if not methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد وسائل دفع مضافة بعد\", self.admin_keyboard())\n            return\n        \n        methods_text = \"📊 وسائل الدفع المتاحة:\\n\\n\"\n        \n        for method in methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            status = \"✅ نشط\" if method['status'] == 'active' else \"❌ متوقف\"\n            \n            methods_text += f\"🆔 {method['id']} - {method['method_name']}\\n\"\n            methods_text += f\"🏢 الشركة: {company_name}\\n\"\n            methods_text += f\"💳 النوع: {method['method_type']}\\n\"\n            methods_text += f\"💰 البيانات: {method['account_data']}\\n\"\n            methods_text += f\"📊 الحالة: {status}\\n\"\n            if method['additional_info']:\n                methods_text += f\"💡 معلومات: {method['additional_info']}\\n\"\n            methods_text += \"─────────────\\n\\n\"\n        \n        methods_text += f\"📈 إجمالي وسائل الدفع: {len(methods)}\"\n        \n        self.send_message(message['chat']['id'], methods_text, self.admin_keyboard())\n    \n    def handle_simple_payment_company_selection(self, message):\n        \"\"\"معالجة اختيار الشركة في المعالج المبسط\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        # البحث عن الشركة\n        company_name = text.replace('🏢 ', '')\n        companies = self.get_companies()\n        selected_company = None\n        \n        for company in companies:\n            if company['name'] == company_name:\n                selected_company = company\n                break\n        \n        if not selected_company:\n            self.send_message(message['chat']['id'], \"❌ شركة غير صحيحة. اختر من القائمة أعلاه\")\n            return\n        \n        # طلب بيانات وسيلة الدفع\n        input_text = f\"\"\"📋 إضافة وسيلة دفع للشركة: {selected_company['name']}\n\nأدخل البيانات بالتنسيق التالي:\nاسم_الوسيلة | نوع_الوسيلة | رقم_الحساب | معلومات_إضافية\n\nمثال:\nبنك الأهلي | حساب بنكي | SA1234567890123456789 | حساب رئيسي\nأو\nفودافون كاش | محفظة إلكترونية | 01012345678 | للدفع السريع\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], input_text)\n        self.user_states[user_id] = f'adding_payment_method_{selected_company[\"id\"]}'\n    \n    def handle_simple_payment_method_data(self, message):\n        \"\"\"معالجة بيانات وسيلة الدفع المبسطة\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        state = self.user_states.get(user_id, '')\n        \n        if text == '/cancel':\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        # استخراج معرف الشركة\n        company_id = state.replace('adding_payment_method_', '')\n        \n        # تحليل البيانات المدخلة\n        if '|' in text:\n            parts = [part.strip() for part in text.split('|')]\n            if len(parts) >= 3:\n                method_name = parts[0]\n                method_type = parts[1]\n                account_data = parts[2]\n                additional_info = parts[3] if len(parts) > 3 else \"\"\n                \n                # إضافة وسيلة الدفع\n                success = self.add_payment_method(company_id, method_name, method_type, account_data, additional_info)\n                \n                if success:\n                    company = self.get_company_by_id(company_id)\n                    company_name = company['name'] if company else 'غير محدد'\n                    \n                    success_msg = f\"\"\"✅ تم إضافة وسيلة الدفع بنجاح!\n\n🏢 الشركة: {company_name}\n📋 الاسم: {method_name}\n💳 النوع: {method_type}\n💰 البيانات: {account_data}\n💡 معلومات: {additional_info if additional_info else 'لا توجد'}\"\"\"\n                    \n                    self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n                else:\n                    self.send_message(message['chat']['id'], \"❌ فشل في إضافة وسيلة الدفع\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], \"❌ تنسيق غير صحيح. يجب أن يحتوي على 3 أجزاء على الأقل مفصولة بـ |\")\n                return\n        else:\n            self.send_message(message['chat']['id'], \"❌ تنسيق غير صحيح. استخدم | للفصل بين البيانات\")\n            return\n        \n        # تنظيف الحالة\n        if user_id in self.user_states:\n            del self.user_states[user_id]\n    \n    def handle_simple_method_edit_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع للتعديل المبسط\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        if text.startswith('تعديل '):\n            method_id = text.replace('تعديل ', '').strip()\n            method = self.get_payment_method_by_id(method_id)\n            \n            if not method:\n                self.send_message(message['chat']['id'], \"❌ وسيلة دفع غير موجودة\")\n                return\n            \n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            edit_text = f\"\"\"✏️ تعديل وسيلة الدفع\n\n🆔 المعرف: {method['id']}\n🏢 الشركة: {company_name}\n📋 الاسم الحالي: {method['method_name']}\n💳 النوع الحالي: {method['method_type']}\n💰 البيانات الحالية: {method['account_data']}\n💡 المعلومات الحالية: {method['additional_info']}\n\nأدخل البيانات الجديدة بالتنسيق:\nاسم_جديد | نوع_جديد | رقم_حساب_جديد | معلومات_جديدة\n\n⬅️ /cancel للإلغاء\"\"\"\n            \n            self.send_message(message['chat']['id'], edit_text)\n            self.user_states[user_id] = f'editing_method_simple_{method_id}'\n    \n    def handle_simple_method_delete_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع للحذف المبسط\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        if text.startswith('حذف '):\n            method_id = text.replace('حذف ', '').strip()\n            \n            # الحصول على بيانات الوسيلة قبل الحذف\n            method_to_delete = self.get_payment_method_by_id(method_id)\n            if not method_to_delete:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على وسيلة الدفع {method_id}\", self.admin_keyboard())\n                if user_id in self.user_states:\n                    del self.user_states[user_id]\n                return\n            \n            # حذف وسيلة الدفع\n            success, deleted_method = self.delete_payment_method(method_id)\n            \n            if success and deleted_method:\n                company = self.get_company_by_id(deleted_method['company_id'])\n                company_name = company['name'] if company else 'غير محدد'\n                \n                success_msg = f\"\"\"✅ تم حذف وسيلة الدفع بنجاح!\n\n🆔 المحذوفة: {deleted_method['id']}\n🏢 الشركة: {company_name}\n📋 الاسم: {deleted_method['method_name']}\n💳 النوع: {deleted_method['method_type']}\"\"\"\n                \n                self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ فشل في حذف وسيلة الدفع {method_id}\", self.admin_keyboard())\n            \n            # تنظيف الحالة\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n    \n    def handle_simple_method_edit_data(self, message, method_id):\n        \"\"\"معالجة بيانات التعديل المبسط\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text == '/cancel':\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        # تحليل البيانات الجديدة - تنسيق مبسط\n        if '|' in text:\n            parts = [part.strip() for part in text.split('|')]\n            if len(parts) >= 3:\n                new_name = parts[0]\n                new_type = parts[1]\n                new_account = parts[2]\n                new_info = parts[3] if len(parts) > 3 else \"\"\n                \n                # التحقق من وجود الوسيلة قبل التحديث\n                existing_method = self.get_payment_method_by_id(method_id)\n                if not existing_method:\n                    self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على وسيلة الدفع رقم {method_id}\", self.admin_keyboard())\n                    if user_id in self.user_states:\n                        del self.user_states[user_id]\n                    return\n                \n                # تحديث وسيلة الدفع\n                logger.info(f\"محاولة تحديث وسيلة الدفع - المعرف: {method_id}, الاسم: {new_name}, البيانات: {new_account}\")\n                \n                # تسجيل البيانات للتشخيص\n                logger.info(f\"البيانات المدخلة: الاسم={new_name}, النوع={new_type}, الحساب={new_account}, المعلومات={new_info}\")\n                \n                success = self.update_payment_method_safe(method_id, new_name, new_type, new_account, new_info)\n                \n                if success:\n                    # الحصول على بيانات الشركة\n                    company = self.get_company_by_id(existing_method['company_id'])\n                    company_name = company['name'] if company else 'غير محدد'\n                    \n                    success_msg = f\"\"\"✅ تم تعديل وسيلة الدفع بنجاح!\n\n🆔 المعرف: {method_id}\n🏢 الشركة: {company_name}\n📋 الاسم: {new_name}\n💳 النوع: {new_type}\n💰 البيانات: {new_account}\n💡 معلومات إضافية: {new_info if new_info else 'لا توجد'}\"\"\"\n                    \n                    self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n                else:\n                    self.send_message(message['chat']['id'], f\"❌ فشل في تعديل وسيلة الدفع {method_id}\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], \"❌ تنسيق غير صحيح!\\n\\nالتنسيق المطلوب:\\nاسم_الوسيلة | نوع_الوسيلة | رقم_الحساب | معلومات_إضافية\\n\\nمثال:\\nفودافون كاش | محفظة إلكترونية | 01012345678 | للدفع السريع\")\n                return\n        else:\n            self.send_message(message['chat']['id'], \"❌ يجب استخدام | للفصل بين البيانات!\\n\\nمثال:\\nفودافون كاش | محفظة إلكترونية | 01012345678 | للدفع السريع\")\n            return\n        \n        # تنظيف الحالة\n        if user_id in self.user_states:\n            del self.user_states[user_id]\n    \n    def update_payment_method_safe(self, method_id, new_name, new_type, new_account, new_info=\"\"):\n        \"\"\"تحديث آمن لوسيلة الدفع مع تحقق شامل\"\"\"\n        try:\n            methods = []\n            updated = False\n            original_method = None\n            \n            # قراءة الملف والبحث عن الوسيلة\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        original_method = row.copy()\n                        # تحديث البيانات\n                        row['method_name'] = new_name\n                        row['method_type'] = new_type\n                        row['account_data'] = new_account\n                        row['additional_info'] = new_info\n                        updated = True\n                        logger.info(f\"تم العثور على وسيلة الدفع {method_id} وتحديثها\")\n                    methods.append(row)\n            \n            if not updated:\n                logger.error(f\"لم يتم العثور على وسيلة الدفع {method_id}\")\n                return False\n            \n            # كتابة الملف المحدث\n            with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(methods)\n            \n            logger.info(f\"✅ تم حفظ التحديث بنجاح - الوسيلة {method_id}: {new_name}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"❌ خطأ في تحديث وسيلة الدفع {method_id}: {e}\")\n            return False\n    \n    def show_payment_methods_management(self, message):\n        \"\"\"عرض لوحة إدارة وسائل الدفع\"\"\"\n        methods_text = \"\"\"💳 إدارة وسائل الدفع\n\n🏢 هذا القسم يسمح لك بإدارة وسائل الدفع لكل شركة:\n• إضافة وسائل دفع جديدة\n• تعديل بيانات الوسائل الموجودة  \n• حذف وسائل الدفع\n• تشغيل/إيقاف وسائل الدفع\n• عرض جميع الوسائل المتاحة\n\nاختر العملية المطلوبة:\"\"\"\n        \n        keyboard = [\n            [{'text': '➕ إضافة وسيلة دفع'}, {'text': '✏️ تعديل وسيلة دفع'}],\n            [{'text': '🗑️ حذف وسيلة دفع'}, {'text': '⏹️ إيقاف وسيلة دفع'}],\n            [{'text': '▶️ تشغيل وسيلة دفع'}, {'text': '📊 عرض وسائل الدفع'}],\n            [{'text': '↩️ العودة للوحة الأدمن'}]\n        ]\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': False\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def start_disable_payment_method_wizard(self, message):\n        \"\"\"معالج إيقاف وسيلة دفع\"\"\"\n        methods = self.get_all_payment_methods()\n        active_methods = [m for m in methods if m['status'] == 'active']\n        \n        if not active_methods:\n            self.send_message(message['chat']['id'], \"❌ لا توجد وسائل دفع نشطة لإيقافها\", self.admin_keyboard())\n            return\n        \n        methods_text = \"⏹️ اختر وسيلة الدفع لإيقافها:\\n\\n\"\n        keyboard = []\n        \n        for method in active_methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            methods_text += f\"🆔 {method['id']} - {method['method_name']}\\n\"\n            methods_text += f\"   🏢 {company_name}\\n\"\n            methods_text += f\"   💳 {method['method_type']}\\n\\n\"\n            \n            keyboard.append([{'text': f\"إيقاف {method['id']}\"}])\n        \n        keyboard.append([{'text': '🔙 العودة'}])\n        \n        self.user_states[message['from']['id']] = 'selecting_method_to_disable'\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def start_enable_payment_method_wizard(self, message):\n        \"\"\"معالج تشغيل وسيلة دفع\"\"\"\n        methods = self.get_all_payment_methods()\n        inactive_methods = [m for m in methods if m['status'] != 'active']\n        \n        if not inactive_methods:\n            self.send_message(message['chat']['id'], \"❌ جميع وسائل الدفع نشطة بالفعل\", self.admin_keyboard())\n            return\n        \n        methods_text = \"▶️ اختر وسيلة الدفع لتشغيلها:\\n\\n\"\n        keyboard = []\n        \n        for method in inactive_methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            methods_text += f\"🆔 {method['id']} - {method['method_name']}\\n\"\n            methods_text += f\"   🏢 {company_name}\\n\"\n            methods_text += f\"   💳 {method['method_type']}\\n\\n\"\n            \n            keyboard.append([{'text': f\"تشغيل {method['id']}\"}])\n        \n        keyboard.append([{'text': '🔙 العودة'}])\n        \n        self.user_states[message['from']['id']] = 'selecting_method_to_enable'\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def handle_method_disable_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع للإيقاف\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        if text.startswith('إيقاف '):\n            method_id = text.replace('إيقاف ', '').strip()\n            success = self.toggle_payment_method_status(method_id, 'inactive')\n            \n            if success:\n                method = self.get_payment_method_by_id(method_id)\n                if method:\n                    company = self.get_company_by_id(method['company_id'])\n                    company_name = company['name'] if company else 'غير محدد'\n                    \n                    success_msg = f\"\"\"⏹️ تم إيقاف وسيلة الدفع بنجاح!\n\n🆔 المعرف: {method_id}\n🏢 الشركة: {company_name}\n📋 الاسم: {method['method_name']}\n💳 النوع: {method['method_type']}\n📊 الحالة: متوقفة ❌\"\"\"\n                    \n                    self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n                else:\n                    self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على وسيلة الدفع {method_id}\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ فشل في إيقاف وسيلة الدفع {method_id}\", self.admin_keyboard())\n            \n            if user_id in self.user_states:\n                del self.user_states[user_id]\n    \n    def handle_method_enable_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع للتشغيل\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_payment_methods_management(message)\n            return\n        \n        if text.startswith('تشغيل '):\n            method_id = text.replace('تشغيل ', '').strip()\n            success = self.toggle_payment_method_status(method_id, 'active')\n            \n            if success:\n                method = self.get_payment_method_by_id(method_id)\n                if method:\n                    company = self.get_company_by_id(method['company_id'])\n                    company_name = company['name'] if company else 'غير محدد'\n                    \n                    success_msg = f\"\"\"▶️ تم تشغيل وسيلة الدفع بنجاح!\n\n🆔 المعرف: {method_id}\n🏢 الشركة: {company_name}\n📋 الاسم: {method['method_name']}\n💳 النوع: {method['method_type']}\n📊 الحالة: نشطة ✅\"\"\"\n                    \n                    self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n                else:\n                    self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على وسيلة الدفع {method_id}\", self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ فشل في تشغيل وسيلة الدفع {method_id}\", self.admin_keyboard())\n            \n            if user_id in self.user_states:\n                del self.user_states[user_id]\n    \n    def toggle_payment_method_status(self, method_id, new_status):\n        \"\"\"تغيير حالة وسيلة الدفع (تشغيل/إيقاف)\"\"\"\n        try:\n            methods = []\n            updated = False\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        row['status'] = new_status\n                        updated = True\n                        logger.info(f\"تم تغيير حالة وسيلة الدفع {method_id} إلى {new_status}\")\n                    methods.append(row)\n            \n            if updated:\n                with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(methods)\n                \n                return True\n            \n            return False\n        except Exception as e:\n            logger.error(f\"خطأ في تغيير حالة وسيلة الدفع {method_id}: {e}\")\n            return False\n    \n    def get_all_payment_methods(self):\n        \"\"\"الحصول على جميع وسائل الدفع\"\"\"\n        methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    methods.append(row)\n        except:\n            pass\n        return methods\n    \n    def get_payment_method_by_id(self, method_id):\n        \"\"\"الحصول على وسيلة دفع بالمعرف\"\"\"\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        return row\n        except Exception as e:\n            logger.error(f\"خطأ في البحث عن وسيلة الدفع {method_id}: {e}\")\n        return None\n    \n    def show_all_payment_methods(self, message):\n        \"\"\"عرض جميع وسائل الدفع المتاحة\"\"\"\n        methods_text = \"💳 جميع وسائل الدفع:\\n\\n\"\n        \n        try:\n            companies = self.get_companies()\n            company_names = {c['id']: c['name'] for c in companies}\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                methods_by_company = {}\n                \n                for row in reader:\n                    company_id = row['company_id']\n                    if company_id not in methods_by_company:\n                        methods_by_company[company_id] = []\n                    methods_by_company[company_id].append(row)\n                \n                for company_id, methods in methods_by_company.items():\n                    company_name = company_names.get(company_id, f\"شركة #{company_id}\")\n                    methods_text += f\"🏢 **{company_name}**:\\n\"\n                    \n                    for method in methods:\n                        status_emoji = \"✅\" if method['status'] == 'active' else \"⏹️\"\n                        status_text = \"نشطة\" if method['status'] == 'active' else \"متوقفة\"\n                        methods_text += f\"  {status_emoji} {method['method_name']} (#{method['id']}) - {status_text}\\n\"\n                        methods_text += f\"      📋 النوع: {method['method_type']}\\n\"\n                        methods_text += f\"      💳 البيانات: {method['account_data']}\\n\"\n                        if method['additional_info']:\n                            methods_text += f\"      💡 ملاحظات: {method['additional_info']}\\n\"\n                        methods_text += \"\\n\"\n                    methods_text += \"▫️▫️▫️▫️▫️▫️▫️▫️\\n\\n\"\n        except:\n            methods_text += \"❌ خطأ في قراءة البيانات\"\n        \n        # إضافة أوامر النسخ السريع\n        methods_text += \"\\n📋 **أوامر إدارة سريعة:**\\n\"\n        methods_text += \"• `اضافة_وسيلة_دفع ID_الشركة اسم_الوسيلة نوع_الوسيلة البيانات`\\n\"\n        methods_text += \"• `تعديل_وسيلة_دفع ID_الوسيلة البيانات_الجديدة`\\n\"\n        methods_text += \"• `حذف_وسيلة_دفع ID_الوسيلة`\\n\\n\"\n        \n        methods_text += \"💡 **مثال:**\\n\"\n        methods_text += \"`اضافة_وسيلة_دفع 1 حساب_مدى bank_account رقم:1234567890`\"\n        \n        keyboard = [\n            [{'text': '➕ إضافة وسيلة دفع'}, {'text': '✏️ تعديل وسيلة دفع'}],\n            [{'text': '🔄 تحديث القائمة'}, {'text': '↩️ العودة'}]\n        ]\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': False\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, reply_keyboard)\n    \n    def start_add_payment_method(self, message):\n        \"\"\"بدء إضافة وسيلة دفع جديدة\"\"\"\n        user_id = message['from']['id']\n        \n        # عرض الشركات المتاحة\n        companies = self.get_companies()\n        if not companies:\n            self.send_message(message['chat']['id'], \n                            \"❌ لا توجد شركات متاحة. يجب إضافة شركة أولاً\", \n                            self.admin_keyboard())\n            return\n        \n        companies_text = \"🏢 اختر الشركة لإضافة وسيلة دفع لها:\\n\\n\"\n        keyboard = []\n        \n        for company in companies:\n            companies_text += f\"🔹 {company['name']} (#{company['id']})\\n\"\n            keyboard.append([{'text': f\"{company['name']} (#{company['id']})\"}])\n        \n        keyboard.append([{'text': '🔙 العودة'}])\n        \n        self.user_states[user_id] = {\n            'step': 'adding_payment_method_select_company',\n            'companies': companies\n        }\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], companies_text, reply_keyboard)\n    \n    def handle_payment_method_selection(self, message, text):\n        \"\"\"معالجة اختيار وسيلة الدفع\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, {})\n        \n        if text in ['🔙 العودة لاختيار الشركة', '🔙 العودة', '⬅️ العودة']:\n            # العودة لاختيار الشركة\n            transaction_type = state.get('transaction_type')\n            if transaction_type == 'deposit':\n                self.create_deposit_request(message)\n            else:\n                self.create_withdrawal_request(message)\n            return\n        \n        # البحث عن وسيلة الدفع المختارة\n        methods = state.get('methods', [])\n        selected_method = None\n        \n        for method in methods:\n            if method['method_name'] == text:\n                selected_method = method\n                break\n        \n        if not selected_method:\n            self.send_message(message['chat']['id'], \"❌ اختيار غير صحيح. يرجى اختيار وسيلة دفع من القائمة\")\n            return\n        \n        # حفظ الوسيلة المختارة والانتقال للمرحلة التالية\n        transaction_type = state['transaction_type']\n        company_id = state['company_id']\n        company = self.get_company_by_id(company_id)\n        \n        # عرض تفاصيل الوسيلة وطلب رقم المحفظة مع خيار النسخ\n        wallet_text = f\"\"\"✅ تم اختيار وسيلة الدفع: {selected_method['method_name']}\n\n💳 تفاصيل الوسيلة:\n📋 النوع: {selected_method['method_type']}\n🏢 الشركة: {company['name'] if company else 'غير محدد'}\n💰 رقم الحساب/المحفظة: `{selected_method['account_data']}`\n💡 معلومات إضافية: {selected_method.get('additional_info', 'لا توجد')}\n\n📋 يمكنك نسخ رقم الحساب أعلاه بسهولة\n📝 الآن أدخل رقم محفظتك/حسابك الشخصي:\"\"\"\n        \n        self.send_message(message['chat']['id'], wallet_text)\n        \n        # تحديث الحالة\n        if transaction_type == 'deposit':\n            self.user_states[user_id] = f'deposit_wallet_{company_id}_{company[\"name\"] if company else \"unknown\"}_{selected_method[\"id\"]}'\n        else:\n            self.user_states[user_id] = f'withdraw_wallet_{company_id}_{company[\"name\"] if company else \"unknown\"}_{selected_method[\"id\"]}'\n    \n    def get_company_by_id(self, company_id):\n        \"\"\"الحصول على شركة بواسطة ID\"\"\"\n        companies = self.get_companies()\n        for company in companies:\n            if company['id'] == str(company_id):\n                return company\n        return None\n    \n    def start_send_user_message(self, message):\n        \"\"\"بدء إرسال رسالة لعميل محدد\"\"\"\n        user_id = message['from']['id']\n        \n        instruction_text = \"\"\"📧 إرسال رسالة لعميل محدد\n        \n📝 أدخل رقم العميل الذي تريد إرسال رسالة إليه:\n\nمثال: C123456\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], instruction_text)\n        self.user_states[user_id] = 'sending_user_message_id'\n    \n    def handle_user_message_id(self, message):\n        \"\"\"معالجة رقم العميل لإرسال الرسالة\"\"\"\n        user_id = message['from']['id']\n        customer_id = message.get('text', '').strip()\n        \n        if customer_id == '/cancel':\n            del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم إلغاء إرسال الرسالة\", self.admin_keyboard())\n            return\n        \n        # البحث عن العميل\n        user_found = None\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        user_found = row\n                        break\n        except:\n            pass\n        \n        if not user_found:\n            self.send_message(message['chat']['id'], \n                            f\"❌ لم يتم العثور على عميل برقم: {customer_id}\\n\\nيرجى التحقق من الرقم والمحاولة مرة أخرى:\")\n            return\n        \n        # عرض معلومات العميل وطلب الرسالة\n        customer_info = f\"\"\"✅ تم العثور على العميل:\n\n👤 الاسم: {user_found['name']}\n📱 الهاتف: {user_found['phone']}\n🆔 رقم العميل: {user_found['customer_id']}\n📅 تاريخ التسجيل: {user_found.get('registration_date', 'غير محدد')}\n🚫 الحالة: {'محظور' if user_found.get('is_banned') == 'yes' else 'نشط'}\n\n📝 الآن أدخل الرسالة التي تريد إرسالها لهذا العميل:\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], customer_info)\n        self.user_states[user_id] = f'sending_user_message_{customer_id}'\n    \n    def handle_user_message_content(self, message, customer_id):\n        \"\"\"معالجة محتوى الرسالة وإرسالها\"\"\"\n        user_id = message['from']['id']\n        message_content = message.get('text', '').strip()\n        \n        if message_content == '/cancel':\n            del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم إلغاء إرسال الرسالة\", self.admin_keyboard())\n            return\n        \n        if not message_content:\n            self.send_message(message['chat']['id'], \"❌ الرسالة فارغة. يرجى كتابة الرسالة:\")\n            return\n        \n        # البحث عن معرف التليجرام للعميل\n        target_telegram_id = None\n        customer_name = \"\"\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        target_telegram_id = row['user_id']\n                        customer_name = row['name']\n                        break\n        except:\n            pass\n        \n        if not target_telegram_id:\n            self.send_message(message['chat']['id'], \n                            f\"❌ لم يتم العثور على معرف التليجرام للعميل {customer_id}\", \n                            self.admin_keyboard())\n            del self.user_states[user_id]\n            return\n        \n        # إرسال الرسالة للعميل بدون لوحة مفاتيح حتى لا تؤثر على الأزرار\n        admin_info = self.find_user(user_id)\n        admin_name = admin_info.get('name', 'الإدارة') if admin_info else 'الإدارة'\n        \n        customer_message = f\"\"\"📧 رسالة من الإدارة\n        \nمن: {admin_name}\nالتاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n━━━━━━━━━━━━━━━━━━━━\n\n{message_content}\n\n━━━━━━━━━━━━━━━━━━━━\n\n💬 للرد على هذه الرسالة، استخدم قسم الشكاوى في النظام\"\"\"\n        \n        # محاولة إرسال الرسالة بدون لوحة مفاتيح\n        try:\n            response = self.send_message(int(target_telegram_id), customer_message, None)\n            \n            # إشعار الأدمن بنجاح الإرسال\n            success_msg = f\"\"\"✅ تم إرسال الرسالة بنجاح!\n\n📧 إلى العميل: {customer_name} ({customer_id})\n📅 وقت الإرسال: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n📝 محتوى الرسالة:\n{message_content}\"\"\"\n            \n            self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n            \n        except Exception as e:\n            # فشل في الإرسال\n            error_msg = f\"\"\"❌ فشل في إرسال الرسالة!\n\n🎯 العميل: {customer_name} ({customer_id})\n⚠️ السبب: العميل قد يكون حظر البوت أو حذف المحادثة\n\n💡 يمكنك التواصل معه عبر:\n📱 الهاتف المسجل في النظام\n📧 البريد الإلكتروني (إن وجد)\"\"\"\n            \n            self.send_message(message['chat']['id'], error_msg, self.admin_keyboard())\n        \n        # حذف الحالة\n        del self.user_states[user_id]\n    \n    def start_edit_payment_method(self, message):\n        \"\"\"بدء تعديل وسيلة دفع\"\"\"\n        user_id = message['from']['id']\n        \n        # عرض جميع وسائل الدفع للاختيار\n        methods = self.get_all_payment_methods()\n        \n        if not methods:\n            self.send_message(message['chat']['id'], \n                            \"❌ لا توجد وسائل دفع في النظام حالياً\", \n                            self.admin_keyboard())\n            return\n        \n        methods_text = \"✏️ اختر وسيلة الدفع للتعديل:\\n\\n\"\n        \n        keyboard_buttons = []\n        for method in methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            method_info = f\"🆔 {method['id']} | {method['method_name']} | {company_name}\"\n            methods_text += f\"{method_info}\\n\"\n            keyboard_buttons.append([{'text': f\"تعديل {method['id']}\"}])\n        \n        keyboard_buttons.append([{'text': '🔙 العودة'}])\n        \n        keyboard = {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, keyboard)\n        self.user_states[user_id] = 'selecting_method_to_edit'\n    \n    def start_delete_payment_method(self, message):\n        \"\"\"بدء حذف وسيلة دفع\"\"\"\n        user_id = message['from']['id']\n        \n        # عرض جميع وسائل الدفع للاختيار\n        methods = self.get_all_payment_methods()\n        \n        if not methods:\n            self.send_message(message['chat']['id'], \n                            \"❌ لا توجد وسائل دفع في النظام حالياً\", \n                            self.admin_keyboard())\n            return\n        \n        methods_text = \"🗑️ اختر وسيلة الدفع للحذف:\\n\\n\"\n        \n        keyboard_buttons = []\n        for method in methods:\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            method_info = f\"🆔 {method['id']} | {method['method_name']} | {company_name}\"\n            methods_text += f\"{method_info}\\n\"\n            keyboard_buttons.append([{'text': f\"حذف {method['id']}\"}])\n        \n        keyboard_buttons.append([{'text': '🔙 العودة'}])\n        \n        keyboard = {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, keyboard)\n        self.user_states[user_id] = 'selecting_method_to_delete'\n    \n    def get_all_payment_methods(self):\n        \"\"\"الحصول على جميع وسائل الدفع\"\"\"\n        methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row.get('status') == 'active':\n                        methods.append(row)\n        except:\n            pass\n        return methods\n    \n    def delete_payment_method(self, method_id):\n        \"\"\"حذف وسيلة دفع\"\"\"\n        try:\n            methods = []\n            deleted = False\n            deleted_method = None\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] != str(method_id):\n                        methods.append(row)\n                    else:\n                        deleted = True\n                        deleted_method = row\n            \n            if deleted:\n                # إعادة كتابة الملف بدون الوسيلة المحذوفة\n                with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(methods)\n                \n                return True, deleted_method\n            else:\n                return False, None\n        except Exception as e:\n            return False, None\n    \n    def handle_method_edit_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع للتعديل\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة', '↩️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم الإلغاء\", self.admin_keyboard())\n            return\n        \n        if text.startswith('تعديل '):\n            method_id = text.replace('تعديل ', '').strip()\n            \n            # البحث عن وسيلة الدفع\n            method = self.get_payment_method_by_id(method_id)\n            if not method:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على وسيلة الدفع {method_id}\")\n                return\n            \n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            # عرض تفاصيل الوسيلة وطلب البيانات الجديدة\n            edit_text = f\"\"\"✏️ تعديل وسيلة الدفع:\n\n🆔 المعرف: {method['id']}\n🏢 الشركة: {company_name}\n📋 الاسم: {method['method_name']}\n💳 النوع: {method['method_type']}\n📊 البيانات الحالية: {method['account_data']}\n💡 معلومات إضافية: {method['additional_info']}\n\n📝 أدخل البيانات الجديدة (رقم الحساب/المحفظة):\n\n⬅️ /cancel للإلغاء\"\"\"\n            \n            self.send_message(message['chat']['id'], edit_text)\n            self.user_states[user_id] = f'editing_method_{method_id}'\n    \n    def handle_method_delete_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع للحذف\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text in ['🔙 العودة', '⬅️ العودة', '↩️ العودة']:\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم الإلغاء\", self.admin_keyboard())\n            return\n        \n        if text.startswith('حذف '):\n            method_id = text.replace('حذف ', '').strip()\n            \n            # حذف وسيلة الدفع\n            success, deleted_method = self.delete_payment_method(method_id)\n            \n            if success:\n                company = self.get_company_by_id(deleted_method['company_id'])\n                company_name = company['name'] if company else 'غير محدد'\n                \n                success_msg = f\"\"\"✅ تم حذف وسيلة الدفع بنجاح!\n\n🗑️ المحذوفة:\n🆔 المعرف: {deleted_method['id']}\n🏢 الشركة: {company_name}\n📋 الاسم: {deleted_method['method_name']}\n💳 النوع: {deleted_method['method_type']}\"\"\"\n                \n                self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n            else:\n                self.send_message(message['chat']['id'], f\"❌ فشل في حذف وسيلة الدفع {method_id}\", self.admin_keyboard())\n            \n            del self.user_states[user_id]\n    \n    def handle_method_edit_data(self, message, method_id):\n        \"\"\"معالجة تعديل بيانات وسيلة الدفع\"\"\"\n        user_id = message['from']['id']\n        new_data = message.get('text', '').strip()\n        \n        if new_data == '/cancel':\n            del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم إلغاء التعديل\", self.admin_keyboard())\n            return\n        \n        if not new_data:\n            self.send_message(message['chat']['id'], \"❌ البيانات فارغة. يرجى إدخال البيانات الجديدة:\")\n            return\n        \n        # تحديث وسيلة الدفع\n        success = self.update_payment_method(method_id, new_data)\n        \n        if success:\n            method = self.get_payment_method_by_id(method_id)\n            company = self.get_company_by_id(method['company_id'])\n            company_name = company['name'] if company else 'غير محدد'\n            \n            success_msg = f\"\"\"✅ تم تحديث وسيلة الدفع بنجاح!\n\n📝 المُحدّثة:\n🆔 المعرف: {method['id']}\n🏢 الشركة: {company_name}\n📋 الاسم: {method['method_name']}\n💳 النوع: {method['method_type']}\n📊 البيانات الجديدة: {new_data}\"\"\"\n            \n            self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], \"❌ فشل في تحديث وسيلة الدفع\", self.admin_keyboard())\n        \n        del self.user_states[user_id]\n    \n    def get_payment_method_by_id(self, method_id):\n        \"\"\"الحصول على وسيلة دفع بواسطة المعرف\"\"\"\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        return row\n        except:\n            pass\n        return None\n    \n    def update_payment_method(self, method_id, new_account_data):\n        \"\"\"تحديث بيانات وسيلة الدفع - تحديث قديم\"\"\"\n        try:\n            methods = []\n            updated = False\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        row['account_data'] = new_account_data\n                        updated = True\n                    methods.append(row)\n            \n            if updated:\n                with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(methods)\n                \n                return True\n            return False\n        except Exception as e:\n            return False\n\n    def update_payment_method_complete(self, method_id, new_data):\n        \"\"\"تحديث شامل لوسيلة الدفع - جميع الحقول\"\"\"\n        try:\n            methods = []\n            updated = False\n            \n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == str(method_id):\n                        # تحديث جميع الحقول المطلوبة\n                        if 'method_name' in new_data:\n                            row['method_name'] = new_data['method_name']\n                        if 'method_type' in new_data:\n                            row['method_type'] = new_data['method_type']\n                        if 'account_data' in new_data:\n                            row['account_data'] = new_data['account_data']\n                        if 'additional_info' in new_data:\n                            row['additional_info'] = new_data['additional_info']\n                        updated = True\n                    methods.append(row)\n            \n            if updated:\n                with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(methods)\n                \n                return True\n            return False\n        except Exception as e:\n            logger.error(f\"خطأ في تحديث وسيلة الدفع {method_id}: {e}\")\n            return False\n    \n    def start_backup_scheduler(self):\n        \"\"\"بدء نظام النسخ الاحتياطي التلقائي كل 6 ساعات\"\"\"\n        def backup_worker():\n            while True:\n                try:\n                    # انتظار 6 ساعات (21600 ثانية)\n                    time.sleep(21600)  # 6 ساعات\n                    self.send_backup_to_admins()\n                except Exception as e:\n                    logger.error(f\"خطأ في نظام النسخ الاحتياطي: {e}\")\n                    \n        # تشغيل النظام في خيط منفصل\n        backup_thread = threading.Thread(target=backup_worker, daemon=True)\n        backup_thread.start()\n        logger.info(\"تم بدء نظام النسخ الاحتياطي التلقائي (كل 6 ساعات)\")\n    \n    def create_backup_zip(self):\n        \"\"\"إنشاء ملف مضغوط يحتوي على جميع بيانات النظام\"\"\"\n        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')\n        zip_filename = f\"DUX_Backup_{timestamp}.zip\"\n        \n        try:\n            with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:\n                # إضافة ملفات البيانات الأساسية\n                files_to_backup = [\n                    'users.csv',\n                    'transactions.csv', \n                    'companies.csv',\n                    'complaints.csv',\n                    'payment_methods.csv',\n                    'exchange_addresses.csv',\n                    'system_settings.csv'\n                ]\n                \n                for file in files_to_backup:\n                    if os.path.exists(file):\n                        zipf.write(file)\n                        \n                # إنشاء تقرير ملخص\n                self.create_summary_report(zipf, timestamp)\n                \n            logger.info(f\"تم إنشاء النسخة الاحتياطية: {zip_filename}\")\n            return zip_filename\n            \n        except Exception as e:\n            logger.error(f\"فشل في إنشاء النسخة الاحتياطية: {e}\")\n            return None\n    \n    def create_summary_report(self, zipf, timestamp):\n        \"\"\"إنشاء تقرير ملخص للنسخة الاحتياطية\"\"\"\n        report_content = f\"\"\"تقرير النسخة الاحتياطية - {timestamp}\n{'=' * 50}\n\n📊 إحصائيات النظام:\n\"\"\"\n        \n        try:\n            # إحصائيات المستخدمين\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                users_count = len(list(csv.DictReader(f)))\n                report_content += f\"• عدد المستخدمين المسجلين: {users_count}\\n\"\n                \n            # إحصائيات المعاملات\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                transactions = list(reader)\n                total_transactions = len(transactions)\n                pending = sum(1 for t in transactions if t['status'] == 'pending')\n                approved = sum(1 for t in transactions if t['status'] == 'approved')\n                rejected = sum(1 for t in transactions if t['status'] == 'rejected')\n                \n                report_content += f\"• إجمالي المعاملات: {total_transactions}\\n\"\n                report_content += f\"  - معلقة: {pending}\\n\"\n                report_content += f\"  - موافقة: {approved}\\n\"\n                report_content += f\"  - مرفوضة: {rejected}\\n\"\n                \n            # إحصائيات الشركات\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                companies_count = len(list(csv.DictReader(f)))\n                report_content += f\"• عدد الشركات: {companies_count}\\n\"\n                \n        except Exception as e:\n            report_content += f\"خطأ في جمع الإحصائيات: {e}\\n\"\n            \n        report_content += f\"\\n📅 تاريخ النسخة: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\\n\"\n        report_content += f\"🤖 البوت: @depositbettingbot\\n\"\n        \n        # حفظ التقرير كملف نصي داخل الـ ZIP\n        zipf.writestr('backup_report.txt', report_content.encode('utf-8'))\n    \n    def send_document(self, chat_id, file_path, caption=\"\"):\n        \"\"\"إرسال ملف لمحادثة معينة\"\"\"\n        try:\n            # قراءة الملف\n            with open(file_path, 'rb') as f:\n                file_data = f.read()\n            \n            # إعداد البيانات للإرسال\n            url = f\"{self.api_url}/sendDocument\"\n            \n            # إنشاء multipart/form-data\n            boundary = '----WebKitFormBoundary7MA4YWxkTrZu0gW'\n            \n            # بناء البيانات\n            data = []\n            data.append(f'--{boundary}')\n            data.append('Content-Disposition: form-data; name=\"chat_id\"')\n            data.append('')\n            data.append(str(chat_id))\n            \n            if caption:\n                data.append(f'--{boundary}')\n                data.append('Content-Disposition: form-data; name=\"caption\"')\n                data.append('')\n                data.append(caption)\n            \n            data.append(f'--{boundary}')\n            data.append(f'Content-Disposition: form-data; name=\"document\"; filename=\"{os.path.basename(file_path)}\"')\n            data.append('Content-Type: application/zip')\n            data.append('')\n            \n            # تحويل إلى bytes\n            body = '\\r\\n'.join(data).encode('utf-8')\n            body += b'\\r\\n' + file_data + f'\\r\\n--{boundary}--\\r\\n'.encode('utf-8')\n            \n            # إنشاء الطلب\n            req = urllib.request.Request(url, data=body)\n            req.add_header('Content-Type', f'multipart/form-data; boundary={boundary}')\n            \n            # إرسال الطلب\n            with urllib.request.urlopen(req, timeout=30) as response:\n                result = json.loads(response.read().decode('utf-8'))\n                return result\n                \n        except Exception as e:\n            logger.error(f\"فشل في إرسال الملف: {e}\")\n            return None\n    \n    def get_chat_id_by_username(self, username):\n        \"\"\"الحصول على معرف المحادثة من اسم المستخدم\"\"\"\n        try:\n            # إزالة علامة @ إذا كانت موجودة\n            if username.startswith('@'):\n                username = username[1:]\n            \n            # استخدام getChat API للحصول على معلومات المحادثة\n            url = f\"{self.api_url}/getChat\"\n            data = {'chat_id': f'@{username}'}\n            \n            req = urllib.request.Request(url, data=json.dumps(data).encode('utf-8'))\n            req.add_header('Content-Type', 'application/json')\n            \n            with urllib.request.urlopen(req, timeout=10) as response:\n                result = json.loads(response.read().decode('utf-8'))\n                \n                if result.get('ok') and 'result' in result:\n                    return result['result']['id']\n                    \n        except Exception as e:\n            logger.error(f\"فشل في الحصول على معرف {username}: {e}\")\n            \n        return None\n\n    def send_backup_to_admins(self):\n        \"\"\"إرسال النسخة الاحتياطية لجميع الإدارة\"\"\"\n        logger.info(\"بدء إرسال النسخة الاحتياطية للإدارة...\")\n        \n        # إنشاء النسخة الاحتياطية\n        backup_file = self.create_backup_zip()\n        \n        if not backup_file:\n            logger.error(\"فشل في إنشاء النسخة الاحتياطية\")\n            return\n            \n        try:\n            # رسالة مرافقة للنسخة الاحتياطية\n            caption = f\"\"\"📦 نسخة احتياطية تلقائية\n\n🤖 البوت: @depositbettingbot\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n⏰ النسخ التلقائي: كل 6 ساعات\n\n📋 المحتويات:\n• بيانات المستخدمين\n• المعاملات المالية\n• الشركات ووسائل الدفع\n• الشكاوى والإعدادات\n• تقرير إحصائي شامل\n\n🔒 البيانات آمنة ومشفرة\"\"\"\n\n            # إرسال لحساب @Aba10o0 المحدد (إذا تم تفعيله)\n            backup_recipients = [\n                # إضافة المعرف الرقمي هنا عندما يصبح متاحاً\n                # مثال: 123456789  # @Aba10o0\n            ]\n            \n            for recipient_id in backup_recipients:\n                try:\n                    result = self.send_document(recipient_id, backup_file, caption)\n                    if result and result.get('ok'):\n                        logger.info(f\"تم إرسال النسخة الاحتياطية بنجاح للمستلم: {recipient_id}\")\n                    else:\n                        logger.error(f\"فشل في إرسال النسخة للمستلم: {recipient_id}\")\n                except Exception as e:\n                    logger.error(f\"خطأ في إرسال النسخة للمستلم {recipient_id}: {e}\")\n                \n            # إرسال للإدارة العادية أيضاً كنسخة احتياطية\n            sent_count = 0\n            for admin_id in self.admin_ids:\n                try:\n                    if str(admin_id).isdigit():  # إرسال فقط للمعرفات الرقمية\n                        result = self.send_document(admin_id, backup_file, caption)\n                        if result and result.get('ok'):\n                            sent_count += 1\n                            logger.info(f\"تم إرسال النسخة الاحتياطية للإدارة: {admin_id}\")\n                        else:\n                            logger.error(f\"فشل في إرسال النسخة للإدارة: {admin_id}\")\n                except Exception as e:\n                    logger.error(f\"خطأ في إرسال النسخة للإدارة {admin_id}: {e}\")\n                    \n            # حذف الملف المؤقت\n            try:\n                os.remove(backup_file)\n                logger.info(f\"تم حذف الملف المؤقت: {backup_file}\")\n            except:\n                pass\n                \n            logger.info(f\"تم إرسال النسخة الاحتياطية لـ @{target_username} + {sent_count} إدارة إضافية\")\n            \n        except Exception as e:\n            logger.error(f\"خطأ في إرسال النسخة الاحتياطية: {e}\")\n    \n    def manual_backup_command(self, message):\n        \"\"\"أمر يدوي لإنشاء وإرسال نسخة احتياطية فورية\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n            \n        self.send_message(message['chat']['id'], \"🔄 جاري إنشاء النسخة الاحتياطية...\")\n        \n        # إنشاء وإرسال النسخة\n        backup_file = self.create_backup_zip()\n        \n        if backup_file:\n            caption = f\"\"\"📦 نسخة احتياطية يدوية\n\n🤖 البوت: @depositbettingbot  \n📅 {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n👨‍💼 طلب من: الإدارة\n\n📋 جميع بيانات النظام محفوظة في هذا الملف\"\"\"\n\n            result = self.send_document(message['chat']['id'], backup_file, caption)\n            \n            if result and result.get('ok'):\n                self.send_message(message['chat']['id'], \"✅ تم إرسال النسخة الاحتياطية بنجاح!\")\n            else:\n                self.send_message(message['chat']['id'], \"❌ فشل في إرسال النسخة الاحتياطية\")\n                \n            # حذف الملف المؤقت\n            try:\n                os.remove(backup_file)\n            except:\n                pass\n        else:\n            self.send_message(message['chat']['id'], \"❌ فشل في إنشاء النسخة الاحتياطية\")\n    \n    def handle_complaint_reply_buttons(self, message, complaint_id):\n        \"\"\"معالجة أزرار الرد على الشكاوى\"\"\"\n        user_id = message['from']['id']\n        text = message.get('text', '').strip()\n        \n        if text == '🔙 العودة للشكاوى':\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_complaints_admin(message)\n            return\n        \n        # تحديد نوع الرد\n        reply_message = \"\"\n        if text.startswith('✅ تم الحل'):\n            reply_message = \"شكراً لتواصلك معنا. تم حل مشكلتك بنجاح ونعتذر عن أي إزعاج.\"\n        elif text.startswith('🔍 قيد المراجعة'):\n            reply_message = \"نحن نراجع طلبك بعناية وسنرد عليك خلال 24 ساعة. شكراً لصبرك.\"\n        elif text.startswith('📞 سنتواصل معك'):\n            reply_message = \"سنتواصل معك قريباً عبر الهاتف أو الرسائل. شكراً لتواصلك معنا.\"\n        elif text.startswith('💡 رد مخصص'):\n            # طلب رد مخصص\n            custom_text = \"\"\"💡 اكتب ردك المخصص:\n            \nمثال: شكراً لتواصلك، تم حل المشكلة...\n\n⬅️ /cancel للإلغاء\"\"\"\n            \n            self.send_message(message['chat']['id'], custom_text)\n            self.user_states[user_id] = f'writing_custom_reply_{complaint_id}'\n            return\n        \n        # حفظ الرد وإرساله للعميل\n        if reply_message:\n            success = self.save_complaint_reply(complaint_id, reply_message)\n            if success:\n                self.send_message(message['chat']['id'], f\"✅ تم إرسال الرد للعميل!\\n\\n📝 الرد: {reply_message}\", self.admin_keyboard())\n                # إرسال الرد للعميل\n                self.send_complaint_reply_to_customer(complaint_id, reply_message)\n            else:\n                self.send_message(message['chat']['id'], \"❌ فشل في حفظ الرد\", self.admin_keyboard())\n        \n        # تنظيف الحالة\n        if user_id in self.user_states:\n            del self.user_states[user_id]\n    \n    def save_complaint_reply(self, complaint_id, reply_message):\n        \"\"\"حفظ رد الشكوى\"\"\"\n        try:\n            complaints = []\n            updated = False\n            \n            with open('complaints.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == complaint_id:\n                        row['status'] = 'resolved'\n                        row['admin_response'] = reply_message\n                        updated = True\n                        logger.info(f\"تم العثور على الشكوى {complaint_id} وتحديثها\")\n                    complaints.append(row)\n            \n            if updated:\n                with open('complaints.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'customer_id', 'subject', 'message', 'status', 'date', 'admin_response']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    \n                    # تنظيف البيانات قبل الكتابة\n                    clean_complaints = []\n                    for complaint in complaints:\n                        clean_complaint = {}\n                        for field in fieldnames:\n                            clean_complaint[field] = complaint.get(field, '')\n                        clean_complaints.append(clean_complaint)\n                    \n                    writer.writerows(clean_complaints)\n                \n                return True\n            \n            return False\n        except Exception as e:\n            logger.error(f\"خطأ في حفظ رد الشكوى {complaint_id}: {e}\")\n            return False\n    \n    def send_complaint_reply_to_customer(self, complaint_id, reply_message):\n        \"\"\"إرسال رد الشكوى للعميل\"\"\"\n        try:\n            # البحث عن بيانات العميل\n            customer_telegram_id = None\n            \n            with open('complaints.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == complaint_id:\n                        customer_id = row['customer_id']\n                        \n                        # البحث عن التليجرام ID من ملف المستخدمين\n                        with open('users.csv', 'r', encoding='utf-8-sig') as users_file:\n                            users_reader = csv.DictReader(users_file)\n                            for user_row in users_reader:\n                                if user_row['customer_id'] == customer_id:\n                                    customer_telegram_id = user_row['telegram_id']\n                                    break\n                        break\n            \n            if customer_telegram_id:\n                customer_message = f\"\"\"📞 رد على شكواك:\n\n🆔 رقم الشكوى: {complaint_id}\n💬 الرد: {reply_message}\n\nشكراً لتواصلك معنا ونتطلع لخدمتك دائماً 🙏\"\"\"\n                \n                # إرسال الرد للعميل بدون كيبورد لعدم التداخل\n                result = self.send_message_without_keyboard(customer_telegram_id, customer_message)\n                if result and result.get('ok'):\n                    logger.info(f\"✅ تم إرسال رد الشكوى {complaint_id} للعميل {customer_telegram_id} بنجاح\")\n                else:\n                    logger.error(f\"❌ فشل في إرسال رد الشكوى {complaint_id} للعميل {customer_telegram_id}\")\n                    # محاولة أخرى بالطريقة العادية\n                    self.send_message(customer_telegram_id, customer_message)\n                \n        except Exception as e:\n            logger.error(f\"خطأ في إرسال رد الشكوى للعميل: {e}\")\n    \n    def send_message_without_keyboard(self, chat_id, text):\n        \"\"\"إرسال رسالة بدون كيبورد\"\"\"\n        try:\n            url = f\"https://api.telegram.org/bot{self.token}/sendMessage\"\n            data = {\n                'chat_id': chat_id,\n                'text': text,\n                'parse_mode': 'Markdown'\n            }\n            \n            # تحويل البيانات إلى JSON\n            json_data = json.dumps(data).encode('utf-8')\n            \n            # إنشاء الطلب\n            req = urllib.request.Request(url, data=json_data, headers={\n                'Content-Type': 'application/json',\n                'Content-Length': len(json_data)\n            })\n            \n            # إرسال الطلب\n            with urllib.request.urlopen(req) as response:\n                result = json.loads(response.read().decode('utf-8'))\n                return result\n                \n        except Exception as e:\n            logger.error(f\"Error sending message without keyboard: {e}\")\n            # محاولة بديلة بالطريقة العادية\n            try:\n                return self.send_message(chat_id, text)\n            except:\n                return None\n    \n    def show_support_data_editor(self, message):\n        \"\"\"عرض محرر بيانات الدعم\"\"\"\n        support_text = \"\"\"🛠️ محرر بيانات الدعم\n\nيمكنك تعديل بيانات الدعم والمساعدة من هنا:\n\n📞 رقم الدعم الحالي: {self.get_support_setting('support_phone', '+966123456789')}\n💬 رابط التليجرام: {self.get_support_setting('support_telegram', '@DUX_support')}\n📧 البريد الإلكتروني: {self.get_support_setting('support_email', 'support@dux.com')}\n🕒 ساعات العمل: {self.get_support_setting('support_hours', '9 صباحاً - 6 مساءً')}\n\nاستخدم الأوامر التالية للتعديل:\n\n📞 `تعديل_رقم +966987654321`\n💬 `تعديل_تليجرام @DUX_support`\n📧 `تعديل_بريد support@dux.com`\n🕒 `تعديل_ساعات 8 صباحاً - 10 مساءً`\n\nأو استخدم الأزرار أدناه للتعديل التفاعلي:\"\"\"\n        \n        keyboard = [\n            [{'text': '📞 تعديل رقم الهاتف'}],\n            [{'text': '💬 تعديل حساب التليجرام'}],\n            [{'text': '📧 تعديل البريد الإلكتروني'}],\n            [{'text': '🕒 تعديل ساعات العمل'}],\n            [{'text': '🔄 تحديث بيانات الدعم'}],\n            [{'text': '↩️ العودة للوحة الأدمن'}]\n        ]\n        \n        reply_keyboard = {\n            'keyboard': keyboard,\n            'resize_keyboard': True,\n            'one_time_keyboard': False\n        }\n        \n        self.send_message(message['chat']['id'], support_text, reply_keyboard)\n    \n    def start_phone_edit_wizard(self, message):\n        \"\"\"بدء معالج تعديل رقم الهاتف\"\"\"\n        edit_text = \"\"\"📞 تعديل رقم الهاتف\n\nالرقم الحالي: +966123456789\n\nاكتب الرقم الجديد:\nمثال: +966987654321\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], edit_text)\n        self.user_states[message['from']['id']] = 'editing_support_phone'\n    \n    def start_telegram_edit_wizard(self, message):\n        \"\"\"بدء معالج تعديل حساب التليجرام\"\"\"\n        edit_text = \"\"\"💬 تعديل حساب التليجرام\n\nالحساب الحالي: @DUX_support\n\nاكتب اسم المستخدم الجديد:\nمثال: @DUX_support\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], edit_text)\n        self.user_states[message['from']['id']] = 'editing_support_telegram'\n    \n    def start_email_edit_wizard(self, message):\n        \"\"\"بدء معالج تعديل البريد الإلكتروني\"\"\"\n        edit_text = \"\"\"📧 تعديل البريد الإلكتروني\n\nالبريد الحالي: support@dux.com\n\nاكتب البريد الجديد:\nمثال: support@dux.com\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], edit_text)\n        self.user_states[message['from']['id']] = 'editing_support_email'\n    \n    def start_hours_edit_wizard(self, message):\n        \"\"\"بدء معالج تعديل ساعات العمل\"\"\"\n        edit_text = \"\"\"🕒 تعديل ساعات العمل\n\nالساعات الحالية: 9 صباحاً - 6 مساءً\n\nاكتب ساعات العمل الجديدة:\nمثال: 8 صباحاً - 10 مساءً\n\n⬅️ /cancel للإلغاء\"\"\"\n        \n        self.send_message(message['chat']['id'], edit_text)\n        self.user_states[message['from']['id']] = 'editing_support_hours'\n    \n    def handle_support_data_edit(self, message, state):\n        \"\"\"معالجة تعديل بيانات الدعم\"\"\"\n        text = message.get('text', '').strip()\n        user_id = message['from']['id']\n        \n        if text == '/cancel':\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n            self.show_support_data_editor(message)\n            return\n        \n        # تحديد نوع التعديل\n        if state == 'editing_support_phone':\n            success_msg = f\"✅ تم تحديث رقم الهاتف إلى: {text}\"\n            self.save_support_setting('support_phone', text)\n        elif state == 'editing_support_telegram':\n            success_msg = f\"✅ تم تحديث حساب التليجرام إلى: {text}\"\n            self.save_support_setting('support_telegram', text)\n        elif state == 'editing_support_email':\n            success_msg = f\"✅ تم تحديث البريد الإلكتروني إلى: {text}\"\n            self.save_support_setting('support_email', text)\n        elif state == 'editing_support_hours':\n            success_msg = f\"✅ تم تحديث ساعات العمل إلى: {text}\"\n            self.save_support_setting('support_hours', text)\n        else:\n            success_msg = \"❌ خطأ في تحديث البيانات\"\n        \n        # إرسال رسالة التأكيد والعودة لمحرر البيانات\n        self.send_message(message['chat']['id'], success_msg, self.admin_keyboard())\n        \n        # تنظيف الحالة\n        if user_id in self.user_states:\n            del self.user_states[user_id]\n    \n    def save_support_setting(self, key, value):\n        \"\"\"حفظ إعداد الدعم\"\"\"\n        try:\n            # قراءة الإعدادات الموجودة\n            settings = []\n            setting_exists = False\n            \n            try:\n                with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                    reader = csv.DictReader(f)\n                    for row in reader:\n                        if row['setting_key'] == key:\n                            row['setting_value'] = value\n                            setting_exists = True\n                        settings.append(row)\n            except FileNotFoundError:\n                pass\n            \n            # إضافة الإعداد الجديد إذا لم يكن موجوداً\n            if not setting_exists:\n                descriptions = {\n                    'support_phone': 'رقم هاتف الدعم الفني',\n                    'support_telegram': 'حساب التليجرام للدعم',\n                    'support_email': 'بريد إلكتروني للدعم',\n                    'support_hours': 'ساعات عمل خدمة الدعم'\n                }\n                \n                settings.append({\n                    'setting_key': key,\n                    'setting_value': value,\n                    'description': descriptions.get(key, 'إعداد الدعم')\n                })\n            \n            # حفظ الإعدادات\n            with open('system_settings.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['setting_key', 'setting_value', 'description']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(settings)\n                \n            logger.info(f\"تم حفظ إعداد الدعم: {key} = {value}\")\n            \n        except Exception as e:\n            logger.error(f\"خطأ في حفظ إعداد الدعم: {e}\")\n    \n    def get_support_setting(self, key, default='غير محدد'):\n        \"\"\"قراءة إعداد الدعم\"\"\"\n        try:\n            with open('system_settings.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['setting_key'] == key:\n                        return row['setting_value']\n        except:\n            pass\n        return default\n\nif __name__ == \"__main__\":\n    # جلب التوكن\n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        logger.error(\"BOT_TOKEN غير موجود في متغيرات البيئة\")\n        exit(1)\n    \n    # تشغيل البوت\n    bot = ComprehensiveDUXBot(bot_token)\n    bot.run()","size_bytes":234534},"config.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nConfiguration module for the LangSense Bot\nLoads environment variables and provides configuration constants\n\"\"\"\n\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Bot Configuration\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\")\nif not BOT_TOKEN:\n    raise ValueError(\"BOT_TOKEN must be set in environment variables\")\n\n# Admin Configuration\nADMIN_USER_IDS_STR = os.getenv(\"ADMIN_USER_IDS\", \"\")\nADMIN_USER_IDS = [int(uid.strip()) for uid in ADMIN_USER_IDS_STR.split(\",\") if uid.strip().isdigit()]\n\nif not ADMIN_USER_IDS:\n    raise ValueError(\"ADMIN_USER_IDS must be set with at least one valid user ID\")\n\n# Database Configuration\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite+aiosqlite:///./langsense.db\")\n\n# Broadcast Configuration\nBROADCAST_RATE_LIMIT = int(os.getenv(\"BROADCAST_RATE_LIMIT\", \"30\"))  # messages per second\nBROADCAST_CHUNK_SIZE = int(os.getenv(\"BROADCAST_CHUNK_SIZE\", \"100\"))  # users per batch\nBROADCAST_RETRY_ATTEMPTS = int(os.getenv(\"BROADCAST_RETRY_ATTEMPTS\", \"3\"))\nBROADCAST_RETRY_DELAY = int(os.getenv(\"BROADCAST_RETRY_DELAY\", \"5\"))  # seconds\n\n# Localization Configuration\nDEFAULT_LANGUAGE = os.getenv(\"DEFAULT_LANGUAGE\", \"ar\")\nDEFAULT_COUNTRY = os.getenv(\"DEFAULT_COUNTRY\", \"SA\")\nSUPPORTED_LANGUAGES = [\"ar\", \"en\"]\n\n# Customer ID Configuration\nCUSTOMER_ID_PREFIX = os.getenv(\"CUSTOMER_ID_PREFIX\", \"C\")\nCUSTOMER_ID_YEAR_FORMAT = os.getenv(\"CUSTOMER_ID_YEAR_FORMAT\", \"2025\")\n\n# File Upload Configuration\nMAX_FILE_SIZE = int(os.getenv(\"MAX_FILE_SIZE\", \"20\")) * 1024 * 1024  # 20MB default\nALLOWED_IMAGE_TYPES = [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"]\n\n# Pagination Configuration\nUSERS_PER_PAGE = int(os.getenv(\"USERS_PER_PAGE\", \"10\"))\nANNOUNCEMENTS_PER_PAGE = int(os.getenv(\"ANNOUNCEMENTS_PER_PAGE\", \"5\"))\n\n# Logging Configuration\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\")\nLOG_FILE = os.getenv(\"LOG_FILE\", \"bot.log\")\n\n# Rate Limiting Configuration\nUSER_RATE_LIMIT = int(os.getenv(\"USER_RATE_LIMIT\", \"5\"))  # requests per minute\nADMIN_RATE_LIMIT = int(os.getenv(\"ADMIN_RATE_LIMIT\", \"30\"))  # requests per minute\n\n# Validation\ndef validate_config():\n    \"\"\"Validate configuration settings\"\"\"\n    errors = []\n    \n    if not BOT_TOKEN or len(BOT_TOKEN) < 40:\n        errors.append(\"Invalid BOT_TOKEN format\")\n    \n    if not ADMIN_USER_IDS:\n        errors.append(\"No valid admin user IDs configured\")\n    \n    if BROADCAST_RATE_LIMIT > 30:\n        errors.append(\"BROADCAST_RATE_LIMIT cannot exceed 30 messages/second (Telegram limit)\")\n    \n    if errors:\n        raise ValueError(\"Configuration errors: \" + \"; \".join(errors))\n\n# Validate configuration on import\nvalidate_config()\n","size_bytes":2685},"excel_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nLangSense Telegram Bot - Excel Based Storage\nNo databases, no servers - all data saved in Excel files\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nfrom urllib.request import urlopen, Request\nfrom urllib.parse import urlencode\nfrom urllib.error import URLError, HTTPError\nfrom datetime import datetime\nimport csv\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass ExcelTelegramBot:\n    def __init__(self, token):\n        self.token = token\n        self.api_url = f\"https://api.telegram.org/bot{token}\"\n        self.offset = 0\n        self.users_file = 'users_data.csv'\n        self.transactions_file = 'transactions_data.csv'\n        self.complaints_file = 'complaints_data.csv'\n        self.init_excel_files()\n        \n    def init_excel_files(self):\n        \"\"\"Initialize CSV files (Excel compatible)\"\"\"\n        # Initialize users file\n        if not os.path.exists(self.users_file):\n            with open(self.users_file, 'w', newline='', encoding='utf-8-sig') as file:\n                writer = csv.writer(file)\n                writer.writerow([\n                    'telegram_id', 'username', 'first_name', 'last_name', \n                    'phone_number', 'customer_code', 'language', 'country',\n                    'registration_date', 'is_active'\n                ])\n                \n        # Initialize transactions file  \n        if not os.path.exists(self.transactions_file):\n            with open(self.transactions_file, 'w', newline='', encoding='utf-8-sig') as file:\n                writer = csv.writer(file)\n                writer.writerow([\n                    'transaction_id', 'customer_code', 'telegram_id', 'type', \n                    'amount', 'status', 'request_date', 'approval_date',\n                    'notes', 'receipt_info'\n                ])\n                \n        # Initialize complaints file\n        if not os.path.exists(self.complaints_file):\n            with open(self.complaints_file, 'w', newline='', encoding='utf-8-sig') as file:\n                writer = csv.writer(file)\n                writer.writerow([\n                    'complaint_id', 'customer_code', 'telegram_id', 'subject',\n                    'description', 'status', 'submission_date', 'resolution_date',\n                    'admin_response'\n                ])\n                \n        logger.info(\"Excel files initialized successfully\")\n        \n    def make_request(self, method, params=None):\n        \"\"\"Make HTTP request to Telegram API\"\"\"\n        url = f\"{self.api_url}/{method}\"\n        \n        if params:\n            if method in ['sendMessage', 'sendPhoto', 'sendDocument']:\n                data = urlencode(params).encode('utf-8')\n                request = Request(url, data=data)\n                request.add_header('Content-Type', 'application/x-www-form-urlencoded')\n            else:\n                url += '?' + urlencode(params)\n                request = Request(url)\n        else:\n            request = Request(url)\n            \n        try:\n            with urlopen(request, timeout=30) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except (URLError, HTTPError, json.JSONDecodeError) as e:\n            logger.error(f\"API request failed: {e}\")\n            return None\n            \n    def send_message(self, chat_id, text, reply_markup=None):\n        \"\"\"Send message to user\"\"\"\n        params = {\n            'chat_id': chat_id,\n            'text': text,\n            'parse_mode': 'HTML'\n        }\n        \n        if reply_markup:\n            params['reply_markup'] = json.dumps(reply_markup)\n            \n        return self.make_request('sendMessage', params)\n        \n    def get_updates(self):\n        \"\"\"Get updates from Telegram\"\"\"\n        params = {\n            'offset': self.offset + 1,\n            'timeout': 10\n        }\n        return self.make_request('getUpdates', params)\n        \n    def get_main_menu_keyboard(self, lang='ar'):\n        \"\"\"Create main menu keyboard\"\"\"\n        if lang == 'ar':\n            return {\n                'keyboard': [\n                    [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}],\n                    [{'text': '📨 تقديم شكوى'}, {'text': '📋 حالة طلباتي'}],\n                    [{'text': '👨‍💼 أدوات الإدارة'}, {'text': '👤 بياناتي الشخصية'}],\n                    [{'text': '⚙️ تغيير اللغة'}, {'text': '🆘 المساعدة'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': False\n            }\n        else:\n            return {\n                'keyboard': [\n                    [{'text': '💰 Request Deposit'}, {'text': '💸 Request Withdrawal'}],\n                    [{'text': '📨 Submit Complaint'}, {'text': '📋 My Requests Status'}],\n                    [{'text': '👨‍💼 Admin Tools'}, {'text': '👤 My Profile'}],\n                    [{'text': '⚙️ Change Language'}, {'text': '🆘 Help'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': False\n            }\n            \n    def get_phone_request_keyboard(self, lang='ar'):\n        \"\"\"Create phone number request keyboard\"\"\"\n        text = '📱 مشاركة رقم الهاتف' if lang == 'ar' else '📱 Share Phone Number'\n        return {\n            'keyboard': [[{'text': text, 'request_contact': True}]],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n    def get_language_keyboard(self):\n        \"\"\"Create language selection keyboard\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '🇸🇦 العربية'}, {'text': '🇺🇸 English'}]\n            ],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n    def find_user_by_telegram_id(self, telegram_id):\n        \"\"\"Find user in CSV file\"\"\"\n        try:\n            with open(self.users_file, 'r', newline='', encoding='utf-8-sig') as file:\n                reader = csv.DictReader(file)\n                for row in reader:\n                    if row['telegram_id'] == str(telegram_id):\n                        return row\n            return None\n        except FileNotFoundError:\n            return None\n            \n    def save_user(self, user_data):\n        \"\"\"Save or update user in CSV file\"\"\"\n        users = []\n        user_exists = False\n        \n        # Read existing users\n        try:\n            with open(self.users_file, 'r', newline='', encoding='utf-8-sig') as file:\n                reader = csv.DictReader(file)\n                for row in reader:\n                    if row['telegram_id'] == str(user_data['telegram_id']):\n                        # Update existing user\n                        users.append(user_data)\n                        user_exists = True\n                    else:\n                        users.append(row)\n        except FileNotFoundError:\n            pass\n            \n        # Add new user if doesn't exist\n        if not user_exists:\n            users.append(user_data)\n            \n        # Write back to file\n        with open(self.users_file, 'w', newline='', encoding='utf-8-sig') as file:\n            if users:\n                fieldnames = users[0].keys()\n                writer = csv.DictWriter(file, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(users)\n                \n    def generate_customer_code(self):\n        \"\"\"Generate unique customer code\"\"\"\n        try:\n            with open(self.users_file, 'r', newline='', encoding='utf-8-sig') as file:\n                reader = csv.DictReader(file)\n                count = sum(1 for row in reader if row['customer_code'])\n                return f\"C-2025-{count + 1:06d}\"\n        except FileNotFoundError:\n            return \"C-2025-000001\"\n            \n    def save_transaction(self, transaction_data):\n        \"\"\"Save transaction request to CSV file\"\"\"\n        with open(self.transactions_file, 'a', newline='', encoding='utf-8-sig') as file:\n            fieldnames = [\n                'transaction_id', 'customer_code', 'telegram_id', 'type', \n                'amount', 'status', 'request_date', 'approval_date',\n                'notes', 'receipt_info'\n            ]\n            writer = csv.DictWriter(file, fieldnames=fieldnames)\n            \n            # Write header if file is empty\n            if file.tell() == 0:\n                writer.writeheader()\n                \n            writer.writerow(transaction_data)\n            \n    def save_complaint(self, complaint_data):\n        \"\"\"Save complaint to CSV file\"\"\"\n        with open(self.complaints_file, 'a', newline='', encoding='utf-8-sig') as file:\n            fieldnames = [\n                'complaint_id', 'customer_code', 'telegram_id', 'subject',\n                'description', 'status', 'submission_date', 'resolution_date',\n                'admin_response'\n            ]\n            writer = csv.DictWriter(file, fieldnames=fieldnames)\n            \n            # Write header if file is empty  \n            if file.tell() == 0:\n                writer.writeheader()\n                \n            writer.writerow(complaint_data)\n            \n    def get_user_transactions(self, customer_code):\n        \"\"\"Get user transactions from CSV\"\"\"\n        transactions = []\n        try:\n            with open(self.transactions_file, 'r', newline='', encoding='utf-8-sig') as file:\n                reader = csv.DictReader(file)\n                for row in reader:\n                    if row['customer_code'] == customer_code:\n                        transactions.append(row)\n        except FileNotFoundError:\n            pass\n        return transactions\n        \n    def get_user_complaints(self, customer_code):\n        \"\"\"Get user complaints from CSV\"\"\"\n        complaints = []\n        try:\n            with open(self.complaints_file, 'r', newline='', encoding='utf-8-sig') as file:\n                reader = csv.DictReader(file)\n                for row in reader:\n                    if row['customer_code'] == customer_code:\n                        complaints.append(row)\n        except FileNotFoundError:\n            pass\n        return complaints\n        \n    def handle_start(self, message):\n        \"\"\"Handle /start command\"\"\"\n        telegram_user = message['from']\n        user = self.find_user_by_telegram_id(telegram_user['id'])\n        \n        if not user or not user.get('phone_number'):\n            # New user or user without phone\n            welcome_text = (\n                f\"مرحباً بك {telegram_user['first_name']}! 🎉\\n\\n\"\n                \"أهلاً وسهلاً في نظام LangSense المالي.\\n\\n\"\n                \"لإكمال التسجيل، يرجى مشاركة رقم هاتفك معنا.\"\n            )\n            \n            self.send_message(\n                message['chat']['id'],\n                welcome_text,\n                self.get_phone_request_keyboard('ar')\n            )\n        else:\n            lang = user.get('language', 'ar')\n            welcome_text = (\n                f\"أهلاً وسهلاً بك مرة أخرى {user['first_name']}! 👋\\n\\n\"\n                f\"رقم العميل: {user['customer_code']}\\n\\n\"\n                \"اختر الخدمة المطلوبة من القائمة أدناه:\"\n            ) if lang == 'ar' else (\n                f\"Welcome back {user['first_name']}! 👋\\n\\n\"\n                f\"Customer ID: {user['customer_code']}\\n\\n\"\n                \"Select the required service from the menu below:\"\n            )\n            \n            self.send_message(\n                message['chat']['id'],\n                welcome_text,\n                self.get_main_menu_keyboard(lang)\n            )\n            \n    def handle_contact(self, message):\n        \"\"\"Handle contact sharing\"\"\"\n        contact = message['contact']\n        telegram_user = message['from']\n        \n        if contact['user_id'] == telegram_user['id']:\n            customer_code = self.generate_customer_code()\n            \n            user_data = {\n                'telegram_id': str(telegram_user['id']),\n                'username': telegram_user.get('username', ''),\n                'first_name': telegram_user['first_name'],\n                'last_name': telegram_user.get('last_name', ''),\n                'phone_number': contact['phone_number'],\n                'customer_code': customer_code,\n                'language': 'ar',\n                'country': 'SA',\n                'registration_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n                'is_active': 'Yes'\n            }\n            \n            self.save_user(user_data)\n            \n            success_text = (\n                f\"✅ تم تسجيل رقم الهاتف بنجاح!\\n\\n\"\n                f\"📱 الرقم: {contact['phone_number']}\\n\"\n                f\"🆔 رقم العميل: {customer_code}\\n\\n\"\n                \"أهلاً وسهلاً بك في نظام LangSense المالي!\"\n            )\n            \n            self.send_message(\n                message['chat']['id'],\n                success_text,\n                self.get_main_menu_keyboard('ar')\n            )\n            \n    def handle_deposit_request(self, message):\n        \"\"\"Handle deposit request\"\"\"\n        user = self.find_user_by_telegram_id(message['from']['id'])\n        if not user:\n            return\n            \n        lang = user.get('language', 'ar')\n        \n        transaction_id = f\"DEP-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        \n        response = (\n            f\"💰 طلب إيداع جديد\\n\\n\"\n            f\"🆔 رقم المعاملة: {transaction_id}\\n\\n\"\n            \"لإتمام طلب الإيداع، يرجى إرسال:\\n\"\n            \"1️⃣ المبلغ المراد إيداعه\\n\"\n            \"2️⃣ صورة إيصال التحويل\\n\\n\"\n            \"مثال: 1000 ريال\\n\\n\"\n            \"سيتم مراجعة طلبك خلال 24 ساعة.\"\n        ) if lang == 'ar' else (\n            f\"💰 New Deposit Request\\n\\n\"\n            f\"🆔 Transaction ID: {transaction_id}\\n\\n\"\n            \"To complete the deposit request, please send:\\n\"\n            \"1️⃣ Amount to deposit\\n\"\n            \"2️⃣ Transfer receipt image\\n\\n\"\n            \"Example: 1000 SAR\\n\\n\"\n            \"Your request will be reviewed within 24 hours.\"\n        )\n        \n        self.send_message(message['chat']['id'], response)\n        \n        # Save transaction request\n        transaction_data = {\n            'transaction_id': transaction_id,\n            'customer_code': user['customer_code'],\n            'telegram_id': str(message['from']['id']),\n            'type': 'Deposit',\n            'amount': '0',  # Will be updated when user provides amount\n            'status': 'Pending Info',\n            'request_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'approval_date': '',\n            'notes': 'Awaiting amount and receipt',\n            'receipt_info': ''\n        }\n        \n        self.save_transaction(transaction_data)\n        \n    def handle_withdrawal_request(self, message):\n        \"\"\"Handle withdrawal request\"\"\"\n        user = self.find_user_by_telegram_id(message['from']['id'])\n        if not user:\n            return\n            \n        lang = user.get('language', 'ar')\n        \n        transaction_id = f\"WD-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        \n        response = (\n            f\"💸 طلب سحب جديد\\n\\n\"\n            f\"🆔 رقم المعاملة: {transaction_id}\\n\\n\"\n            \"لإتمام طلب السحب، يرجى إرسال:\\n\"\n            \"1️⃣ المبلغ المراد سحبه\\n\"\n            \"2️⃣ بيانات الحساب البنكي\\n\"\n            \"3️⃣ صورة الهوية\\n\\n\"\n            \"مثال: 500 ريال\\n\"\n            \"البنك الأهلي - 1234567890\\n\\n\"\n            \"سيتم معالجة طلبك خلال 48 ساعة.\"\n        ) if lang == 'ar' else (\n            f\"💸 New Withdrawal Request\\n\\n\"\n            f\"🆔 Transaction ID: {transaction_id}\\n\\n\"\n            \"To complete the withdrawal request, please send:\\n\"\n            \"1️⃣ Amount to withdraw\\n\"\n            \"2️⃣ Bank account details\\n\"\n            \"3️⃣ ID photo\\n\\n\"\n            \"Example: 500 SAR\\n\"\n            \"National Bank - 1234567890\\n\\n\"\n            \"Your request will be processed within 48 hours.\"\n        )\n        \n        self.send_message(message['chat']['id'], response)\n        \n        # Save transaction request\n        transaction_data = {\n            'transaction_id': transaction_id,\n            'customer_code': user['customer_code'],\n            'telegram_id': str(message['from']['id']),\n            'type': 'Withdrawal',\n            'amount': '0',  # Will be updated when user provides amount\n            'status': 'Pending Info',\n            'request_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'approval_date': '',\n            'notes': 'Awaiting amount and bank details',\n            'receipt_info': ''\n        }\n        \n        self.save_transaction(transaction_data)\n        \n    def handle_complaint_request(self, message):\n        \"\"\"Handle complaint submission\"\"\"\n        user = self.find_user_by_telegram_id(message['from']['id'])\n        if not user:\n            return\n            \n        lang = user.get('language', 'ar')\n        \n        complaint_id = f\"COMP-{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        \n        response = (\n            f\"📨 تقديم شكوى جديدة\\n\\n\"\n            f\"🆔 رقم الشكوى: {complaint_id}\\n\\n\"\n            \"يرجى إرسال تفاصيل الشكوى:\\n\"\n            \"• موضوع الشكوى\\n\"\n            \"• تفاصيل المشكلة\\n\"\n            \"• أي مستندات مطلوبة\\n\\n\"\n            \"سيتم الرد على شكواك خلال 24 ساعة.\"\n        ) if lang == 'ar' else (\n            f\"📨 New Complaint Submission\\n\\n\"\n            f\"🆔 Complaint ID: {complaint_id}\\n\\n\"\n            \"Please send complaint details:\\n\"\n            \"• Subject of complaint\\n\"\n            \"• Problem details\\n\"\n            \"• Any required documents\\n\\n\"\n            \"Your complaint will be addressed within 24 hours.\"\n        )\n        \n        self.send_message(message['chat']['id'], response)\n        \n        # Save complaint\n        complaint_data = {\n            'complaint_id': complaint_id,\n            'customer_code': user['customer_code'],\n            'telegram_id': str(message['from']['id']),\n            'subject': 'Pending',\n            'description': 'Awaiting details',\n            'status': 'Submitted',\n            'submission_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),\n            'resolution_date': '',\n            'admin_response': ''\n        }\n        \n        self.save_complaint(complaint_data)\n        \n    def handle_status_check(self, message):\n        \"\"\"Handle status check request\"\"\"\n        user = self.find_user_by_telegram_id(message['from']['id'])\n        if not user:\n            return\n            \n        lang = user.get('language', 'ar')\n        \n        # Get transactions\n        transactions = self.get_user_transactions(user['customer_code'])\n        complaints = self.get_user_complaints(user['customer_code'])\n        \n        status_text = \"📋 حالة طلباتي\\n\\n\" if lang == 'ar' else \"📋 My Requests Status\\n\\n\"\n        \n        if transactions:\n            status_text += \"💰 المعاملات المالية:\\n\" if lang == 'ar' else \"💰 Financial Transactions:\\n\"\n            for trans in transactions[-5:]:  # Show last 5 transactions\n                status_text += f\"• {trans['transaction_id']} - {trans['type']} - {trans['status']}\\n\"\n            status_text += \"\\n\"\n            \n        if complaints:\n            status_text += \"📨 الشكاوى:\\n\" if lang == 'ar' else \"📨 Complaints:\\n\"\n            for comp in complaints[-3:]:  # Show last 3 complaints\n                status_text += f\"• {comp['complaint_id']} - {comp['status']}\\n\"\n            status_text += \"\\n\"\n            \n        if not transactions and not complaints:\n            status_text += \"لا توجد طلبات سابقة.\" if lang == 'ar' else \"No previous requests found.\"\n            \n        self.send_message(message['chat']['id'], status_text)\n        \n    def handle_profile(self, message):\n        \"\"\"Handle profile view\"\"\"\n        user = self.find_user_by_telegram_id(message['from']['id'])\n        if not user:\n            return\n            \n        lang = user.get('language', 'ar')\n        \n        profile_text = (\n            f\"👤 بياناتي الشخصية\\n\\n\"\n            f\"🏷️ الاسم: {user['first_name']} {user.get('last_name', '')}\\n\"\n            f\"👤 اسم المستخدم: @{user.get('username', 'غير محدد')}\\n\"\n            f\"📱 رقم الهاتف: {user.get('phone_number', 'غير محدد')}\\n\"\n            f\"🆔 رقم العميل: {user.get('customer_code', 'غير محدد')}\\n\"\n            f\"🌐 اللغة: {user.get('language', 'ar').upper()}\\n\"\n            f\"🌍 الدولة: {user.get('country', 'SA').upper()}\\n\"\n            f\"📅 تاريخ التسجيل: {user.get('registration_date', 'غير محدد')}\"\n        ) if lang == 'ar' else (\n            f\"👤 My Profile\\n\\n\"\n            f\"🏷️ Name: {user['first_name']} {user.get('last_name', '')}\\n\"\n            f\"👤 Username: @{user.get('username', 'Not Set')}\\n\"\n            f\"📱 Phone: {user.get('phone_number', 'Not Set')}\\n\"\n            f\"🆔 Customer ID: {user.get('customer_code', 'Not Set')}\\n\"\n            f\"🌐 Language: {user.get('language', 'ar').upper()}\\n\"\n            f\"🌍 Country: {user.get('country', 'SA').upper()}\\n\"\n            f\"📅 Registration: {user.get('registration_date', 'Not Set')}\"\n        )\n        \n        self.send_message(message['chat']['id'], profile_text)\n        \n    def handle_language_change(self, message):\n        \"\"\"Handle language change request\"\"\"\n        response = \"🌐 اختر اللغة المفضلة:\\n🇸🇦 العربية\\n🇺🇸 English\"\n        self.send_message(message['chat']['id'], response, self.get_language_keyboard())\n        \n    def handle_language_selection(self, message):\n        \"\"\"Handle language selection\"\"\"\n        text = message['text']\n        user = self.find_user_by_telegram_id(message['from']['id'])\n        \n        if not user:\n            return\n            \n        if '🇸🇦 العربية' in text:\n            new_lang = 'ar'\n            response = \"✅ تم تغيير اللغة إلى العربية بنجاح!\"\n        elif '🇺🇸 English' in text:\n            new_lang = 'en'\n            response = \"✅ Language changed to English successfully!\"\n        else:\n            return\n            \n        # Update user language\n        user['language'] = new_lang\n        self.save_user(user)\n        \n        self.send_message(message['chat']['id'], response, self.get_main_menu_keyboard(new_lang))\n        \n    def handle_admin_commands(self, message):\n        \"\"\"Handle admin commands\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        if str(message['from']['id']) not in admin_ids:\n            self.send_message(\n                message['chat']['id'],\n                \"🚫 غير مسموح! هذه الخدمة مخصصة للمشرفين فقط.\"\n            )\n            return\n            \n        # Count statistics from files\n        user_count = 0\n        transaction_count = 0\n        complaint_count = 0\n        \n        try:\n            with open(self.users_file, 'r', encoding='utf-8-sig') as f:\n                user_count = len(f.readlines()) - 1  # Subtract header\n        except:\n            pass\n            \n        try:\n            with open(self.transactions_file, 'r', encoding='utf-8-sig') as f:\n                transaction_count = len(f.readlines()) - 1\n        except:\n            pass\n            \n        try:\n            with open(self.complaints_file, 'r', encoding='utf-8-sig') as f:\n                complaint_count = len(f.readlines()) - 1\n        except:\n            pass\n            \n        admin_text = (\n            f\"🛠️ لوحة إدارة النظام\\n\\n\"\n            f\"📊 إحصائيات سريعة:\\n\"\n            f\"👥 المستخدمون: {user_count}\\n\"\n            f\"💰 المعاملات: {transaction_count}\\n\"\n            f\"📨 الشكاوى: {complaint_count}\\n\\n\"\n            f\"📁 الملفات:\\n\"\n            f\"• {self.users_file}\\n\"\n            f\"• {self.transactions_file}\\n\"\n            f\"• {self.complaints_file}\\n\\n\"\n            f\"يمكن فتح الملفات في Excel لإدارة البيانات\"\n        )\n        \n        self.send_message(message['chat']['id'], admin_text)\n        \n    def handle_text_message(self, message):\n        \"\"\"Handle text messages\"\"\"\n        text = message['text']\n        chat_id = message['chat']['id']\n        \n        user = self.find_user_by_telegram_id(message['from']['id'])\n        if not user:\n            return\n            \n        lang = user.get('language', 'ar')\n        \n        # Handle menu options\n        if text in ['💰 طلب إيداع', '💰 Request Deposit']:\n            self.handle_deposit_request(message)\n        elif text in ['💸 طلب سحب', '💸 Request Withdrawal']:\n            self.handle_withdrawal_request(message)\n        elif text in ['📨 تقديم شكوى', '📨 Submit Complaint']:\n            self.handle_complaint_request(message)\n        elif text in ['📋 حالة طلباتي', '📋 My Requests Status']:\n            self.handle_status_check(message)\n        elif text in ['👤 بياناتي الشخصية', '👤 My Profile']:\n            self.handle_profile(message)\n        elif text in ['⚙️ تغيير اللغة', '⚙️ Change Language']:\n            self.handle_language_change(message)\n        elif text in ['🇸🇦 العربية', '🇺🇸 English']:\n            self.handle_language_selection(message)\n        elif text in ['🆘 المساعدة', '🆘 Help']:\n            help_text = (\n                \"🆘 المساعدة\\n\\n\"\n                \"الخدمات المتاحة:\\n\"\n                \"💰 طلب إيداع - لإيداع الأموال\\n\"\n                \"💸 طلب سحب - لسحب الأموال\\n\"\n                \"📨 تقديم شكوى - لتقديم شكوى\\n\"\n                \"📋 حالة طلباتي - متابعة الطلبات\\n\"\n                \"👤 بياناتي - عرض البيانات الشخصية\\n\"\n                \"⚙️ تغيير اللغة - تغيير لغة الواجهة\\n\\n\"\n                \"للدعم الفني، تواصل مع الإدارة.\"\n            ) if lang == 'ar' else (\n                \"🆘 Help\\n\\n\"\n                \"Available services:\\n\"\n                \"💰 Request Deposit - For depositing funds\\n\"\n                \"💸 Request Withdrawal - For withdrawing funds\\n\"\n                \"📨 Submit Complaint - For submitting complaints\\n\"\n                \"📋 My Requests Status - Track requests\\n\"\n                \"👤 My Profile - View personal data\\n\"\n                \"⚙️ Change Language - Change interface language\\n\\n\"\n                \"For technical support, contact administration.\"\n            )\n            self.send_message(chat_id, help_text)\n        else:\n            response = (\n                \"❓ عذراً، لم أفهم طلبك. يرجى استخدام القائمة أدناه.\"\n            ) if lang == 'ar' else (\n                \"❓ Sorry, I didn't understand your request. Please use the menu below.\"\n            )\n            self.send_message(chat_id, response, self.get_main_menu_keyboard(lang))\n            \n    def run(self):\n        \"\"\"Main bot loop\"\"\"\n        logger.info(\"Starting LangSense Excel Bot...\")\n        \n        # Test bot token\n        result = self.make_request('getMe')\n        if not result or not result.get('ok'):\n            logger.error(\"Invalid bot token!\")\n            return\n            \n        logger.info(f\"Bot started: @{result['result']['username']}\")\n        logger.info(\"All data will be saved to Excel-compatible CSV files\")\n        logger.info(f\"Files: {self.users_file}, {self.transactions_file}, {self.complaints_file}\")\n        \n        while True:\n            try:\n                updates = self.get_updates()\n                \n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        self.offset = update['update_id']\n                        \n                        if 'message' in update:\n                            message = update['message']\n                            \n                            if 'text' in message:\n                                if message['text'] == '/start':\n                                    self.handle_start(message)\n                                elif message['text'] == '/admin':\n                                    self.handle_admin_commands(message)\n                                else:\n                                    self.handle_text_message(message)\n                            elif 'contact' in message:\n                                self.handle_contact(message)\n                                \n                time.sleep(1)\n                \n            except KeyboardInterrupt:\n                logger.info(\"Bot stopped by user\")\n                break\n            except Exception as e:\n                logger.error(f\"Error in bot loop: {e}\")\n                time.sleep(5)\n\ndef main():\n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        logger.error(\"BOT_TOKEN environment variable not set!\")\n        return\n        \n    bot = ExcelTelegramBot(bot_token)\n    bot.run()\n\nif __name__ == '__main__':\n    main()","size_bytes":30059},"fixed_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nLangSense Bot - مُحسن ومُبسط\nيحفظ البيانات في ملفات Excel بدون قواعد بيانات\n\"\"\"\n\nimport os\nimport json\nimport time\nimport logging\nimport csv\nfrom datetime import datetime\nimport urllib.request\nimport urllib.parse\nimport urllib.error\n\n# إعداد التسجيل\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass LangSenseBot:\n    def __init__(self, token):\n        self.token = token\n        self.api_url = f\"https://api.telegram.org/bot{token}\"\n        self.offset = 0\n        self.init_files()\n        \n    def init_files(self):\n        \"\"\"إنشاء ملفات Excel\"\"\"\n        # ملف المستخدمين\n        if not os.path.exists('users.csv'):\n            with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned', 'ban_reason'])\n        \n        # ملف المعاملات\n        if not os.path.exists('transactions.csv'):\n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'telegram_id', 'name', 'type', 'amount', 'status', 'date', 'admin_note', 'payment_method', 'receipt_info'])\n        \n        # ملف الشكاوى\n        if not os.path.exists('complaints.csv'):\n            with open('complaints.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'subject', 'message', 'status', 'date'])\n        \n        # ملف وسائل الدفع\n        if not os.path.exists('payment_methods.csv'):\n            with open('payment_methods.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'name', 'type', 'details', 'is_active', 'created_date'])\n                # إضافة وسائل افتراضية\n                writer.writerow(['1', 'البنك الأهلي', 'deposit', 'رقم الحساب: 1234567890', 'active', datetime.now().strftime('%Y-%m-%d')])\n                writer.writerow(['2', 'بنك الراجحي', 'deposit', 'رقم الحساب: 0987654321', 'active', datetime.now().strftime('%Y-%m-%d')])\n                writer.writerow(['3', 'STC Pay', 'withdraw', 'رقم الجوال: 0501234567', 'active', datetime.now().strftime('%Y-%m-%d')])\n        \n        logger.info(\"تم إنشاء ملفات Excel بنجاح\")\n        \n    def api_call(self, method, data=None):\n        \"\"\"استدعاء Telegram API مُبسط\"\"\"\n        url = f\"{self.api_url}/{method}\"\n        \n        try:\n            if data:\n                # تحويل البيانات إلى JSON\n                json_data = json.dumps(data).encode('utf-8')\n                req = urllib.request.Request(url, data=json_data)\n                req.add_header('Content-Type', 'application/json')\n            else:\n                req = urllib.request.Request(url)\n            \n            with urllib.request.urlopen(req, timeout=10) as response:\n                result = json.loads(response.read().decode('utf-8'))\n                return result\n                \n        except urllib.error.HTTPError as e:\n            error_body = e.read().decode('utf-8')\n            logger.error(f\"HTTP Error {e.code}: {error_body}\")\n            return None\n        except Exception as e:\n            logger.error(f\"خطأ في API: {e}\")\n            return None\n    \n    def send_message(self, chat_id, text, keyboard=None):\n        \"\"\"إرسال رسالة\"\"\"\n        data = {\n            'chat_id': chat_id,\n            'text': text,\n            'parse_mode': 'HTML'\n        }\n        \n        if keyboard:\n            data['reply_markup'] = keyboard\n            \n        return self.api_call('sendMessage', data)\n    \n    def get_updates(self):\n        \"\"\"جلب التحديثات\"\"\"\n        url = f\"{self.api_url}/getUpdates?offset={self.offset + 1}&timeout=10\"\n        \n        try:\n            with urllib.request.urlopen(url, timeout=15) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في جلب التحديثات: {e}\")\n            return None\n    \n    def main_keyboard(self, lang='ar'):\n        \"\"\"لوحة المفاتيح الرئيسية\"\"\"\n        if lang == 'ar':\n            return {\n                'keyboard': [\n                    [{'text': '💰 إيداع'}, {'text': '💸 سحب'}],\n                    [{'text': '📋 طلباتي'}, {'text': '👤 حسابي'}],\n                    [{'text': '📨 شكوى'}, {'text': '🇺🇸 English'}]\n                ],\n                'resize_keyboard': True\n            }\n        else:\n            return {\n                'keyboard': [\n                    [{'text': '💰 Deposit'}, {'text': '💸 Withdraw'}],\n                    [{'text': '📋 My Requests'}, {'text': '👤 Profile'}],\n                    [{'text': '📨 Complaint'}, {'text': '🇸🇦 العربية'}]\n                ],\n                'resize_keyboard': True\n            }\n    \n    def phone_keyboard(self, lang='ar'):\n        \"\"\"لوحة طلب رقم الهاتف\"\"\"\n        text = '📱 مشاركة رقم الهاتف' if lang == 'ar' else '📱 Share Phone'\n        return {\n            'keyboard': [[{'text': text, 'request_contact': True}]],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n    \n    def find_user(self, telegram_id):\n        \"\"\"البحث عن مستخدم\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['telegram_id'] == str(telegram_id):\n                        return row\n        except:\n            pass\n        return None\n    \n    def save_user(self, telegram_id, name, phone, customer_id, language='ar'):\n        \"\"\"حفظ مستخدم جديد\"\"\"\n        with open('users.csv', 'a', newline='', encoding='utf-8-sig') as f:\n            writer = csv.writer(f)\n            writer.writerow([\n                telegram_id, name, phone, customer_id, \n                language, datetime.now().strftime('%Y-%m-%d %H:%M'), 'no', ''\n            ])\n    \n    def generate_customer_id(self):\n        \"\"\"توليد رقم عميل\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                lines = f.readlines()\n                count = len(lines) - 1  # طرح سطر العناوين\n                return f\"C{count + 1:06d}\"\n        except:\n            return \"C000001\"\n    \n    def save_transaction(self, customer_id, telegram_id, name, trans_type, amount, payment_method='', receipt_info='', status='pending'):\n        \"\"\"حفظ معاملة\"\"\"\n        trans_id = f\"T{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n            writer = csv.writer(f)\n            writer.writerow([\n                trans_id, customer_id, telegram_id, name, trans_type, amount, \n                status, datetime.now().strftime('%Y-%m-%d %H:%M'), '', payment_method, receipt_info\n            ])\n        return trans_id\n    \n    def save_complaint(self, customer_id, subject, message, status='new'):\n        \"\"\"حفظ شكوى\"\"\"\n        comp_id = f\"COMP{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        with open('complaints.csv', 'a', newline='', encoding='utf-8-sig') as f:\n            writer = csv.writer(f)\n            writer.writerow([\n                comp_id, customer_id, subject, message, \n                status, datetime.now().strftime('%Y-%m-%d %H:%M')\n            ])\n        return comp_id\n    \n    def handle_start(self, message):\n        \"\"\"التعامل مع أمر /start\"\"\"\n        user_info = message['from']\n        user = self.find_user(user_info['id'])\n        \n        if not user:\n            # مستخدم جديد\n            text = f\"مرحباً {user_info['first_name']}! 🎉\\n\\nأهلاً بك في LangSense\\nيرجى مشاركة رقم هاتفك للتسجيل\"\n            self.send_message(message['chat']['id'], text, self.phone_keyboard())\n        else:\n            # مستخدم موجود\n            lang = user.get('language', 'ar')\n            text = f\"مرحباً {user['name']}! 👋\\nرقم العميل: {user['customer_id']}\" if lang == 'ar' else f\"Welcome {user['name']}! 👋\\nCustomer ID: {user['customer_id']}\"\n            self.send_message(message['chat']['id'], text, self.main_keyboard(lang))\n    \n    def handle_contact(self, message):\n        \"\"\"التعامل مع مشاركة رقم الهاتف\"\"\"\n        contact = message['contact']\n        user_info = message['from']\n        \n        if contact['user_id'] == user_info['id']:\n            customer_id = self.generate_customer_id()\n            name = user_info['first_name']\n            phone = contact['phone_number']\n            \n            self.save_user(user_info['id'], name, phone, customer_id)\n            \n            text = f\"✅ تم التسجيل بنجاح!\\n📱 الهاتف: {phone}\\n🆔 رقم العميل: {customer_id}\"\n            self.send_message(message['chat']['id'], text, self.main_keyboard())\n    \n    def is_admin(self, telegram_id):\n        \"\"\"فحص إذا كان المستخدم أدمن\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        return str(telegram_id) in admin_ids\n    \n    def is_user_banned(self, telegram_id):\n        \"\"\"فحص إذا كان المستخدم محظور\"\"\"\n        user = self.find_user(telegram_id)\n        return user and user.get('is_banned', 'no') == 'yes'\n    \n    def get_payment_methods(self, method_type=None):\n        \"\"\"جلب وسائل الدفع\"\"\"\n        methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if method_type is None or row['type'] == method_type:\n                        if row['is_active'] == 'active':\n                            methods.append(row)\n        except:\n            pass\n        return methods\n    \n    def handle_admin_commands(self, message):\n        \"\"\"أوامر الأدمن\"\"\"\n        if not self.is_admin(message['from']['id']):\n            self.send_message(message['chat']['id'], \"🚫 غير مسموح! هذا الأمر للأدمن فقط\")\n            return\n        \n        # إحصائيات\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                users_count = len(f.readlines()) - 1\n        except:\n            users_count = 0\n            \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                trans_list = list(reader)\n                trans_count = len(trans_list)\n                pending_count = len([t for t in trans_list if t['status'] == 'pending'])\n        except:\n            trans_count = 0\n            pending_count = 0\n        \n        try:\n            with open('complaints.csv', 'r', encoding='utf-8-sig') as f:\n                comp_count = len(f.readlines()) - 1\n        except:\n            comp_count = 0\n        \n        admin_text = f\"\"\"🛠️ لوحة الإدارة المتقدمة\n\n📊 الإحصائيات:\n👥 المستخدمين: {users_count}\n💰 المعاملات: {trans_count} (⏳ معلقة: {pending_count})\n📨 الشكاوى: {comp_count}\n\n🔧 أوامر إدارة المستخدمين:\n/search اسم_أو_رقم - البحث عن مستخدم\n/userinfo رقم_العميل - معلومات مستخدم\n/ban رقم_العميل سبب - حظر مستخدم\n/unban رقم_العميل - إلغاء حظر\n\n💳 إدارة وسائل الدفع:\n/payments - عرض وسائل الدفع\n/addpay نوع اسم تفاصيل - إضافة وسيلة دفع\n\n📋 إدارة الطلبات:\n/pending - الطلبات المعلقة\n/approve رقم_المعاملة - موافقة\n/reject رقم_المعاملة سبب - رفض\n/note رقم_المعاملة ملاحظة - إضافة تعليق\n\n📢 أوامر أخرى:\n/users - قائمة المستخدمين\n/broadcast رسالة - إرسال جماعي\"\"\"\n        \n        self.send_message(message['chat']['id'], admin_text)\n    \n    def handle_broadcast(self, message):\n        \"\"\"إرسال رسالة جماعية\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        # استخراج الرسالة من النص\n        parts = message['text'].split(' ', 1)\n        if len(parts) < 2:\n            self.send_message(message['chat']['id'], \"استخدم: /broadcast رسالتك\")\n            return\n        \n        broadcast_msg = parts[1]\n        \n        # جلب جميع المستخدمين\n        users = []\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                users = list(reader)\n        except:\n            pass\n        \n        if not users:\n            self.send_message(message['chat']['id'], \"لا يوجد مستخدمين لإرسال الرسالة إليهم\")\n            return\n        \n        # إرسال الرسالة لجميع المستخدمين\n        success_count = 0\n        for user in users:\n            try:\n                result = self.send_message(user['telegram_id'], f\"📢 رسالة من الإدارة:\\n\\n{broadcast_msg}\")\n                if result and result.get('ok'):\n                    success_count += 1\n                time.sleep(0.1)  # تجنب السبام\n            except:\n                pass\n        \n        self.send_message(message['chat']['id'], f\"✅ تم إرسال الرسالة إلى {success_count} من {len(users)} مستخدم\")\n    \n    def handle_users_list(self, message):\n        \"\"\"عرض قائمة المستخدمين\"\"\"\n        if not self.is_admin(message['from']['id']):\n            return\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                users = list(reader)\n        except:\n            users = []\n        \n        if not users:\n            self.send_message(message['chat']['id'], \"لا يوجد مستخدمين مسجلين\")\n            return\n        \n        users_text = \"👥 قائمة المستخدمين:\\n\\n\"\n        for user in users[-10:]:  # آخر 10 مستخدمين\n            users_text += f\"• {user['name']} ({user['customer_id']})\\n  📱 {user['phone']}\\n  📅 {user['date']}\\n\\n\"\n        \n        self.send_message(message['chat']['id'], users_text)\n    \n    def handle_text(self, message):\n        \"\"\"التعامل مع الرسائل النصية\"\"\"\n        text = message['text']\n        chat_id = message['chat']['id']\n        \n        # أوامر خاصة\n        if text == '/admin':\n            self.handle_admin_commands(message)\n            return\n        elif text.startswith('/broadcast '):\n            self.handle_broadcast(message)\n            return\n        elif text == '/users':\n            self.handle_users_list(message)\n            return\n        elif text == '/myid':\n            # عرض ID المستخدم\n            self.send_message(chat_id, f\"🆔 Telegram ID الخاص بك:\\n`{message['from']['id']}`\\n\\nانسخ هذا الرقم وأرسله للمطور لإضافتك كأدمن\")\n            return\n        \n        user = self.find_user(message['from']['id'])\n        \n        if not user:\n            self.handle_start(message)\n            return\n        \n        lang = user.get('language', 'ar')\n        \n        # تغيير اللغة\n        if text == '🇺🇸 English':\n            # تحديث اللغة في الملف\n            self.update_user_language(user['telegram_id'], 'en')\n            self.send_message(chat_id, \"✅ Language changed to English\", self.main_keyboard('en'))\n            return\n        elif text == '🇸🇦 العربية':\n            self.update_user_language(user['telegram_id'], 'ar')\n            self.send_message(chat_id, \"✅ تم تغيير اللغة إلى العربية\", self.main_keyboard('ar'))\n            return\n        \n        # معالجة الطلبات\n        if text in ['💰 إيداع', '💰 Deposit']:\n            trans_id = self.save_transaction(user['customer_id'], 'deposit', '0')\n            response = f\"💰 طلب إيداع جديد\\n🆔 رقم المعاملة: {trans_id}\\n\\nيرجى إرسال المبلغ وصورة الإيصال\" if lang == 'ar' else f\"💰 New deposit request\\n🆔 Transaction: {trans_id}\\n\\nPlease send amount and receipt image\"\n            self.send_message(chat_id, response)\n            \n        elif text in ['💸 سحب', '💸 Withdraw']:\n            trans_id = self.save_transaction(user['customer_id'], 'withdraw', '0')\n            response = f\"💸 طلب سحب جديد\\n🆔 رقم المعاملة: {trans_id}\\n\\nيرجى إرسال المبلغ وبيانات الحساب\" if lang == 'ar' else f\"💸 New withdrawal request\\n🆔 Transaction: {trans_id}\\n\\nPlease send amount and account details\"\n            self.send_message(chat_id, response)\n            \n        elif text in ['📋 طلباتي', '📋 My Requests']:\n            # عرض آخر 5 طلبات\n            transactions = self.get_user_transactions(user['customer_id'])\n            if transactions:\n                response = \"📋 آخر طلباتك:\\n\\n\" if lang == 'ar' else \"📋 Your recent requests:\\n\\n\"\n                for trans in transactions[-5:]:\n                    response += f\"• {trans['id']} - {trans['type']} - {trans['status']}\\n\"\n            else:\n                response = \"لا توجد طلبات سابقة\" if lang == 'ar' else \"No previous requests\"\n            self.send_message(chat_id, response)\n            \n        elif text in ['👤 حسابي', '👤 Profile']:\n            response = f\"👤 بياناتك:\\n🏷️ الاسم: {user['name']}\\n📱 الهاتف: {user['phone']}\\n🆔 رقم العميل: {user['customer_id']}\\n📅 تاريخ التسجيل: {user['date']}\" if lang == 'ar' else f\"👤 Your Profile:\\n🏷️ Name: {user['name']}\\n📱 Phone: {user['phone']}\\n🆔 Customer ID: {user['customer_id']}\\n📅 Registration: {user['date']}\"\n            self.send_message(chat_id, response)\n            \n        elif text in ['📨 شكوى', '📨 Complaint']:\n            comp_id = self.save_complaint(user['customer_id'], 'عام', 'في انتظار التفاصيل')\n            response = f\"📨 شكوى جديدة\\n🆔 رقم الشكوى: {comp_id}\\n\\nيرجى إرسال تفاصيل الشكوى\" if lang == 'ar' else f\"📨 New complaint\\n🆔 Complaint ID: {comp_id}\\n\\nPlease send complaint details\"\n            self.send_message(chat_id, response)\n            \n        else:\n            response = \"اختر من القائمة أدناه:\" if lang == 'ar' else \"Please select from the menu below:\"\n            self.send_message(chat_id, response, self.main_keyboard(lang))\n    \n    def update_user_language(self, telegram_id, new_lang):\n        \"\"\"تحديث لغة المستخدم\"\"\"\n        try:\n            # قراءة جميع المستخدمين\n            users = []\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['telegram_id'] == str(telegram_id):\n                        row['language'] = new_lang\n                    users.append(row)\n            \n            # إعادة كتابة الملف\n            with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                fieldnames = ['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date']\n                writer = csv.DictWriter(f, fieldnames=fieldnames)\n                writer.writeheader()\n                writer.writerows(users)\n        except Exception as e:\n            logger.error(f\"خطأ في تحديث اللغة: {e}\")\n    \n    def get_user_transactions(self, customer_id):\n        \"\"\"جلب معاملات المستخدم\"\"\"\n        transactions = []\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        transactions.append(row)\n        except:\n            pass\n        return transactions\n    \n    def run(self):\n        \"\"\"تشغيل البوت\"\"\"\n        # اختبار التوكن\n        test_result = self.api_call('getMe')\n        if not test_result or not test_result.get('ok'):\n            logger.error(\"❌ خطأ في التوكن!\")\n            print(\"تأكد من صحة BOT_TOKEN\")\n            return\n        \n        bot_info = test_result['result']\n        logger.info(f\"✅ البوت يعمل: @{bot_info['username']}\")\n        logger.info(\"📁 البيانات محفوظة في: users.csv, transactions.csv, complaints.csv\")\n        \n        while True:\n            try:\n                updates = self.get_updates()\n                \n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        self.offset = update['update_id']\n                        \n                        if 'message' in update:\n                            message = update['message']\n                            \n                            if 'text' in message:\n                                if message['text'] == '/start':\n                                    self.handle_start(message)\n                                else:\n                                    self.handle_text(message)\n                            elif 'contact' in message:\n                                self.handle_contact(message)\n                \n                time.sleep(1)\n                \n            except KeyboardInterrupt:\n                logger.info(\"تم إيقاف البوت\")\n                break\n            except Exception as e:\n                logger.error(f\"خطأ: {e}\")\n                time.sleep(3)\n\nif __name__ == '__main__':\n    # قراءة التوكن\n    bot_token = os.getenv('BOT_TOKEN')\n    \n    if not bot_token:\n        print(\"❌ يرجى تعيين BOT_TOKEN في متغيرات البيئة\")\n        exit(1)\n    \n    print(\"🚀 بدء تشغيل LangSense Bot...\")\n    bot = LangSenseBot(bot_token)\n    bot.run()","size_bytes":22868},"main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMain entry point for the LangSense Telegram Bot\nHandles database initialization and starts the bot\n\"\"\"\n\nimport asyncio\nimport logging\nimport sys\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\nfrom config import DATABASE_URL\nfrom models import Base\nimport bot\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('bot.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(__name__)\n\nasync def init_database():\n    \"\"\"Initialize database and create tables\"\"\"\n    try:\n        # Convert PostgreSQL URL to asyncpg if needed\n        db_url = DATABASE_URL\n        if db_url.startswith(\"postgresql://\"):\n            db_url = db_url.replace(\"postgresql://\", \"postgresql+asyncpg://\")\n        \n        # Create async engine\n        if \"sqlite\" in db_url:\n            # SQLite specific configuration\n            engine = create_async_engine(\n                db_url,\n                poolclass=StaticPool,\n                connect_args={\"check_same_thread\": False},\n                echo=False\n            )\n        else:\n            # PostgreSQL configuration\n            engine = create_async_engine(db_url, echo=False)\n        \n        # Create tables\n        async with engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n        \n        logger.info(\"Database initialized successfully\")\n        return engine\n        \n    except Exception as e:\n        logger.error(f\"Database initialization failed: {e}\")\n        raise\n\nasync def main():\n    \"\"\"Main application entry point\"\"\"\n    try:\n        logger.info(\"Starting LangSense Bot...\")\n        \n        # Initialize database\n        engine = await init_database()\n        \n        # Create session maker\n        async_session = async_sessionmaker(engine, expire_on_commit=False)\n        \n        # Start the bot\n        await bot.main(async_session)\n        \n    except KeyboardInterrupt:\n        logger.info(\"Bot stopped by user\")\n    except Exception as e:\n        logger.error(f\"Fatal error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":2328},"models.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSQLAlchemy models for the LangSense Bot\nDefines database schema for users, languages, countries, announcements, and messaging\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom enum import Enum as PyEnum\nfrom typing import Optional\n\nfrom sqlalchemy import (\n    Boolean, Column, DateTime, Enum, ForeignKey, Integer, String, Text, \n    UniqueConstraint, Index, BigInteger\n)\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship, Mapped, mapped_column\n\nBase = declarative_base(cls=AsyncAttrs)\n\nclass OutboxType(PyEnum):\n    \"\"\"Types of outbox messages\"\"\"\n    DEPOSIT = \"deposit\"\n    WITHDRAWAL = \"withdrawal\" \n    COMPLAINT = \"complaint\"\n    SUPPORT = \"support\"\n    BROADCAST = \"broadcast\"\n    ANNOUNCEMENT = \"announcement\"\n\nclass OutboxStatus(PyEnum):\n    \"\"\"Status of outbox messages\"\"\"\n    PENDING = \"pending\"\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\nclass DeliveryStatus(PyEnum):\n    \"\"\"Status of message delivery\"\"\"\n    PENDING = \"pending\"\n    SENT = \"sent\"\n    DELIVERED = \"delivered\"\n    FAILED = \"failed\"\n    BLOCKED = \"blocked\"\n\nclass User(Base):\n    \"\"\"User model for storing Telegram user information\"\"\"\n    __tablename__ = 'users'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True, nullable=False, index=True)\n    username: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    first_name: Mapped[str] = mapped_column(String(255), nullable=False)\n    last_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    phone_number: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)\n    customer_code: Mapped[Optional[str]] = mapped_column(String(50), unique=True, nullable=True, index=True)\n    \n    # Preferences\n    language_code: Mapped[str] = mapped_column(String(5), nullable=False, default='ar')\n    country_code: Mapped[str] = mapped_column(String(5), nullable=False, default='SA')\n    notifications_enabled: Mapped[bool] = mapped_column(Boolean, default=True)\n    \n    # Status\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    is_banned: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_admin: Mapped[bool] = mapped_column(Boolean, default=False)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    last_activity: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    outbox_messages = relationship(\"Outbox\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    announcement_deliveries = relationship(\"AnnouncementDelivery\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __repr__(self):\n        return f\"<User(id={self.id}, telegram_id={self.telegram_id}, username={self.username})>\"\n\nclass Language(Base):\n    \"\"\"Language model for multi-language support\"\"\"\n    __tablename__ = 'languages'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    code: Mapped[str] = mapped_column(String(5), unique=True, nullable=False, index=True)\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    native_name: Mapped[str] = mapped_column(String(100), nullable=False)\n    rtl: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    \n    def __repr__(self):\n        return f\"<Language(code={self.code}, name={self.name})>\"\n\nclass Country(Base):\n    \"\"\"Country model for regional settings\"\"\"\n    __tablename__ = 'countries'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    code: Mapped[str] = mapped_column(String(5), unique=True, nullable=False, index=True)\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    native_name: Mapped[str] = mapped_column(String(100), nullable=False)\n    phone_prefix: Mapped[str] = mapped_column(String(10), nullable=False)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    \n    def __repr__(self):\n        return f\"<Country(code={self.code}, name={self.name})>\"\n\nclass Announcement(Base):\n    \"\"\"Announcement model for system announcements\"\"\"\n    __tablename__ = 'announcements'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    title_ar: Mapped[str] = mapped_column(String(255), nullable=False)\n    title_en: Mapped[str] = mapped_column(String(255), nullable=False)\n    content_ar: Mapped[str] = mapped_column(Text, nullable=False)\n    content_en: Mapped[str] = mapped_column(Text, nullable=False)\n    image_url: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)\n    \n    # Display settings\n    display_duration: Mapped[int] = mapped_column(Integer, default=0)  # 0 = permanent\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    priority: Mapped[int] = mapped_column(Integer, default=0)\n    \n    # Filtering\n    target_language: Mapped[Optional[str]] = mapped_column(String(5), nullable=True)\n    target_country: Mapped[Optional[str]] = mapped_column(String(5), nullable=True)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    scheduled_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    deliveries = relationship(\"AnnouncementDelivery\", back_populates=\"announcement\", cascade=\"all, delete-orphan\")\n    \n    def __repr__(self):\n        return f\"<Announcement(id={self.id}, title_ar={self.title_ar[:50]})>\"\n\nclass AnnouncementDelivery(Base):\n    \"\"\"Track announcement delivery to users\"\"\"\n    __tablename__ = 'announcement_deliveries'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    announcement_id: Mapped[int] = mapped_column(Integer, ForeignKey('announcements.id'), nullable=False)\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id'), nullable=False)\n    \n    status: Mapped[DeliveryStatus] = mapped_column(Enum(DeliveryStatus), default=DeliveryStatus.PENDING)\n    delivered_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    read_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    \n    # Relationships\n    announcement = relationship(\"Announcement\", back_populates=\"deliveries\")\n    user = relationship(\"User\", back_populates=\"announcement_deliveries\")\n    \n    # Unique constraint\n    __table_args__ = (UniqueConstraint('announcement_id', 'user_id', name='uq_announcement_user'),)\n    \n    def __repr__(self):\n        return f\"<AnnouncementDelivery(announcement_id={self.announcement_id}, user_id={self.user_id}, status={self.status})>\"\n\nclass Outbox(Base):\n    \"\"\"Outbox for user requests and system messages\"\"\"\n    __tablename__ = 'outbox'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id'), nullable=False)\n    type: Mapped[OutboxType] = mapped_column(Enum(OutboxType), nullable=False)\n    status: Mapped[OutboxStatus] = mapped_column(Enum(OutboxStatus), default=OutboxStatus.PENDING)\n    \n    # Content\n    subject: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    content: Mapped[str] = mapped_column(Text, nullable=False)\n    attachment_url: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)\n    \n    # Processing\n    processed_by: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)  # Admin telegram_id\n    processed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    admin_comment: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    \n    # Relationships\n    user = relationship(\"User\", back_populates=\"outbox_messages\")\n    recipients = relationship(\"OutboxRecipient\", back_populates=\"outbox\", cascade=\"all, delete-orphan\")\n    \n    # Indexes\n    __table_args__ = (\n        Index('idx_outbox_type_status', 'type', 'status'),\n        Index('idx_outbox_created', 'created_at'),\n    )\n    \n    def __repr__(self):\n        return f\"<Outbox(id={self.id}, type={self.type}, status={self.status})>\"\n\nclass OutboxRecipient(Base):\n    \"\"\"Track individual message recipients for broadcasts\"\"\"\n    __tablename__ = 'outbox_recipients'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    outbox_id: Mapped[int] = mapped_column(Integer, ForeignKey('outbox.id'), nullable=False)\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id'), nullable=False)\n    \n    status: Mapped[DeliveryStatus] = mapped_column(Enum(DeliveryStatus), default=DeliveryStatus.PENDING)\n    attempts: Mapped[int] = mapped_column(Integer, default=0)\n    last_attempt: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    delivered_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    \n    # Relationships\n    outbox = relationship(\"Outbox\", back_populates=\"recipients\")\n    \n    # Unique constraint\n    __table_args__ = (UniqueConstraint('outbox_id', 'user_id', name='uq_outbox_user'),)\n    \n    def __repr__(self):\n        return f\"<OutboxRecipient(outbox_id={self.outbox_id}, user_id={self.user_id}, status={self.status})>\"\n","size_bytes":11331},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = []\n","size_bytes":143},"replit.md":{"content":"# replit.md\n\n## Overview\n\nLangSense is a streamlined Telegram bot for financial services with Arabic support. The bot provides a simplified financial ecosystem focusing on deposit/withdrawal processing with company selection, wallet number input, and exchange address management. Features include user registration, admin approval system, and comprehensive transaction tracking.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\nUI Design: Button-based navigation preferred over text commands.\nNotifications: Only at completion of operations, not during process.\nAdmin Commands: Simplified format without complex syntax requirements.\n\n## System Architecture\n\n### Core Framework\n- **Bot Framework**: Simplified HTTP-based Telegram Bot API implementation using Python standard library\n- **Language**: Python 3 with urllib and json for lightweight operation\n- **State Management**: Simple dictionary-based state management for user sessions\n- **Implementation**: Streamlined single-file solution without external dependencies\n- **Backup System**: Automated data backup every 6 hours with ZIP compression and admin delivery\n\n### Database Layer\n- **Database**: CSV files for simplicity and transparency\n- **Files**: users.csv, transactions.csv, companies.csv, exchange_addresses.csv\n- **Schema**: Simplified tables focusing on essential data only\n- **Data Integrity**: Automatic customer code generation, basic validation\n\n### User Interface\n- **Navigation**: Button-based keyboards for all interactions\n- **Language**: Arabic primary with simple interface\n- **Flow**: Linear process flows for deposits and withdrawals\n- **Withdrawal Confirmation**: Button-based final confirmation with \"✅ تأكيد الطلب\", \"❌ إلغاء\", and \"🏠 القائمة الرئيسية\"\n- **Advanced Reset System**: \"🔄 إعادة تعيين النظام\" and \"🆘 إصلاح شامل\" buttons for comprehensive error resolution\n- **Super Reset Function**: Complete system cleanup including user states, temporary data, and file integrity verification\n- **Error Recovery**: Enhanced error messages with multiple reset options and alternative action buttons\n- **System Diagnostics**: Automatic verification and repair of core system files\n- **Simplicity**: No complex commands or syntax requirements\n\n### Authentication & Authorization\n- **Admin System**: Environment variable-based admin user ID configuration\n- **User Registration**: Name and phone number only\n- **Session Management**: Simple state tracking for multi-step processes\n\n### Financial Services Workflow\n- **Enhanced Deposit Process**: Company Selection → **Payment Method Selection** → Wallet Number → Amount → Completion\n- **Enhanced Withdrawal Process**: Company Selection → **Payment Method Selection** → Wallet Number → Amount → **Withdrawal Address Entry** → **Confirmation Code Entry** → Final Confirmation\n- **Payment Method Integration**: Users select specific payment methods for each company (bank accounts, e-wallets, etc.)\n- **Status Tracking**: Simple pending/approved/rejected states\n- **Admin Approval**: Direct text-based commands (موافقة/رفض)\n- **Withdrawal Address**: Users must specify withdrawal address for each request\n- **Confirmation Code**: Required verification code from customer before processing\n\n### Company & Payment Method Management\n- **Enhanced Company Management**: Interactive step-by-step wizards for adding, editing, and deleting companies\n- **Comprehensive Payment Method System**: \n  - Multiple payment methods per company (bank accounts, e-wallets, investment accounts)\n  - Customizable payment data fields for each method\n  - Admin CRUD operations (add, edit, delete) for payment methods\n  - User selection of payment methods during transactions\n- **User-Friendly Interface**: Button-based navigation with confirmation dialogs and real-time preview\n- **Advanced Features**: \n  - Add Company Wizard: Name → Service Type (buttons) → Details → Confirmation with edit options\n  - Payment Method Management: Add/Edit/Delete methods with custom data fields\n  - Edit Company Wizard: Select company → Edit any field → Live preview → Safe save\n  - Delete Company: Safety confirmation with company details display\n  - Management Dashboard: Enhanced view with company count, status indicators, and quick actions\n- **Exchange Address**: Single active address that can be updated easily\n- **Flexibility**: Dynamic company list for both deposits and withdrawals with method selection\n\n### Notifications\n- **Timing**: Only at completion of operations (approval/rejection) + instant notifications for new requests\n- **Content**: Essential information only\n- **Direction**: Bidirectional (admin ↔ user) at completion + instant admin alerts for new transactions\n- **Admin Alerts**: Immediate notifications when users submit deposit/withdrawal requests\n- **Customer Alerts**: Instant notifications upon approval/rejection with full transaction details\n- **Broadcast Messages**: Sent without keyboard markup to prevent interference with existing user interfaces\n- **Direct Admin Messages**: Individual customer messages sent without keyboard to preserve current user state\n\n### Admin Interface\n- **Commands**: Simplified text-based commands with enhanced copy functionality\n- **Format**: Natural language without complex syntax\n- **Enhanced Copy System**: \n  - Quick copy commands for each transaction (approve/reject)\n  - Quick copy responses for complaints with templates\n  - Comprehensive quick copy commands section with all admin operations\n  - Pre-formatted commands for easy copying and modification\n- **Direct User Messaging**: Send targeted messages to specific customers using their customer ID\n- **Enhanced Payment Method Management**: Full CRUD operations with interactive selection interfaces\n- **Easy Copy Payment Data**: Customer-friendly display of payment account information with copy functionality\n- **Payment Method Commands**: \n  - `اضافة_وسيلة_دفع ID_الشركة اسم_الوسيلة نوع_الوسيلة البيانات`\n  - `حذف_وسيلة_دفع ID_الوسيلة`\n  - `تعديل_وسيلة_دفع ID_الوسيلة البيانات_الجديدة`\n- **Examples**: \"موافقة DEP123\", \"رفض WTH456 سبب\", \"اضف_شركة اسم نوع تفاصيل\"\n- **Navigation**: Button-based admin panel with payment method management\n\n### Error Handling & Logging\n- **Logging**: Basic console logging for monitoring\n- **Validation**: Simple input validation with clear error messages\n- **Fallbacks**: Graceful handling of invalid inputs\n- **Data Protection**: Automated backup system every 6 hours with encrypted ZIP files sent to admin accounts\n- **Manual Backup**: Admin command for instant backup generation and delivery\n- **Backup Contents**: All CSV files, system settings, and comprehensive statistical reports\n\n## External Dependencies\n\n### Core Dependencies\n- **Aiogram v3**: Modern Telegram Bot API framework with async support\n- **SQLAlchemy**: Async ORM for database operations and relationship management\n- **APScheduler**: Task scheduling for announcements and periodic operations\n- **Pillow**: Image processing for media validation and manipulation\n\n### Database Options\n- **SQLite**: Default development database with aiosqlite driver\n- **PostgreSQL**: Production database with asyncpg driver for scalability\n\n### Runtime Dependencies\n- **Python-dotenv**: Environment variable management and configuration loading\n- **AsyncIO**: Core async runtime for handling concurrent operations\n\n### Optional Integrations\n- **File Storage**: Local file system for media uploads (configurable for cloud storage)\n- **External APIs**: Extensible architecture for payment provider integrations\n- **Monitoring Services**: Ready for integration with external logging and monitoring platforms","size_bytes":7879},"run_linux.sh":{"content":"#!/bin/bash\n\necho \"========================================\"\necho \"LangSense Telegram Bot - Linux Setup\"\necho \"========================================\"\necho\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\n# Function to print colored output\nprint_success() {\n    echo -e \"${GREEN}$1 ✓${NC}\"\n}\n\nprint_error() {\n    echo -e \"${RED}ERROR: $1${NC}\"\n}\n\nprint_warning() {\n    echo -e \"${YELLOW}WARNING: $1${NC}\"\n}\n\n# Check if Python is installed\nif ! command -v python3 &> /dev/null; then\n    print_error \"Python 3 is not installed\"\n    echo \"Please install Python 3.8+ using your package manager:\"\n    echo \"  Ubuntu/Debian: sudo apt install python3 python3-pip python3-venv\"\n    echo \"  CentOS/RHEL: sudo yum install python3 python3-pip\"\n    echo \"  Fedora: sudo dnf install python3 python3-pip\"\n    exit 1\nfi\n\nprint_success \"Python 3 is installed\"\n\n# Check Python version\nPYTHON_VERSION=$(python3 -c 'import sys; print(\".\".join(map(str, sys.version_info[:2])))')\nREQUIRED_VERSION=\"3.8\"\n\nif ! python3 -c \"import sys; exit(0 if sys.version_info >= (3, 8) else 1)\"; then\n    print_error \"Python 3.8 or higher is required. You have Python $PYTHON_VERSION\"\n    exit 1\nfi\n\nprint_success \"Python version $PYTHON_VERSION is compatible\"\necho\n\n# Create virtual environment if it doesn't exist\nif [ ! -d \"venv\" ]; then\n    echo \"Creating virtual environment...\"\n    python3 -m venv venv\n    if [ $? -ne 0 ]; then\n        print_error \"Failed to create virtual environment\"\n        exit 1\n    fi\n    print_success \"Virtual environment created\"\nelse\n    print_success \"Virtual environment already exists\"\nfi\n\necho\n\n# Activate virtual environment\necho \"Activating virtual environment...\"\nsource venv/bin/activate\nif [ $? -ne 0 ]; then\n    print_error \"Failed to activate virtual environment\"\n    exit 1\nfi\n\nprint_success \"Virtual environment activated\"\necho\n\n# Upgrade pip\necho \"Upgrading pip...\"\npython -m pip install --upgrade pip\nprint_success \"Pip upgraded\"\necho\n\n# Install required packages\necho \"Installing required packages...\"\npip install aiogram sqlalchemy aiosqlite asyncpg python-dotenv aiohttp pydantic psutil requests aiofiles pillow cryptography apscheduler babel\nif [ $? -ne 0 ]; then\n    print_error \"Failed to install packages\"\n    exit 1\nfi\n\nprint_success \"Packages installed successfully\"\necho\n\n# Check if .env file exists\nif [ ! -f \".env\" ]; then\n    print_warning \".env file not found!\"\n    echo\n    echo \"Please create a .env file with the following content:\"\n    echo \"BOT_TOKEN=your_bot_token_here\"\n    echo \"ADMIN_USER_IDS=your_telegram_user_id_here\"\n    echo \"DATABASE_URL=sqlite+aiosqlite:///./langsense.db\"\n    echo\n    echo \"You can copy .env.example to .env and modify the values:\"\n    echo \"cp .env.example .env\"\n    echo\n    read -p \"Press Enter to continue...\"\nelse\n    print_success \".env file found\"\nfi\n\necho\n\n# Create directories if they don't exist\nfor dir in translations handlers services utils; do\n    if [ ! -d \"$dir\" ]; then\n        mkdir -p \"$dir\"\n        print_success \"Created $dir directory\"\n    fi\ndone\n\necho\necho \"========================================\"\nprint_success \"Setup completed successfully! 🎉\"\necho \"========================================\"\necho\n\n# Make script executable\nchmod +x \"$0\"\n\n# Start the bot\necho \"Starting LangSense Bot...\"\necho \"Press Ctrl+C to stop the bot\"\necho\n\n# Function to handle script termination\ncleanup() {\n    echo\n    echo \"Bot stopped.\"\n    deactivate\n    exit 0\n}\n\n# Set up signal handlers\ntrap cleanup SIGINT SIGTERM\n\n# Start the bot\npython main.py\n\n# Cleanup on normal exit\ncleanup\n","size_bytes":3611},"simple_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSimple Telegram Bot using basic HTTP requests\nWorks without complex dependencies\n\"\"\"\n\nimport os\nimport json\nimport time\nimport sqlite3\nimport logging\nfrom urllib.request import urlopen, Request\nfrom urllib.parse import urlencode\nfrom urllib.error import URLError, HTTPError\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass SimpleTelegramBot:\n    def __init__(self, token):\n        self.token = token\n        self.api_url = f\"https://api.telegram.org/bot{token}\"\n        self.offset = 0\n        self.init_database()\n        \n    def init_database(self):\n        \"\"\"Initialize SQLite database\"\"\"\n        self.conn = sqlite3.connect('langsense.db', check_same_thread=False)\n        cursor = self.conn.cursor()\n        \n        # Create users table\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS users (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                telegram_id INTEGER UNIQUE NOT NULL,\n                username TEXT,\n                first_name TEXT NOT NULL,\n                last_name TEXT,\n                phone_number TEXT,\n                customer_code TEXT UNIQUE,\n                language_code TEXT DEFAULT 'ar',\n                country_code TEXT DEFAULT 'SA',\n                is_active BOOLEAN DEFAULT 1,\n                is_admin BOOLEAN DEFAULT 0,\n                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n            )\n        ''')\n        \n        # Create languages table\n        cursor.execute('''\n            CREATE TABLE IF NOT EXISTS languages (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                code TEXT UNIQUE NOT NULL,\n                name TEXT NOT NULL,\n                native_name TEXT NOT NULL,\n                is_active BOOLEAN DEFAULT 1\n            )\n        ''')\n        \n        # Insert default languages\n        cursor.execute(\"INSERT OR IGNORE INTO languages (code, name, native_name) VALUES ('ar', 'Arabic', 'العربية')\")\n        cursor.execute(\"INSERT OR IGNORE INTO languages (code, name, native_name) VALUES ('en', 'English', 'English')\")\n        \n        self.conn.commit()\n        logger.info(\"Database initialized successfully\")\n        \n    def make_request(self, method, params=None):\n        \"\"\"Make HTTP request to Telegram API\"\"\"\n        url = f\"{self.api_url}/{method}\"\n        \n        if params:\n            if method == 'sendMessage' or method == 'sendPhoto':\n                # POST request for sending messages\n                data = urlencode(params).encode('utf-8')\n                request = Request(url, data=data)\n                request.add_header('Content-Type', 'application/x-www-form-urlencoded')\n            else:\n                # GET request for other methods\n                url += '?' + urlencode(params)\n                request = Request(url)\n        else:\n            request = Request(url)\n            \n        try:\n            with urlopen(request, timeout=30) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except (URLError, HTTPError, json.JSONDecodeError) as e:\n            logger.error(f\"API request failed: {e}\")\n            return None\n            \n    def send_message(self, chat_id, text, reply_markup=None):\n        \"\"\"Send message to user\"\"\"\n        params = {\n            'chat_id': chat_id,\n            'text': text,\n            'parse_mode': 'HTML'\n        }\n        \n        if reply_markup:\n            params['reply_markup'] = json.dumps(reply_markup)\n            \n        return self.make_request('sendMessage', params)\n        \n    def get_updates(self):\n        \"\"\"Get updates from Telegram\"\"\"\n        params = {\n            'offset': self.offset + 1,\n            'timeout': 10\n        }\n        return self.make_request('getUpdates', params)\n        \n    def get_main_menu_keyboard(self, lang='ar'):\n        \"\"\"Create main menu keyboard\"\"\"\n        if lang == 'ar':\n            return {\n                'keyboard': [\n                    [{'text': '💰 إيداع'}, {'text': '💸 سحب'}],\n                    [{'text': '📨 شكاوى'}, {'text': '🆘 دعم'}],\n                    [{'text': '👨‍💼 مدير'}, {'text': '📋 خطط واشتراكات'}],\n                    [{'text': '💼 المبيعات'}, {'text': '⚙️ الإعدادات'}],\n                    [{'text': '⬅️ رجوع'}, {'text': '➡️ تقدم'}, {'text': '👤 حسابي'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': False\n            }\n        else:\n            return {\n                'keyboard': [\n                    [{'text': '💰 Deposit'}, {'text': '💸 Withdraw'}],\n                    [{'text': '📨 Complaints'}, {'text': '🆘 Support'}],\n                    [{'text': '👨‍💼 Manager'}, {'text': '📋 Plans & Subscriptions'}],\n                    [{'text': '💼 Sales'}, {'text': '⚙️ Settings'}],\n                    [{'text': '⬅️ Back'}, {'text': '➡️ Forward'}, {'text': '👤 My Account'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': False\n            }\n            \n    def get_phone_request_keyboard(self, lang='ar'):\n        \"\"\"Create phone number request keyboard\"\"\"\n        text = '📱 مشاركة رقم الهاتف' if lang == 'ar' else '📱 Share Phone Number'\n        return {\n            'keyboard': [[{'text': text, 'request_contact': True}]],\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n    def get_or_create_user(self, telegram_user):\n        \"\"\"Get or create user in database\"\"\"\n        cursor = self.conn.cursor()\n        \n        # Try to get existing user\n        cursor.execute(\"SELECT * FROM users WHERE telegram_id = ?\", (telegram_user['id'],))\n        user = cursor.fetchone()\n        \n        if user:\n            # Update existing user\n            cursor.execute(\"\"\"\n                UPDATE users \n                SET username = ?, first_name = ?, last_name = ?\n                WHERE telegram_id = ?\n            \"\"\", (\n                telegram_user.get('username'),\n                telegram_user['first_name'],\n                telegram_user.get('last_name'),\n                telegram_user['id']\n            ))\n        else:\n            # Create new user\n            cursor.execute(\"\"\"\n                INSERT INTO users (telegram_id, username, first_name, last_name, language_code)\n                VALUES (?, ?, ?, ?, ?)\n            \"\"\", (\n                telegram_user['id'],\n                telegram_user.get('username'),\n                telegram_user['first_name'],\n                telegram_user.get('last_name'),\n                telegram_user.get('language_code', 'ar')\n            ))\n            \n        self.conn.commit()\n        \n        # Get updated user\n        cursor.execute(\"SELECT * FROM users WHERE telegram_id = ?\", (telegram_user['id'],))\n        return cursor.fetchone()\n        \n    def generate_customer_code(self):\n        \"\"\"Generate unique customer code\"\"\"\n        cursor = self.conn.cursor()\n        cursor.execute(\"SELECT COUNT(*) FROM users WHERE customer_code IS NOT NULL\")\n        count = cursor.fetchone()[0]\n        return f\"C-2025-{count + 1:06d}\"\n        \n    def handle_start(self, message):\n        \"\"\"Handle /start command\"\"\"\n        user = self.get_or_create_user(message['from'])\n        lang = user[7] if user else 'ar'  # language_code column\n        \n        if not user[5]:  # phone_number column\n            welcome_text = (\n                f\"مرحباً بك {user[3]}! 🎉\\n\\n\"\n                \"أهلاً وسهلاً في نظام LangSense المالي.\\n\\n\"\n                \"لإكمال التسجيل، يرجى مشاركة رقم هاتفك معنا لإنشاء حساب عميل آمن.\"\n            ) if lang == 'ar' else (\n                f\"Welcome {user[3]}! 🎉\\n\\n\"\n                \"Welcome to the LangSense Financial System.\\n\\n\"\n                \"To complete registration, please share your phone number with us to create a secure customer account.\"\n            )\n            \n            self.send_message(\n                message['chat']['id'],\n                welcome_text,\n                self.get_phone_request_keyboard(lang)\n            )\n        else:\n            welcome_text = (\n                f\"أهلاً وسهلاً بك مرة أخرى {user[3]}! 👋\\n\\n\"\n                f\"رقم العميل: {user[6]}\\n\\n\"\n                \"اختر الخدمة المطلوبة من القائمة أدناه:\"\n            ) if lang == 'ar' else (\n                f\"Welcome back {user[3]}! 👋\\n\\n\"\n                f\"Customer ID: {user[6]}\\n\\n\"\n                \"Select the required service from the menu below:\"\n            )\n            \n            self.send_message(\n                message['chat']['id'],\n                welcome_text,\n                self.get_main_menu_keyboard(lang)\n            )\n            \n    def handle_contact(self, message):\n        \"\"\"Handle contact sharing\"\"\"\n        contact = message['contact']\n        if contact['user_id'] == message['from']['id']:\n            cursor = self.conn.cursor()\n            customer_code = self.generate_customer_code()\n            \n            cursor.execute(\"\"\"\n                UPDATE users \n                SET phone_number = ?, customer_code = ?\n                WHERE telegram_id = ?\n            \"\"\", (contact['phone_number'], customer_code, message['from']['id']))\n            self.conn.commit()\n            \n            cursor.execute(\"SELECT * FROM users WHERE telegram_id = ?\", (message['from']['id'],))\n            user = cursor.fetchone()\n            lang = user[7]\n            \n            success_text = (\n                f\"✅ تم تسجيل رقم الهاتف بنجاح!\\n\\n\"\n                f\"📱 الرقم: {contact['phone_number']}\\n\"\n                f\"🆔 رقم العميل: {customer_code}\\n\\n\"\n                \"أهلاً وسهلاً بك في نظام LangSense المالي!\"\n            ) if lang == 'ar' else (\n                f\"✅ Phone number registered successfully!\\n\\n\"\n                f\"📱 Number: {contact['phone_number']}\\n\"\n                f\"🆔 Customer ID: {customer_code}\\n\\n\"\n                \"Welcome to the LangSense Financial System!\"\n            )\n            \n            self.send_message(\n                message['chat']['id'],\n                success_text,\n                self.get_main_menu_keyboard(lang)\n            )\n            \n    def handle_text_message(self, message):\n        \"\"\"Handle text messages\"\"\"\n        text = message['text']\n        chat_id = message['chat']['id']\n        \n        cursor = self.conn.cursor()\n        cursor.execute(\"SELECT * FROM users WHERE telegram_id = ?\", (message['from']['id'],))\n        user = cursor.fetchone()\n        \n        if not user:\n            return\n            \n        lang = user[7]\n        \n        # Handle menu options\n        if text in ['💰 إيداع', '💰 Deposit']:\n            response = (\n                \"💰 خدمة الإيداع\\n\\n\"\n                \"لإتمام عملية الإيداع، يرجى:\\n\"\n                \"1. تحديد المبلغ المراد إيداعه\\n\"\n                \"2. اختيار وسيلة الدفع المناسبة\\n\"\n                \"3. إرفاق صورة إيصال التحويل\\n\\n\"\n                \"سيتم مراجعة طلبك خلال 24 ساعة كحد أقصى.\"\n            ) if lang == 'ar' else (\n                \"💰 Deposit Service\\n\\n\"\n                \"To complete the deposit process, please:\\n\"\n                \"1. Specify the amount to deposit\\n\"\n                \"2. Choose the appropriate payment method\\n\"\n                \"3. Attach a transfer receipt image\\n\\n\"\n                \"Your request will be reviewed within 24 hours maximum.\"\n            )\n            \n        elif text in ['💸 سحب', '💸 Withdraw']:\n            response = (\n                \"💸 خدمة السحب\\n\\n\"\n                \"لإتمام عملية السحب، يرجى:\\n\"\n                \"1. تحديد المبلغ المراد سحبه\\n\"\n                \"2. تقديم بيانات الحساب المصرفي\\n\"\n                \"3. تأكيد الهوية حسب المطلوب\\n\\n\"\n                \"سيتم معالجة طلبك خلال 48 ساعة كحد أقصى.\"\n            ) if lang == 'ar' else (\n                \"💸 Withdrawal Service\\n\\n\"\n                \"To complete the withdrawal process, please:\\n\"\n                \"1. Specify the amount to withdraw\\n\"\n                \"2. Provide bank account details\\n\"\n                \"3. Confirm identity as required\\n\\n\"\n                \"Your request will be processed within 48 hours maximum.\"\n            )\n            \n        elif text in ['👤 حسابي', '👤 My Account']:\n            response = (\n                f\"👤 معلومات حسابي\\n\\n\"\n                f\"🏷️ الاسم: {user[3]} {user[4] or ''}\\n\"\n                f\"👤 اسم المستخدم: @{user[2] or 'غير محدد'}\\n\"\n                f\"📱 رقم الهاتف: {user[5] or 'غير محدد'}\\n\"\n                f\"🆔 رقم العميل: {user[6] or 'غير محدد'}\\n\"\n                f\"🌐 اللغة: {user[7].upper()}\\n\"\n                f\"🌍 الدولة: {user[8].upper()}\"\n            ) if lang == 'ar' else (\n                f\"👤 My Account Information\\n\\n\"\n                f\"🏷️ Name: {user[3]} {user[4] or ''}\\n\"\n                f\"👤 Username: @{user[2] or 'Not Set'}\\n\"\n                f\"📱 Phone: {user[5] or 'Not Set'}\\n\"\n                f\"🆔 Customer ID: {user[6] or 'Not Set'}\\n\"\n                f\"🌐 Language: {user[7].upper()}\\n\"\n                f\"🌍 Country: {user[8].upper()}\"\n            )\n            \n        else:\n            response = (\n                \"❓ عذراً، لم أفهم طلبك. يرجى استخدام القائمة أدناه لاختيار الخدمة المطلوبة.\"\n            ) if lang == 'ar' else (\n                \"❓ Sorry, I didn't understand your request. Please use the menu below to select the required service.\"\n            )\n            \n        self.send_message(chat_id, response)\n        \n    def handle_admin_command(self, message):\n        \"\"\"Handle admin commands\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        if str(message['from']['id']) not in admin_ids:\n            self.send_message(\n                message['chat']['id'],\n                \"🚫 غير مسموح! هذه الخدمة مخصصة للمشرفين فقط.\"\n            )\n            return\n            \n        cursor = self.conn.cursor()\n        cursor.execute(\"SELECT COUNT(*) FROM users\")\n        total_users = cursor.fetchone()[0]\n        \n        cursor.execute(\"SELECT COUNT(*) FROM users WHERE is_active = 1\")\n        active_users = cursor.fetchone()[0]\n        \n        admin_text = (\n            f\"🛠️ لوحة إدارة النظام\\n\\n\"\n            f\"📊 إحصائيات سريعة:\\n\"\n            f\"👥 إجمالي المستخدمين: {total_users}\\n\"\n            f\"✅ المستخدمون النشطون: {active_users}\\n\\n\"\n            f\"استخدم /users لعرض المستخدمين\"\n        )\n        \n        self.send_message(message['chat']['id'], admin_text)\n        \n    def run(self):\n        \"\"\"Main bot loop\"\"\"\n        logger.info(\"Starting LangSense Bot...\")\n        \n        # Test bot token\n        result = self.make_request('getMe')\n        if not result or not result.get('ok'):\n            logger.error(\"Invalid bot token!\")\n            return\n            \n        logger.info(f\"Bot started: @{result['result']['username']}\")\n        \n        while True:\n            try:\n                updates = self.get_updates()\n                \n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        self.offset = update['update_id']\n                        \n                        if 'message' in update:\n                            message = update['message']\n                            \n                            if 'text' in message:\n                                if message['text'] == '/start':\n                                    self.handle_start(message)\n                                elif message['text'] == '/admin':\n                                    self.handle_admin_command(message)\n                                else:\n                                    self.handle_text_message(message)\n                            elif 'contact' in message:\n                                self.handle_contact(message)\n                                \n                time.sleep(1)\n                \n            except KeyboardInterrupt:\n                logger.info(\"Bot stopped by user\")\n                break\n            except Exception as e:\n                logger.error(f\"Error in bot loop: {e}\")\n                time.sleep(5)\n\ndef main():\n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        logger.error(\"BOT_TOKEN environment variable not set!\")\n        return\n        \n    bot = SimpleTelegramBot(bot_token)\n    bot.run()\n\nif __name__ == '__main__':\n    main()","size_bytes":17326},"simple_improved_bot.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport os\nimport json\nimport csv\nimport urllib.request\nimport urllib.parse\nimport logging\nfrom datetime import datetime\n\n# إعداد التسجيل\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass SimpleLangSenseBot:\n    def __init__(self, token):\n        self.token = token\n        self.api_url = f\"https://api.telegram.org/bot{token}\"\n        self.offset = 0\n        self.user_states = {}\n        self.init_files()\n        self.admin_ids = self.get_admin_ids()\n        \n    def init_files(self):\n        \"\"\"إنشاء ملفات النظام\"\"\"\n        # ملف المستخدمين\n        if not os.path.exists('users.csv'):\n            with open('users.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['telegram_id', 'name', 'phone', 'customer_id', 'language', 'date', 'is_banned'])\n        \n        # ملف المعاملات\n        if not os.path.exists('transactions.csv'):\n            with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'customer_id', 'name', 'type', 'company', 'wallet_number', 'amount', 'exchange_address', 'status', 'date', 'admin_note'])\n        \n        # ملف الشركات\n        if not os.path.exists('companies.csv'):\n            with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'name', 'type', 'details'])\n                # شركات افتراضية\n                companies = [\n                    ['1', 'STC Pay', 'both', 'محفظة إلكترونية'],\n                    ['2', 'البنك الأهلي', 'both', 'حساب بنكي'],\n                    ['3', 'فودافون كاش', 'both', 'محفظة إلكترونية'],\n                    ['4', 'بنك الراجحي', 'both', 'حساب بنكي']\n                ]\n                for company in companies:\n                    writer.writerow(company)\n        \n        # ملف عناوين الصرافة\n        if not os.path.exists('exchange_addresses.csv'):\n            with open('exchange_addresses.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'address', 'is_active'])\n                writer.writerow(['1', 'شارع الملك فهد، الرياض، مقابل مول الرياض', 'yes'])\n        \n        logger.info(\"تم إنشاء جميع ملفات النظام\")\n        \n    def api_call(self, method, data=None):\n        \"\"\"استدعاء API\"\"\"\n        url = f\"{self.api_url}/{method}\"\n        try:\n            if data:\n                json_data = json.dumps(data).encode('utf-8')\n                req = urllib.request.Request(url, data=json_data)\n                req.add_header('Content-Type', 'application/json')\n            else:\n                req = urllib.request.Request(url)\n            \n            with urllib.request.urlopen(req, timeout=10) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في API: {e}\")\n            return None\n    \n    def send_message(self, chat_id, text, keyboard=None):\n        \"\"\"إرسال رسالة\"\"\"\n        data = {'chat_id': chat_id, 'text': text, 'parse_mode': 'HTML'}\n        if keyboard:\n            data['reply_markup'] = keyboard\n        return self.api_call('sendMessage', data)\n    \n    def get_updates(self):\n        \"\"\"جلب التحديثات\"\"\"\n        url = f\"{self.api_url}/getUpdates?offset={self.offset + 1}&timeout=10\"\n        try:\n            with urllib.request.urlopen(url, timeout=15) as response:\n                return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في جلب التحديثات: {e}\")\n            return None\n    \n    def get_admin_ids(self):\n        \"\"\"جلب معرفات الأدمن\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        return [admin_id.strip() for admin_id in admin_ids if admin_id.strip()]\n    \n    def is_admin(self, telegram_id):\n        \"\"\"فحص صلاحية الأدمن\"\"\"\n        return str(telegram_id) in self.admin_ids\n    \n    def notify_admins(self, message):\n        \"\"\"إشعار جميع الأدمن\"\"\"\n        for admin_id in self.admin_ids:\n            self.send_message(admin_id, message, self.admin_keyboard())\n    \n    def find_user(self, telegram_id):\n        \"\"\"البحث عن مستخدم\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['telegram_id'] == str(telegram_id):\n                        return row\n        except:\n            pass\n        return None\n    \n    def get_companies(self, service_type=None):\n        \"\"\"جلب الشركات\"\"\"\n        companies = []\n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if service_type is None or row['type'] in [service_type, 'both']:\n                        companies.append(row)\n        except:\n            pass\n        return companies\n    \n    def get_exchange_address(self):\n        \"\"\"جلب عنوان الصرافة النشط\"\"\"\n        try:\n            with open('exchange_addresses.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['is_active'] == 'yes':\n                        return row['address']\n        except:\n            pass\n        return \"العنوان غير متوفر\"\n    \n    def main_keyboard(self, lang='ar'):\n        \"\"\"القائمة الرئيسية\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '💰 إيداع'}, {'text': '💸 سحب'}],\n                [{'text': '📋 طلباتي'}, {'text': '🆘 دعم'}]\n            ],\n            'resize_keyboard': True\n        }\n    \n    def admin_keyboard(self):\n        \"\"\"لوحة الأدمن\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '📋 طلبات معلقة'}, {'text': '✅ موافقة طلب'}],\n                [{'text': '❌ رفض طلب'}, {'text': '👥 المستخدمين'}],\n                [{'text': '🏢 إدارة الشركات'}, {'text': '📍 تعديل العنوان'}],\n                [{'text': '📊 إحصائيات'}, {'text': '🏠 القائمة الرئيسية'}]\n            ],\n            'resize_keyboard': True\n        }\n    \n    def companies_keyboard(self, service_type):\n        \"\"\"لوحة اختيار الشركات\"\"\"\n        companies = self.get_companies(service_type)\n        keyboard = []\n        for company in companies:\n            keyboard.append([{'text': company['name']}])\n        keyboard.append([{'text': '🔙 رجوع'}])\n        return {'keyboard': keyboard, 'resize_keyboard': True}\n    \n    def handle_start(self, message):\n        \"\"\"معالج بداية المحادثة\"\"\"\n        chat_id = message['chat']['id']\n        user_id = message['from']['id']\n        \n        # فحص إذا كان المستخدم موجود\n        user = self.find_user(user_id)\n        if user:\n            welcome_text = f\"مرحباً بعودتك {user['name']}! 👋\"\n            self.send_message(chat_id, welcome_text, self.main_keyboard())\n        else:\n            welcome_text = \"\"\"مرحباً بك في نظام الخدمات المالية! 👋\n\nيرجى إرسال اسمك الكامل للتسجيل:\"\"\"\n            self.send_message(chat_id, welcome_text)\n            self.user_states[user_id] = 'registering_name'\n    \n    def handle_registration(self, message):\n        \"\"\"معالجة التسجيل\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id)\n        \n        if state == 'registering_name':\n            name = message['text'].strip()\n            if len(name) < 2:\n                self.send_message(message['chat']['id'], \"اسم قصير جداً. يرجى إدخال اسم صحيح:\")\n                return\n            \n            self.user_states[user_id] = f'registering_phone_{name}'\n            self.send_message(message['chat']['id'], \"ممتاز! الآن أرسل رقم هاتفك:\")\n            \n        elif state.startswith('registering_phone_'):\n            name = state.replace('registering_phone_', '')\n            phone = message['text'].strip()\n            \n            if len(phone) < 10:\n                self.send_message(message['chat']['id'], \"رقم هاتف غير صحيح. يرجى إدخال رقم صحيح:\")\n                return\n            \n            # إنشاء رقم عميل\n            customer_id = f\"C{str(int(datetime.now().timestamp()))[-6:]}\"\n            \n            # حفظ المستخدم\n            with open('users.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([user_id, name, phone, customer_id, 'ar', datetime.now().strftime('%Y-%m-%d'), 'no'])\n            \n            welcome_text = f\"\"\"✅ تم التسجيل بنجاح!\n\n👤 الاسم: {name}\n📱 الهاتف: {phone}\n🆔 رقم العميل: {customer_id}\n\nيمكنك الآن استخدام الخدمات:\"\"\"\n            \n            self.send_message(message['chat']['id'], welcome_text, self.main_keyboard())\n            del self.user_states[user_id]\n    \n    def start_deposit(self, message):\n        \"\"\"بدء عملية الإيداع\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        self.send_message(message['chat']['id'], \"اختر الشركة للإيداع:\", self.companies_keyboard('deposit'))\n        self.user_states[message['from']['id']] = 'selecting_deposit_company'\n    \n    def start_withdrawal(self, message):\n        \"\"\"بدء عملية السحب\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        self.send_message(message['chat']['id'], \"اختر الشركة للسحب:\", self.companies_keyboard('withdraw'))\n        self.user_states[message['from']['id']] = 'selecting_withdraw_company'\n    \n    def process_deposit_flow(self, message):\n        \"\"\"معالجة تدفق الإيداع\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        text = message['text']\n        \n        if state == 'selecting_deposit_company':\n            # حفظ الشركة المختارة\n            companies = self.get_companies('deposit')\n            selected_company = None\n            for company in companies:\n                if company['name'] == text:\n                    selected_company = company\n                    break\n            \n            if not selected_company:\n                self.send_message(message['chat']['id'], \"اختيار غير صحيح. اختر من القائمة:\")\n                return\n            \n            self.user_states[user_id] = f'deposit_wallet_{selected_company[\"name\"]}'\n            self.send_message(message['chat']['id'], f\"أدخل رقم محفظتك/حسابك في {selected_company['name']}:\")\n            \n        elif state.startswith('deposit_wallet_'):\n            company_name = state.replace('deposit_wallet_', '')\n            wallet_number = text.strip()\n            \n            if len(wallet_number) < 5:\n                self.send_message(message['chat']['id'], \"رقم المحفظة قصير. أدخل رقم صحيح:\")\n                return\n            \n            self.user_states[user_id] = f'deposit_amount_{company_name}_{wallet_number}'\n            self.send_message(message['chat']['id'], \"أدخل المبلغ المطلوب إيداعه:\")\n            \n        elif state.startswith('deposit_amount_'):\n            parts = state.split('_', 2)\n            company_name = parts[2].split('_')[0]\n            wallet_number = '_'.join(parts[2].split('_')[1:])\n            \n            try:\n                amount = float(text.strip())\n                if amount < 50:\n                    self.send_message(message['chat']['id'], \"أقل مبلغ للإيداع 50 ريال:\")\n                    return\n            except:\n                self.send_message(message['chat']['id'], \"مبلغ غير صحيح. أدخل رقم:\")\n                return\n            \n            # إنشاء المعاملة\n            user = self.find_user(user_id)\n            trans_id = f\"DEP{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n            \n            with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([trans_id, user['customer_id'], user['name'], 'deposit', \n                               company_name, wallet_number, amount, '', 'pending', \n                               datetime.now().strftime('%Y-%m-%d %H:%M'), ''])\n            \n            # رسالة تأكيد للعميل\n            confirmation = f\"\"\"✅ تم إرسال طلب الإيداع\n\n🆔 رقم المعاملة: {trans_id}\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n\nسيتم مراجعة طلبك وإشعارك بالنتيجة.\"\"\"\n            \n            self.send_message(message['chat']['id'], confirmation, self.main_keyboard())\n            \n            # إشعار الأدمن\n            admin_msg = f\"\"\"🔔 طلب إيداع جديد\n\n🆔 {trans_id}\n👤 {user['name']} ({user['customer_id']})\n🏢 {company_name}\n💳 {wallet_number}\n💰 {amount} ريال\n\nاستخدم: موافقة {trans_id} أو رفض {trans_id} سبب\"\"\"\n            \n            self.notify_admins(admin_msg)\n            del self.user_states[user_id]\n    \n    def process_withdrawal_flow(self, message):\n        \"\"\"معالجة تدفق السحب\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id, '')\n        text = message['text']\n        \n        if state == 'selecting_withdraw_company':\n            # حفظ الشركة المختارة\n            companies = self.get_companies('withdraw')\n            selected_company = None\n            for company in companies:\n                if company['name'] == text:\n                    selected_company = company\n                    break\n            \n            if not selected_company:\n                self.send_message(message['chat']['id'], \"اختيار غير صحيح. اختر من القائمة:\")\n                return\n            \n            self.user_states[user_id] = f'withdraw_wallet_{selected_company[\"name\"]}'\n            self.send_message(message['chat']['id'], f\"أدخل رقم محفظتك/حسابك في {selected_company['name']}:\")\n            \n        elif state.startswith('withdraw_wallet_'):\n            company_name = state.replace('withdraw_wallet_', '')\n            wallet_number = text.strip()\n            \n            if len(wallet_number) < 5:\n                self.send_message(message['chat']['id'], \"رقم المحفظة قصير. أدخل رقم صحيح:\")\n                return\n            \n            self.user_states[user_id] = f'withdraw_amount_{company_name}_{wallet_number}'\n            self.send_message(message['chat']['id'], \"أدخل المبلغ المطلوب سحبه:\")\n            \n        elif state.startswith('withdraw_amount_'):\n            parts = state.split('_', 2)\n            company_name = parts[2].split('_')[0]\n            wallet_number = '_'.join(parts[2].split('_')[1:])\n            \n            try:\n                amount = float(text.strip())\n                if amount < 100:\n                    self.send_message(message['chat']['id'], \"أقل مبلغ للسحب 100 ريال:\")\n                    return\n            except:\n                self.send_message(message['chat']['id'], \"مبلغ غير صحيح. أدخل رقم:\")\n                return\n            \n            # عرض عنوان الصرافة\n            exchange_address = self.get_exchange_address()\n            self.user_states[user_id] = f'withdraw_confirm_{company_name}_{wallet_number}_{amount}'\n            \n            confirm_msg = f\"\"\"📍 عنوان مكتب الصرافة:\n{exchange_address}\n\nتأكيد طلب السحب:\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📍 العنوان: {exchange_address}\n\nأرسل \"تأكيد\" لإتمام الطلب أو \"إلغاء\" للعودة\"\"\"\n            \n            self.send_message(message['chat']['id'], confirm_msg)\n            \n        elif state.startswith('withdraw_confirm_'):\n            if text.lower() == 'تأكيد':\n                parts = state.split('_', 2)\n                company_name = parts[2].split('_')[0]\n                wallet_number = parts[2].split('_')[1]\n                amount = parts[2].split('_')[2]\n                \n                # إنشاء المعاملة\n                user = self.find_user(user_id)\n                trans_id = f\"WTH{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n                exchange_address = self.get_exchange_address()\n                \n                with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow([trans_id, user['customer_id'], user['name'], 'withdraw', \n                                   company_name, wallet_number, amount, exchange_address, 'pending', \n                                   datetime.now().strftime('%Y-%m-%d %H:%M'), ''])\n                \n                # رسالة تأكيد للعميل\n                confirmation = f\"\"\"✅ تم إرسال طلب السحب\n\n🆔 رقم المعاملة: {trans_id}\n🏢 الشركة: {company_name}\n💳 رقم المحفظة: {wallet_number}\n💰 المبلغ: {amount} ريال\n📍 العنوان: {exchange_address}\n\nسيتم مراجعة طلبك وإشعارك بالنتيجة.\"\"\"\n                \n                self.send_message(message['chat']['id'], confirmation, self.main_keyboard())\n                \n                # إشعار الأدمن\n                admin_msg = f\"\"\"🔔 طلب سحب جديد\n\n🆔 {trans_id}\n👤 {user['name']} ({user['customer_id']})\n🏢 {company_name}\n💳 {wallet_number}\n💰 {amount} ريال\n📍 {exchange_address}\n\nاستخدم: موافقة {trans_id} أو رفض {trans_id} سبب\"\"\"\n                \n                self.notify_admins(admin_msg)\n                del self.user_states[user_id]\n            else:\n                self.send_message(message['chat']['id'], \"تم إلغاء العملية\", self.main_keyboard())\n                del self.user_states[user_id]\n    \n    def show_user_requests(self, message):\n        \"\"\"عرض طلبات المستخدم\"\"\"\n        user = self.find_user(message['from']['id'])\n        if not user:\n            return\n        \n        requests_text = \"📋 طلباتك:\\n\\n\"\n        found_requests = False\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == user['customer_id']:\n                        found_requests = True\n                        status_emoji = \"⏳\" if row['status'] == 'pending' else \"✅\" if row['status'] == 'approved' else \"❌\"\n                        requests_text += f\"{status_emoji} {row['id']}\\n\"\n                        requests_text += f\"🏢 {row['company']}\\n\"\n                        requests_text += f\"💰 {row['amount']} ريال\\n\"\n                        requests_text += f\"📅 {row['date']}\\n\\n\"\n        except:\n            pass\n        \n        if not found_requests:\n            requests_text += \"لا توجد طلبات\"\n        \n        self.send_message(message['chat']['id'], requests_text, self.main_keyboard())\n    \n    def handle_admin_commands(self, message):\n        \"\"\"معالجة أوامر الأدمن\"\"\"\n        text = message['text'].lower()\n        \n        if text == 'طلبات معلقة':\n            self.show_pending_requests(message)\n        elif text.startswith('موافقة '):\n            self.approve_request(message, text.replace('موافقة ', ''))\n        elif text.startswith('رفض '):\n            parts = text.replace('رفض ', '').split(' ', 1)\n            trans_id = parts[0]\n            reason = parts[1] if len(parts) > 1 else 'غير محدد'\n            self.reject_request(message, trans_id, reason)\n        elif text == 'المستخدمين':\n            self.show_all_users(message)\n        elif text == 'إدارة الشركات':\n            self.show_companies_admin(message)\n        elif text == 'تعديل العنوان':\n            self.show_address_admin(message)\n        elif text == 'إحصائيات':\n            self.show_statistics(message)\n        elif text.startswith('اضف_شركة '):\n            self.add_company_simple(message, text)\n        elif text.startswith('حذف_شركة '):\n            self.delete_company_simple(message, text)\n        elif text.startswith('عنوان_جديد '):\n            self.update_address_simple(message, text)\n    \n    def show_pending_requests(self, message):\n        \"\"\"عرض الطلبات المعلقة\"\"\"\n        pending_text = \"📋 الطلبات المعلقة:\\n\\n\"\n        found_pending = False\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['status'] == 'pending':\n                        found_pending = True\n                        pending_text += f\"🆔 {row['id']}\\n\"\n                        pending_text += f\"👤 {row['name']} ({row['customer_id']})\\n\"\n                        pending_text += f\"📋 {row['type']} - {row['company']}\\n\"\n                        pending_text += f\"💰 {row['amount']} ريال\\n\"\n                        pending_text += f\"💳 {row['wallet_number']}\\n\"\n                        if row['exchange_address']:\n                            pending_text += f\"📍 {row['exchange_address']}\\n\"\n                        pending_text += f\"📅 {row['date']}\\n\\n\"\n        except:\n            pass\n        \n        if not found_pending:\n            pending_text += \"لا توجد طلبات معلقة\"\n        else:\n            pending_text += \"\\nاستخدم: موافقة رقم_المعاملة أو رفض رقم_المعاملة السبب\"\n        \n        self.send_message(message['chat']['id'], pending_text, self.admin_keyboard())\n    \n    def approve_request(self, message, trans_id):\n        \"\"\"موافقة على طلب\"\"\"\n        success = self.update_transaction_status(trans_id, 'approved')\n        \n        if success:\n            # إشعار العميل\n            transaction = self.get_transaction(trans_id)\n            if transaction:\n                customer = self.get_customer_by_id(transaction['customer_id'])\n                if customer:\n                    customer_msg = f\"\"\"✅ تمت الموافقة على طلبك\n\n🆔 {trans_id}\n💰 {transaction['amount']} ريال\n📅 {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\"\"\n                    \n                    self.send_message(customer['telegram_id'], customer_msg, self.main_keyboard())\n            \n            self.send_message(message['chat']['id'], f\"✅ تمت الموافقة على {trans_id}\", self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في الموافقة على {trans_id}\", self.admin_keyboard())\n    \n    def reject_request(self, message, trans_id, reason):\n        \"\"\"رفض طلب\"\"\"\n        success = self.update_transaction_status(trans_id, 'rejected', reason)\n        \n        if success:\n            # إشعار العميل\n            transaction = self.get_transaction(trans_id)\n            if transaction:\n                customer = self.get_customer_by_id(transaction['customer_id'])\n                if customer:\n                    customer_msg = f\"\"\"❌ تم رفض طلبك\n\n🆔 {trans_id}\n💰 {transaction['amount']} ريال\n📝 السبب: {reason}\n📅 {datetime.now().strftime('%Y-%m-%d %H:%M')}\"\"\"\n                    \n                    self.send_message(customer['telegram_id'], customer_msg, self.main_keyboard())\n            \n            self.send_message(message['chat']['id'], f\"✅ تم رفض {trans_id}\", self.admin_keyboard())\n        else:\n            self.send_message(message['chat']['id'], f\"❌ فشل في رفض {trans_id}\", self.admin_keyboard())\n    \n    def update_transaction_status(self, trans_id, new_status, note=''):\n        \"\"\"تحديث حالة المعاملة\"\"\"\n        transactions = []\n        success = False\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        row['status'] = new_status\n                        if note:\n                            row['admin_note'] = note\n                        success = True\n                    transactions.append(row)\n            \n            if success:\n                with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'customer_id', 'name', 'type', 'company', 'wallet_number', 'amount', 'exchange_address', 'status', 'date', 'admin_note']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(transactions)\n        except:\n            pass\n        \n        return success\n    \n    def get_transaction(self, trans_id):\n        \"\"\"جلب معاملة\"\"\"\n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == trans_id:\n                        return row\n        except:\n            pass\n        return None\n    \n    def get_customer_by_id(self, customer_id):\n        \"\"\"جلب عميل بالرقم\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['customer_id'] == customer_id:\n                        return row\n        except:\n            pass\n        return None\n    \n    def show_all_users(self, message):\n        \"\"\"عرض جميع المستخدمين\"\"\"\n        users_text = \"👥 جميع المستخدمين:\\n\\n\"\n        count = 0\n        \n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    count += 1\n                    status = \"🚫\" if row.get('is_banned') == 'yes' else \"✅\"\n                    users_text += f\"{status} {row['name']} ({row['customer_id']})\\n\"\n                    users_text += f\"📱 {row['phone']}\\n\\n\"\n        except:\n            pass\n        \n        users_text += f\"📊 إجمالي المستخدمين: {count}\"\n        self.send_message(message['chat']['id'], users_text, self.admin_keyboard())\n    \n    def show_companies_admin(self, message):\n        \"\"\"عرض إدارة الشركات\"\"\"\n        companies_text = \"🏢 إدارة الشركات:\\n\\n\"\n        \n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    companies_text += f\"🆔 {row['id']} - {row['name']}\\n\"\n                    companies_text += f\"⚡ {row['type']} - {row['details']}\\n\\n\"\n        except:\n            pass\n        \n        companies_text += \"\\n📝 الأوامر:\\n\"\n        companies_text += \"اضف_شركة اسم نوع تفاصيل\\n\"\n        companies_text += \"حذف_شركة رقم\\n\\n\"\n        companies_text += \"مثال: اضف_شركة مدى both محفظة\"\n        \n        self.send_message(message['chat']['id'], companies_text, self.admin_keyboard())\n    \n    def show_address_admin(self, message):\n        \"\"\"عرض إدارة العنوان\"\"\"\n        current_address = self.get_exchange_address()\n        \n        address_text = f\"📍 العنوان الحالي:\\n{current_address}\\n\\n\"\n        address_text += \"لتغيير العنوان استخدم:\\n\"\n        address_text += \"عنوان_جديد النص_الجديد\\n\\n\"\n        address_text += \"مثال: عنوان_جديد شارع التحلية، جدة\"\n        \n        self.send_message(message['chat']['id'], address_text, self.admin_keyboard())\n    \n    def show_statistics(self, message):\n        \"\"\"عرض الإحصائيات\"\"\"\n        stats_text = \"📊 إحصائيات النظام:\\n\\n\"\n        \n        # عدد المستخدمين\n        user_count = 0\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                user_count = sum(1 for row in reader)\n        except:\n            pass\n        \n        # المعاملات\n        total_transactions = 0\n        pending_count = 0\n        approved_count = 0\n        rejected_count = 0\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    total_transactions += 1\n                    if row['status'] == 'pending':\n                        pending_count += 1\n                    elif row['status'] == 'approved':\n                        approved_count += 1\n                    elif row['status'] == 'rejected':\n                        rejected_count += 1\n        except:\n            pass\n        \n        stats_text += f\"👥 المستخدمين: {user_count}\\n\"\n        stats_text += f\"📋 إجمالي المعاملات: {total_transactions}\\n\"\n        stats_text += f\"⏳ معلقة: {pending_count}\\n\"\n        stats_text += f\"✅ مُوافق عليها: {approved_count}\\n\"\n        stats_text += f\"❌ مرفوضة: {rejected_count}\\n\"\n        \n        self.send_message(message['chat']['id'], stats_text, self.admin_keyboard())\n    \n    def add_company_simple(self, message, text):\n        \"\"\"إضافة شركة بسيطة\"\"\"\n        parts = text.replace('اضف_شركة ', '').split(' ')\n        if len(parts) < 3:\n            self.send_message(message['chat']['id'], \"❌ استخدم: اضف_شركة اسم نوع تفاصيل\")\n            return\n        \n        name = parts[0]\n        company_type = parts[1]\n        details = ' '.join(parts[2:])\n        \n        if company_type not in ['deposit', 'withdraw', 'both']:\n            self.send_message(message['chat']['id'], \"❌ النوع يجب أن يكون: deposit أو withdraw أو both\")\n            return\n        \n        company_id = str(int(datetime.now().timestamp()))\n        \n        try:\n            with open('companies.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([company_id, name, company_type, details])\n            \n            self.send_message(message['chat']['id'], f\"✅ تم إضافة الشركة: {name}\")\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في إضافة الشركة\")\n    \n    def delete_company_simple(self, message, text):\n        \"\"\"حذف شركة بسيطة\"\"\"\n        company_id = text.replace('حذف_شركة ', '').strip()\n        \n        companies = []\n        deleted = False\n        \n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] != company_id:\n                        companies.append(row)\n                    else:\n                        deleted = True\n            \n            if deleted:\n                with open('companies.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'name', 'type', 'details']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(companies)\n                \n                self.send_message(message['chat']['id'], f\"✅ تم حذف الشركة رقم {company_id}\")\n            else:\n                self.send_message(message['chat']['id'], f\"❌ لم يتم العثور على شركة رقم {company_id}\")\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في حذف الشركة\")\n    \n    def update_address_simple(self, message, text):\n        \"\"\"تحديث العنوان بسيط\"\"\"\n        new_address = text.replace('عنوان_جديد ', '')\n        \n        try:\n            with open('exchange_addresses.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow(['id', 'address', 'is_active'])\n                writer.writerow(['1', new_address, 'yes'])\n            \n            self.send_message(message['chat']['id'], f\"✅ تم تحديث العنوان إلى:\\n{new_address}\")\n        except:\n            self.send_message(message['chat']['id'], \"❌ فشل في تحديث العنوان\")\n    \n    def process_message(self, message):\n        \"\"\"معالج الرسائل الرئيسي\"\"\"\n        if 'text' not in message:\n            return\n        \n        text = message['text']\n        chat_id = message['chat']['id']\n        user_id = message['from']['id']\n        \n        # بداية المحادثة\n        if text == '/start':\n            self.handle_start(message)\n            return\n        \n        # معالجة التسجيل\n        if user_id in self.user_states and self.user_states[user_id].startswith('registering'):\n            self.handle_registration(message)\n            return\n        \n        # فحص المستخدم المسجل\n        user = self.find_user(user_id)\n        if not user:\n            self.handle_start(message)\n            return\n        \n        # معالجة أوامر الأدمن\n        if self.is_admin(user_id):\n            if text == '/admin':\n                self.send_message(chat_id, \"🔧 لوحة تحكم الأدمن\", self.admin_keyboard())\n                return\n            \n            self.handle_admin_commands(message)\n            return\n        \n        # معالجة حالات المستخدم\n        if user_id in self.user_states:\n            state = self.user_states[user_id]\n            if 'deposit' in state:\n                self.process_deposit_flow(message)\n                return\n            elif 'withdraw' in state:\n                self.process_withdrawal_flow(message)\n                return\n        \n        # القوائم الرئيسية\n        if text == 'إيداع':\n            self.start_deposit(message)\n        elif text == 'سحب':\n            self.start_withdrawal(message)\n        elif text == 'طلباتي':\n            self.show_user_requests(message)\n        elif text == 'دعم':\n            support_msg = \"📞 للدعم الفني:\\n\\nيمكنك التواصل معنا عبر الطلبات أو مراسلة الإدارة مباشرة\"\n            self.send_message(chat_id, support_msg, self.main_keyboard())\n        elif text == 'رجوع':\n            self.send_message(chat_id, \"تم العودة للقائمة الرئيسية\", self.main_keyboard())\n            if user_id in self.user_states:\n                del self.user_states[user_id]\n        else:\n            self.send_message(chat_id, \"اختر من القائمة:\", self.main_keyboard())\n    \n    def run(self):\n        \"\"\"تشغيل البوت\"\"\"\n        logger.info(f\"✅ النظام المبسط يعمل\")\n        \n        while True:\n            try:\n                updates = self.get_updates()\n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        self.offset = update['update_id']\n                        \n                        if 'message' in update:\n                            self.process_message(update['message'])\n                        elif 'callback_query' in update:\n                            pass  # يمكن إضافة معالجة الأزرار هنا لاحقاً\n                            \n            except KeyboardInterrupt:\n                logger.info(\"تم إيقاف البوت\")\n                break\n            except Exception as e:\n                logger.error(f\"خطأ: {e}\")\n\nif __name__ == \"__main__\":\n    # جلب التوكن\n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        logger.error(\"BOT_TOKEN غير موجود في متغيرات البيئة\")\n        exit(1)\n    \n    # تشغيل البوت\n    bot = SimpleLangSenseBot(bot_token)\n    bot.run()","size_bytes":37528},"simple_payment_bot.py":{"content":"#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nبوت LangSense المبسط مع نظام وسائل الدفع\nإصدار مبسط يركز على الوظائف الأساسية\n\"\"\"\n\nimport csv\nimport os\nimport time\nimport logging\nimport urllib.request\nimport urllib.parse\nimport json\nfrom datetime import datetime\n\n# إعداد نظام السجلات\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass SimpleLangSenseBot:\n    def __init__(self, token):\n        self.token = token\n        self.base_url = f\"https://api.telegram.org/bot{token}\"\n        self.user_states = {}\n        self.init_files()\n        logger.info(\"تم إنشاء البوت المبسط بنجاح\")\n    \n    def init_files(self):\n        \"\"\"إنشاء الملفات الأساسية\"\"\"\n        files_to_create = [\n            ('users.csv', ['user_id', 'name', 'phone', 'customer_id', 'language', 'registration_date', 'is_banned', 'ban_reason']),\n            ('transactions.csv', ['id', 'user_id', 'customer_id', 'type', 'company_name', 'payment_method', 'wallet_number', 'amount', 'status', 'date', 'withdrawal_address', 'confirmation_code']),\n            ('companies.csv', ['id', 'name', 'type', 'details', 'is_active']),\n            ('payment_methods.csv', ['id', 'company_id', 'method_name', 'method_type', 'account_data', 'additional_info', 'status', 'created_date'])\n        ]\n        \n        for filename, headers in files_to_create:\n            if not os.path.exists(filename):\n                with open(filename, 'w', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow(headers)\n                logger.info(f\"تم إنشاء الملف: {filename}\")\n    \n    def send_message(self, chat_id, text, keyboard=None):\n        \"\"\"إرسال رسالة\"\"\"\n        try:\n            data = {\n                'chat_id': chat_id,\n                'text': text,\n                'parse_mode': 'Markdown'\n            }\n            \n            if keyboard:\n                data['reply_markup'] = json.dumps(keyboard)\n            \n            encoded_data = urllib.parse.urlencode(data).encode('utf-8')\n            request = urllib.request.Request(f\"{self.base_url}/sendMessage\", data=encoded_data)\n            response = urllib.request.urlopen(request)\n            return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في إرسال الرسالة: {e}\")\n            return None\n    \n    def is_admin(self, user_id):\n        \"\"\"فحص الأدمن\"\"\"\n        admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n        return str(user_id) in admin_ids\n    \n    def main_keyboard(self, language='ar'):\n        \"\"\"الكيبورد الرئيسي\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '💰 طلب إيداع'}, {'text': '💸 طلب سحب'}],\n                [{'text': '📋 طلباتي'}, {'text': '👤 حسابي'}],\n                [{'text': '📨 شكوى'}, {'text': '🆘 دعم'}]\n            ],\n            'resize_keyboard': True\n        }\n    \n    def admin_keyboard(self):\n        \"\"\"كيبورد الأدمن\"\"\"\n        return {\n            'keyboard': [\n                [{'text': '📋 الطلبات المعلقة'}, {'text': '✅ طلبات مُوافقة'}],\n                [{'text': '💳 وسائل الدفع'}, {'text': '🏢 الشركات'}],\n                [{'text': '👥 المستخدمين'}, {'text': '📊 الإحصائيات'}],\n                [{'text': '🏠 القائمة الرئيسية'}]\n            ],\n            'resize_keyboard': True\n        }\n    \n    def find_user(self, user_id):\n        \"\"\"العثور على مستخدم\"\"\"\n        try:\n            with open('users.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['user_id'] == str(user_id):\n                        return row\n        except:\n            pass\n        return None\n    \n    def get_companies(self):\n        \"\"\"الحصول على الشركات\"\"\"\n        companies = []\n        try:\n            with open('companies.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row.get('is_active') == 'yes':\n                        companies.append(row)\n        except:\n            pass\n        return companies\n    \n    def get_payment_methods_by_company(self, company_id):\n        \"\"\"الحصول على وسائل الدفع للشركة\"\"\"\n        methods = []\n        try:\n            with open('payment_methods.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['company_id'] == str(company_id) and row.get('status') == 'active':\n                        methods.append(row)\n        except:\n            pass\n        return methods\n    \n    def handle_start(self, message):\n        \"\"\"معالجة بدء المحادثة\"\"\"\n        user_id = message['from']['id']\n        chat_id = message['chat']['id']\n        \n        user = self.find_user(user_id)\n        \n        if user:\n            if user.get('is_banned') == 'yes':\n                ban_reason = user.get('ban_reason', 'غير محدد')\n                self.send_message(chat_id, f\"❌ تم حظر حسابك\\nالسبب: {ban_reason}\")\n                return\n            \n            welcome_text = f\"مرحباً بعودتك {user['name']}! 👋\\n🆔 رقم العميل: {user['customer_id']}\"\n            self.send_message(chat_id, welcome_text, self.main_keyboard())\n        else:\n            welcome_text = \"\"\"مرحباً بك في نظام LangSense المالي! 👋\n\n🔹 خدمات الإيداع والسحب\n🔹 دعم فني متخصص\n🔹 أمان وموثوقية عالية\n\nيرجى إرسال اسمك الكامل للتسجيل:\"\"\"\n            self.send_message(chat_id, welcome_text)\n            self.user_states[user_id] = 'registering_name'\n    \n    def handle_registration(self, message):\n        \"\"\"معالجة التسجيل\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states.get(user_id)\n        \n        if state == 'registering_name':\n            name = message['text'].strip()\n            if len(name) < 2:\n                self.send_message(message['chat']['id'], \"❌ اسم قصير جداً. يرجى إدخال اسم صحيح:\")\n                return\n            \n            self.user_states[user_id] = f'registering_phone_{name}'\n            \n            # كيبورد مشاركة جهة الاتصال\n            contact_keyboard = {\n                'keyboard': [\n                    [{'text': '📱 مشاركة رقم الهاتف', 'request_contact': True}],\n                    [{'text': '✍️ كتابة الرقم يدوياً'}]\n                ],\n                'resize_keyboard': True,\n                'one_time_keyboard': True\n            }\n            \n            phone_text = \"\"\"ممتاز! الآن أرسل رقم هاتفك:\n\n📱 يمكنك مشاركة رقمك مباشرة بالضغط على \"📱 مشاركة رقم الهاتف\"\n✍️ أو اكتب الرقم يدوياً مع رمز البلد (مثال: +966501234567)\"\"\"\n            \n            self.send_message(message['chat']['id'], phone_text, contact_keyboard)\n            \n        elif state.startswith('registering_phone_'):\n            name = state.replace('registering_phone_', '')\n            \n            # التحقق من نوع الرسالة\n            if 'contact' in message:\n                # مشاركة جهة الاتصال\n                phone = message['contact']['phone_number']\n                if not phone.startswith('+'):\n                    phone = '+' + phone\n            elif 'text' in message:\n                text = message['text'].strip()\n                \n                if text == '✍️ كتابة الرقم يدوياً':\n                    manual_text = \"\"\"✍️ اكتب رقم هاتفك مع رمز البلد:\n\nمثال: +966501234567\nمثال: +201234567890\"\"\"\n                    self.send_message(message['chat']['id'], manual_text)\n                    return\n                \n                phone = text\n                if len(phone) < 10:\n                    self.send_message(message['chat']['id'], \"❌ رقم هاتف غير صحيح. يرجى إدخال رقم صحيح مع رمز البلد:\")\n                    return\n            else:\n                self.send_message(message['chat']['id'], \"❌ يرجى مشاركة جهة الاتصال أو كتابة الرقم:\")\n                return\n            \n            # إنشاء رقم عميل تلقائي\n            customer_id = f\"C{str(int(datetime.now().timestamp()))[-6:]}\"\n            \n            # حفظ المستخدم\n            with open('users.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                writer = csv.writer(f)\n                writer.writerow([user_id, name, phone, customer_id, 'ar', \n                               datetime.now().strftime('%Y-%m-%d'), 'no', ''])\n            \n            welcome_text = f\"\"\"✅ تم التسجيل بنجاح!\n\n👤 الاسم: {name}\n📱 الهاتف: {phone}\n🆔 رقم العميل: {customer_id}\n📅 تاريخ التسجيل: {datetime.now().strftime('%Y-%m-%d')}\n\nيمكنك الآن استخدام جميع الخدمات المالية:\"\"\"\n            \n            self.send_message(message['chat']['id'], welcome_text, self.main_keyboard())\n            del self.user_states[user_id]\n    \n    def handle_deposit(self, message):\n        \"\"\"معالجة طلب الإيداع\"\"\"\n        user_id = message['from']['id']\n        companies = self.get_companies()\n        \n        if not companies:\n            self.send_message(message['chat']['id'], \"❌ لا توجد شركات متاحة حالياً\")\n            return\n        \n        companies_text = \"💰 اختر الشركة للإيداع:\\n\\n\"\n        keyboard_buttons = []\n        \n        for company in companies:\n            companies_text += f\"🏢 {company['name']} - {company['type']}\\n\"\n            keyboard_buttons.append([{'text': company['name']}])\n        \n        keyboard_buttons.append([{'text': '🔙 العودة'}])\n        \n        keyboard = {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], companies_text, keyboard)\n        self.user_states[user_id] = 'deposit_company_selection'\n    \n    def handle_withdrawal(self, message):\n        \"\"\"معالجة طلب السحب\"\"\"\n        user_id = message['from']['id']\n        companies = self.get_companies()\n        \n        if not companies:\n            self.send_message(message['chat']['id'], \"❌ لا توجد شركات متاحة حالياً\")\n            return\n        \n        companies_text = \"💸 اختر الشركة للسحب:\\n\\n\"\n        keyboard_buttons = []\n        \n        for company in companies:\n            companies_text += f\"🏢 {company['name']} - {company['type']}\\n\"\n            keyboard_buttons.append([{'text': company['name']}])\n        \n        keyboard_buttons.append([{'text': '🔙 العودة'}])\n        \n        keyboard = {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], companies_text, keyboard)\n        self.user_states[user_id] = 'withdraw_company_selection'\n    \n    def handle_company_selection(self, message, transaction_type):\n        \"\"\"معالجة اختيار الشركة\"\"\"\n        user_id = message['from']['id']\n        company_name = message['text'].strip()\n        \n        if company_name == '🔙 العودة':\n            del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم الإلغاء\", self.main_keyboard())\n            return\n        \n        # البحث عن الشركة\n        companies = self.get_companies()\n        selected_company = None\n        \n        for company in companies:\n            if company['name'] == company_name:\n                selected_company = company\n                break\n        \n        if not selected_company:\n            self.send_message(message['chat']['id'], \"❌ شركة غير صحيحة. يرجى الاختيار من القائمة\")\n            return\n        \n        # الحصول على وسائل الدفع للشركة\n        payment_methods = self.get_payment_methods_by_company(selected_company['id'])\n        \n        if not payment_methods:\n            self.send_message(message['chat']['id'], \n                            f\"❌ لا توجد وسائل دفع متاحة لشركة {company_name} حالياً\")\n            return\n        \n        # عرض وسائل الدفع\n        methods_text = f\"💳 وسائل الدفع المتاحة لشركة {company_name}:\\n\\n\"\n        keyboard_buttons = []\n        \n        for method in payment_methods:\n            method_info = f\"📋 {method['method_name']} ({method['method_type']})\\n\"\n            method_info += f\"💰 الحساب: `{method['account_data']}`\\n\"\n            if method.get('additional_info'):\n                method_info += f\"💡 {method['additional_info']}\\n\"\n            method_info += \"━━━━━━━━━━━━━━━━━━━━\\n\"\n            \n            methods_text += method_info\n            keyboard_buttons.append([{'text': method['method_name']}])\n        \n        methods_text += \"\\n📋 انسخ رقم الحساب المطلوب ثم اختر وسيلة الدفع:\"\n        \n        keyboard_buttons.append([{'text': '🔙 العودة لاختيار الشركة'}])\n        \n        keyboard = {\n            'keyboard': keyboard_buttons,\n            'resize_keyboard': True,\n            'one_time_keyboard': True\n        }\n        \n        self.send_message(message['chat']['id'], methods_text, keyboard)\n        self.user_states[user_id] = {\n            'step': 'method_selection',\n            'transaction_type': transaction_type,\n            'company': selected_company,\n            'methods': payment_methods\n        }\n    \n    def handle_method_selection(self, message):\n        \"\"\"معالجة اختيار وسيلة الدفع\"\"\"\n        user_id = message['from']['id']\n        method_name = message['text'].strip()\n        state = self.user_states[user_id]\n        \n        if method_name == '🔙 العودة لاختيار الشركة':\n            transaction_type = state['transaction_type']\n            if transaction_type == 'deposit':\n                self.handle_deposit(message)\n            else:\n                self.handle_withdrawal(message)\n            return\n        \n        # البحث عن وسيلة الدفع المختارة\n        selected_method = None\n        for method in state['methods']:\n            if method['method_name'] == method_name:\n                selected_method = method\n                break\n        \n        if not selected_method:\n            self.send_message(message['chat']['id'], \"❌ اختيار غير صحيح. يرجى الاختيار من القائمة\")\n            return\n        \n        # طلب رقم المحفظة\n        wallet_text = f\"\"\"✅ تم اختيار: {selected_method['method_name']}\n\n📝 الآن أدخل رقم محفظتك/حسابك الشخصي:\"\"\"\n        \n        self.send_message(message['chat']['id'], wallet_text)\n        \n        # تحديث الحالة\n        company = state['company']\n        transaction_type = state['transaction_type']\n        self.user_states[user_id] = f'{transaction_type}_wallet_{company[\"id\"]}_{company[\"name\"]}_{selected_method[\"id\"]}'\n    \n    def process_transaction_flow(self, message, transaction_type):\n        \"\"\"معالجة تدفق المعاملة\"\"\"\n        user_id = message['from']['id']\n        state = self.user_states[user_id]\n        text = message['text'].strip()\n        \n        if text == '/cancel':\n            del self.user_states[user_id]\n            self.send_message(message['chat']['id'], \"تم إلغاء العملية\", self.main_keyboard())\n            return\n        \n        # استخراج معلومات الحالة\n        parts = state.split('_')\n        if len(parts) >= 4:\n            company_id = parts[2]\n            company_name = parts[3]\n            method_id = parts[4] if len(parts) > 4 else ''\n            \n            if f'{transaction_type}_wallet_' in state:\n                # حفظ رقم المحفظة وطلب المبلغ\n                wallet_number = text\n                amount_text = f\"\"\"💰 تم حفظ رقم المحفظة: {wallet_number}\n\n📝 الآن أدخل المبلغ:\n\n⬅️ /cancel للإلغاء\"\"\"\n                \n                self.send_message(message['chat']['id'], amount_text)\n                self.user_states[user_id] = f'{transaction_type}_amount_{company_id}_{company_name}_{method_id}_{wallet_number}'\n                \n            elif f'{transaction_type}_amount_' in state:\n                # حفظ المبلغ وإنهاء المعاملة\n                try:\n                    amount = float(text)\n                    if amount <= 0:\n                        raise ValueError()\n                except:\n                    self.send_message(message['chat']['id'], \"❌ مبلغ غير صحيح. يرجى إدخال رقم صحيح:\")\n                    return\n                \n                # استخراج رقم المحفظة\n                wallet_number = parts[5] if len(parts) > 5 else ''\n                \n                # إنشاء معاملة جديدة\n                transaction_id = f\"{transaction_type.upper()}{str(int(datetime.now().timestamp()))[-6:]}\"\n                user = self.find_user(user_id)\n                \n                with open('transactions.csv', 'a', newline='', encoding='utf-8-sig') as f:\n                    writer = csv.writer(f)\n                    writer.writerow([\n                        transaction_id, user_id, user.get('customer_id', ''), \n                        transaction_type, company_name, method_id,\n                        wallet_number, amount, 'pending', \n                        datetime.now().strftime('%Y-%m-%d %H:%M'), '', ''\n                    ])\n                \n                # رسالة تأكيد للعميل\n                confirmation_text = f\"\"\"✅ تم إرسال طلب {'الإيداع' if transaction_type == 'deposit' else 'السحب'} بنجاح!\n\n🆔 رقم المعاملة: {transaction_id}\n🏢 الشركة: {company_name}\n💰 المبلغ: {amount}\n📱 رقم المحفظة: {wallet_number}\n📅 التاريخ: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\n⏳ حالة الطلب: قيد المراجعة\nسيتم إشعارك عند الموافقة أو الرفض\"\"\"\n                \n                self.send_message(message['chat']['id'], confirmation_text, self.main_keyboard())\n                \n                # إشعار الأدمن\n                admin_ids = os.getenv('ADMIN_USER_IDS', '').split(',')\n                admin_msg = f\"\"\"🆕 طلب {'إيداع' if transaction_type == 'deposit' else 'سحب'} جديد\n\n🆔 رقم المعاملة: {transaction_id}\n👤 العميل: {user.get('name', 'غير محدد')} ({user.get('customer_id', '')})\n🏢 الشركة: {company_name}\n💰 المبلغ: {amount}\n📱 رقم المحفظة: {wallet_number}\n\nللموافقة: موافقة {transaction_id}\nللرفض: رفض {transaction_id} السبب\"\"\"\n                \n                for admin_id in admin_ids:\n                    if admin_id.strip():\n                        self.send_message(int(admin_id), admin_msg)\n                \n                del self.user_states[user_id]\n    \n    def handle_admin_commands(self, message):\n        \"\"\"معالجة أوامر الأدمن\"\"\"\n        text = message['text'].strip()\n        chat_id = message['chat']['id']\n        \n        if text.startswith('موافقة '):\n            transaction_id = text.replace('موافقة ', '').strip()\n            self.approve_transaction(chat_id, transaction_id)\n            \n        elif text.startswith('رفض '):\n            parts = text.split(' ', 2)\n            if len(parts) >= 3:\n                transaction_id = parts[1]\n                reason = parts[2]\n                self.reject_transaction(chat_id, transaction_id, reason)\n            else:\n                self.send_message(chat_id, \"الصيغة: رفض رقم_المعاملة السبب\")\n    \n    def approve_transaction(self, chat_id, transaction_id):\n        \"\"\"الموافقة على معاملة\"\"\"\n        # تحديث المعاملة\n        transactions = []\n        updated = False\n        approved_transaction = None\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == transaction_id and row['status'] == 'pending':\n                        row['status'] = 'approved'\n                        updated = True\n                        approved_transaction = row\n                    transactions.append(row)\n            \n            if updated:\n                with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'user_id', 'customer_id', 'type', 'company_name', 'payment_method', 'wallet_number', 'amount', 'status', 'date', 'withdrawal_address', 'confirmation_code']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(transactions)\n                \n                # إشعار الأدمن\n                self.send_message(chat_id, f\"✅ تم الموافقة على المعاملة {transaction_id}\")\n                \n                # إشعار العميل\n                customer_msg = f\"\"\"✅ تم الموافقة على طلبك!\n\n🆔 رقم المعاملة: {transaction_id}\n💰 المبلغ: {approved_transaction['amount']}\n📅 تاريخ الموافقة: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nشكراً لاستخدامك خدماتنا\"\"\"\n                \n                self.send_message(int(approved_transaction['user_id']), customer_msg)\n            else:\n                self.send_message(chat_id, f\"❌ لم يتم العثور على معاملة معلقة برقم {transaction_id}\")\n        except Exception as e:\n            self.send_message(chat_id, f\"❌ خطأ في الموافقة: {e}\")\n    \n    def reject_transaction(self, chat_id, transaction_id, reason):\n        \"\"\"رفض معاملة\"\"\"\n        # تحديث المعاملة\n        transactions = []\n        updated = False\n        rejected_transaction = None\n        \n        try:\n            with open('transactions.csv', 'r', encoding='utf-8-sig') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    if row['id'] == transaction_id and row['status'] == 'pending':\n                        row['status'] = 'rejected'\n                        updated = True\n                        rejected_transaction = row\n                    transactions.append(row)\n            \n            if updated:\n                with open('transactions.csv', 'w', newline='', encoding='utf-8-sig') as f:\n                    fieldnames = ['id', 'user_id', 'customer_id', 'type', 'company_name', 'payment_method', 'wallet_number', 'amount', 'status', 'date', 'withdrawal_address', 'confirmation_code']\n                    writer = csv.DictWriter(f, fieldnames=fieldnames)\n                    writer.writeheader()\n                    writer.writerows(transactions)\n                \n                # إشعار الأدمن\n                self.send_message(chat_id, f\"❌ تم رفض المعاملة {transaction_id}\")\n                \n                # إشعار العميل\n                customer_msg = f\"\"\"❌ تم رفض طلبك\n\n🆔 رقم المعاملة: {transaction_id}\n💰 المبلغ: {rejected_transaction['amount']}\n🔍 سبب الرفض: {reason}\n📅 تاريخ الرفض: {datetime.now().strftime('%Y-%m-%d %H:%M')}\n\nيمكنك تقديم طلب جديد بعد تصحيح المشكلة\"\"\"\n                \n                self.send_message(int(rejected_transaction['user_id']), customer_msg)\n            else:\n                self.send_message(chat_id, f\"❌ لم يتم العثور على معاملة معلقة برقم {transaction_id}\")\n        except Exception as e:\n            self.send_message(chat_id, f\"❌ خطأ في الرفض: {e}\")\n    \n    def handle_message(self, message):\n        \"\"\"معالجة الرسائل الواردة\"\"\"\n        try:\n            # قبول الرسائل النصية أو جهات الاتصال\n            if 'text' not in message and 'contact' not in message:\n                return\n            \n            user_id = message['from']['id']\n            chat_id = message['chat']['id']\n            text = message.get('text', '')\n            \n            # معالجة /start\n            if text == '/start':\n                self.handle_start(message)\n                return\n            \n            # معالجة التسجيل\n            if user_id in self.user_states:\n                state = self.user_states[user_id]\n                if isinstance(state, str):\n                    if state.startswith('registering'):\n                        self.handle_registration(message)\n                        return\n                    elif 'deposit' in state:\n                        self.process_transaction_flow(message, 'deposit')\n                        return\n                    elif 'withdraw' in state:\n                        self.process_transaction_flow(message, 'withdrawal')\n                        return\n                    elif state == 'deposit_company_selection':\n                        self.handle_company_selection(message, 'deposit')\n                        return\n                    elif state == 'withdraw_company_selection':\n                        self.handle_company_selection(message, 'withdrawal')\n                        return\n                elif isinstance(state, dict):\n                    if state.get('step') == 'method_selection':\n                        self.handle_method_selection(message)\n                        return\n            \n            # فحص المستخدم المسجل\n            user = self.find_user(user_id)\n            if not user:\n                self.handle_start(message)\n                return\n            \n            # فحص الحظر\n            if user.get('is_banned') == 'yes':\n                ban_reason = user.get('ban_reason', 'غير محدد')\n                self.send_message(chat_id, f\"❌ تم حظر حسابك\\nالسبب: {ban_reason}\")\n                return\n            \n            # معالجة أوامر الأدمن\n            if self.is_admin(user_id):\n                if text == '/admin':\n                    self.send_message(chat_id, \"مرحباً بك في لوحة الإدارة\", self.admin_keyboard())\n                    return\n                \n                # أوامر الموافقة والرفض\n                if text.startswith(('موافقة ', 'رفض ')):\n                    self.handle_admin_commands(message)\n                    return\n            \n            # معالجة القوائم الرئيسية\n            if text == '💰 طلب إيداع':\n                self.handle_deposit(message)\n            elif text == '💸 طلب سحب':\n                self.handle_withdrawal(message)\n            elif text == '🏠 القائمة الرئيسية':\n                if user_id in self.user_states:\n                    del self.user_states[user_id]\n                self.send_message(chat_id, \"تم العودة للقائمة الرئيسية\", self.main_keyboard())\n            else:\n                # رسالة افتراضية\n                self.send_message(chat_id, \"مرحباً! استخدم الأزرار للتنقل في النظام\", self.main_keyboard())\n        \n        except Exception as e:\n            logger.error(f\"خطأ في معالجة الرسالة: {e}\")\n    \n    def get_updates(self, offset=None):\n        \"\"\"جلب التحديثات من تليجرام\"\"\"\n        try:\n            url = f\"{self.base_url}/getUpdates\"\n            if offset:\n                url += f\"?offset={offset}\"\n            \n            request = urllib.request.Request(url)\n            response = urllib.request.urlopen(request)\n            return json.loads(response.read().decode('utf-8'))\n        except Exception as e:\n            logger.error(f\"خطأ في جلب التحديثات: {e}\")\n            return None\n    \n    def run(self):\n        \"\"\"تشغيل البوت\"\"\"\n        logger.info(\"✅ البوت المبسط يعمل الآن\")\n        offset = None\n        \n        while True:\n            try:\n                updates = self.get_updates(offset)\n                if updates and updates.get('ok'):\n                    for update in updates['result']:\n                        if 'message' in update:\n                            self.handle_message(update['message'])\n                        offset = update['update_id'] + 1\n                \n                time.sleep(1)\n            except KeyboardInterrupt:\n                logger.info(\"تم إيقاف البوت\")\n                break\n            except Exception as e:\n                logger.error(f\"خطأ في التشغيل: {e}\")\n                time.sleep(5)\n\nif __name__ == \"__main__\":\n    # جلب التوكن\n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        logger.error(\"BOT_TOKEN غير موجود في متغيرات البيئة\")\n        exit(1)\n    \n    # تشغيل البوت\n    bot = SimpleLangSenseBot(bot_token)\n    bot.run()","size_bytes":30243},"test_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest script to verify the bot database and functionality\n\"\"\"\n\nimport sqlite3\nimport json\n\ndef test_database():\n    \"\"\"Test the SQLite database\"\"\"\n    print(\"🔍 Testing LangSense Database...\")\n    \n    try:\n        conn = sqlite3.connect('langsense.db')\n        cursor = conn.cursor()\n        \n        # Test tables\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n        tables = cursor.fetchall()\n        print(f\"📊 Found tables: {[table[0] for table in tables]}\")\n        \n        # Test languages\n        cursor.execute(\"SELECT * FROM languages\")\n        languages = cursor.fetchall()\n        print(f\"🌐 Available languages: {languages}\")\n        \n        # Test users count\n        cursor.execute(\"SELECT COUNT(*) FROM users\")\n        user_count = cursor.fetchone()[0]\n        print(f\"👥 Total users: {user_count}\")\n        \n        conn.close()\n        print(\"✅ Database test completed successfully!\")\n        return True\n        \n    except Exception as e:\n        print(f\"❌ Database test failed: {e}\")\n        return False\n\ndef test_bot_api():\n    \"\"\"Test Telegram API connection\"\"\"\n    import os\n    from urllib.request import urlopen, Request\n    \n    print(\"\\n🤖 Testing Telegram API connection...\")\n    \n    bot_token = os.getenv('BOT_TOKEN')\n    if not bot_token:\n        print(\"❌ BOT_TOKEN not found in environment\")\n        return False\n        \n    try:\n        url = f\"https://api.telegram.org/bot{bot_token}/getMe\"\n        request = Request(url)\n        \n        with urlopen(request, timeout=10) as response:\n            data = json.loads(response.read().decode('utf-8'))\n            \n        if data.get('ok'):\n            bot_info = data['result']\n            print(f\"✅ Bot connected successfully!\")\n            print(f\"📛 Bot name: {bot_info['first_name']}\")\n            print(f\"🏷️ Bot username: @{bot_info['username']}\")\n            print(f\"🆔 Bot ID: {bot_info['id']}\")\n            return True\n        else:\n            print(f\"❌ API returned error: {data}\")\n            return False\n            \n    except Exception as e:\n        print(f\"❌ API test failed: {e}\")\n        return False\n\ndef display_bot_info():\n    \"\"\"Display bot setup information\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"🚀 LangSense Telegram Bot - Setup Complete!\")\n    print(\"=\"*50)\n    print(\"\\n📋 Features Available:\")\n    print(\"  ✅ Multi-language support (Arabic RTL + English)\")\n    print(\"  ✅ User registration with phone verification\")\n    print(\"  ✅ Customer ID generation\")\n    print(\"  ✅ Financial services (Deposit/Withdraw)\")\n    print(\"  ✅ Admin panel and broadcasting\")\n    print(\"  ✅ SQLite database with user management\")\n    print(\"  ✅ Simple HTTP-based implementation (no dependency issues)\")\n    \n    print(\"\\n🔧 How to Test:\")\n    print(\"  1. Open Telegram and search for your bot\")\n    print(\"  2. Send /start command to begin\")\n    print(\"  3. Share your phone number when prompted\")\n    print(\"  4. Explore the menu options\")\n    print(\"  5. Try admin commands with /admin (if you're an admin)\")\n    \n    print(\"\\n⚙️ Configuration:\")\n    print(\"  - Bot Token: ✅ Configured\")\n    print(\"  - Admin IDs: ✅ Configured\") \n    print(\"  - Database: ✅ SQLite (langsense.db)\")\n    print(\"  - Languages: Arabic (default), English\")\n    \n    print(\"\\n📝 Next Steps:\")\n    print(\"  - Test the bot in Telegram\")\n    print(\"  - Verify phone number registration\")\n    print(\"  - Check admin functionality\")\n    print(\"  - Review logs for any issues\")\n\ndef main():\n    print(\"LangSense Bot - System Test\")\n    print(\"=\" * 30)\n    \n    # Test database\n    db_ok = test_database()\n    \n    # Test API\n    api_ok = test_bot_api()\n    \n    if db_ok and api_ok:\n        display_bot_info()\n        print(\"\\n🎉 All systems are GO! The bot is ready for use.\")\n    else:\n        print(\"\\n⚠️ Some tests failed. Please check the configuration.\")\n\nif __name__ == '__main__':\n    main()","size_bytes":3996},"backup_server_files/bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMain bot module with Aiogram v3 setup\nHandles bot initialization, router registration, and polling\n\"\"\"\n\nimport asyncio\nimport logging\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\nfrom aiogram.fsm.storage.memory import MemoryStorage\n\nfrom config import BOT_TOKEN\nfrom handlers import start, admin, broadcast, user_settings, announcements\nfrom services.broadcast_service import BroadcastService\n\nlogger = logging.getLogger(__name__)\n\n# Global variables for dependency injection\nbot_instance = None\nsession_maker = None\nbroadcast_service = None\n\nasync def main(async_session):\n    \"\"\"Main bot function\"\"\"\n    global bot_instance, session_maker, broadcast_service\n    \n    try:\n        # Validate bot token\n        if not BOT_TOKEN:\n            raise ValueError(\"BOT_TOKEN is not set in environment variables\")\n        \n        # Initialize bot and dispatcher\n        bot_instance = Bot(\n            token=BOT_TOKEN,\n            default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n        )\n        \n        # Test bot token\n        bot_info = await bot_instance.get_me()\n        logger.info(f\"Bot initialized: @{bot_info.username} ({bot_info.first_name})\")\n        \n        # Set session maker for handlers\n        session_maker = async_session\n        \n        # Initialize dispatcher with memory storage\n        storage = MemoryStorage()\n        dp = Dispatcher(storage=storage)\n        \n        # Initialize broadcast service\n        broadcast_service = BroadcastService(bot_instance, async_session)\n        \n        # Register routers\n        dp.include_routers(\n            start.router,\n            user_settings.router,\n            admin.router,\n            broadcast.router,\n            announcements.router\n        )\n        \n        # Set session maker and services for handlers\n        for router in [start.router, user_settings.router, admin.router, \n                      broadcast.router, announcements.router]:\n            router.message.middleware.register(SessionMiddleware(async_session))\n            router.callback_query.middleware.register(SessionMiddleware(async_session))\n        \n        # Start broadcast service worker\n        asyncio.create_task(broadcast_service.worker())\n        logger.info(\"Broadcast service worker started\")\n        \n        # Start polling\n        logger.info(\"Starting bot polling...\")\n        await dp.start_polling(bot_instance)\n        \n    except Exception as e:\n        logger.error(f\"Bot startup failed: {e}\")\n        raise\n    finally:\n        if bot_instance:\n            await bot_instance.session.close()\n\nclass SessionMiddleware:\n    \"\"\"Middleware to inject database session into handlers\"\"\"\n    \n    def __init__(self, session_maker):\n        self.session_maker = session_maker\n    \n    async def __call__(self, handler, event, data):\n        data['session_maker'] = self.session_maker\n        data['broadcast_service'] = broadcast_service\n        return await handler(event, data)\n\ndef get_bot():\n    \"\"\"Get bot instance for external use\"\"\"\n    return bot_instance\n\ndef get_session_maker():\n    \"\"\"Get session maker for external use\"\"\"\n    return session_maker\n\ndef get_broadcast_service():\n    \"\"\"Get broadcast service for external use\"\"\"\n    return broadcast_service\n","size_bytes":3344},"backup_server_files/config.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nConfiguration module for the LangSense Bot\nLoads environment variables and provides configuration constants\n\"\"\"\n\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Bot Configuration\nBOT_TOKEN = os.getenv(\"BOT_TOKEN\")\nif not BOT_TOKEN:\n    raise ValueError(\"BOT_TOKEN must be set in environment variables\")\n\n# Admin Configuration\nADMIN_USER_IDS_STR = os.getenv(\"ADMIN_USER_IDS\", \"\")\nADMIN_USER_IDS = [int(uid.strip()) for uid in ADMIN_USER_IDS_STR.split(\",\") if uid.strip().isdigit()]\n\nif not ADMIN_USER_IDS:\n    raise ValueError(\"ADMIN_USER_IDS must be set with at least one valid user ID\")\n\n# Database Configuration\nDATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite+aiosqlite:///./langsense.db\")\n\n# Broadcast Configuration\nBROADCAST_RATE_LIMIT = int(os.getenv(\"BROADCAST_RATE_LIMIT\", \"30\"))  # messages per second\nBROADCAST_CHUNK_SIZE = int(os.getenv(\"BROADCAST_CHUNK_SIZE\", \"100\"))  # users per batch\nBROADCAST_RETRY_ATTEMPTS = int(os.getenv(\"BROADCAST_RETRY_ATTEMPTS\", \"3\"))\nBROADCAST_RETRY_DELAY = int(os.getenv(\"BROADCAST_RETRY_DELAY\", \"5\"))  # seconds\n\n# Localization Configuration\nDEFAULT_LANGUAGE = os.getenv(\"DEFAULT_LANGUAGE\", \"ar\")\nDEFAULT_COUNTRY = os.getenv(\"DEFAULT_COUNTRY\", \"SA\")\nSUPPORTED_LANGUAGES = [\"ar\", \"en\"]\n\n# Customer ID Configuration\nCUSTOMER_ID_PREFIX = os.getenv(\"CUSTOMER_ID_PREFIX\", \"C\")\nCUSTOMER_ID_YEAR_FORMAT = os.getenv(\"CUSTOMER_ID_YEAR_FORMAT\", \"2025\")\n\n# File Upload Configuration\nMAX_FILE_SIZE = int(os.getenv(\"MAX_FILE_SIZE\", \"20\")) * 1024 * 1024  # 20MB default\nALLOWED_IMAGE_TYPES = [\"image/jpeg\", \"image/png\", \"image/gif\", \"image/webp\"]\n\n# Pagination Configuration\nUSERS_PER_PAGE = int(os.getenv(\"USERS_PER_PAGE\", \"10\"))\nANNOUNCEMENTS_PER_PAGE = int(os.getenv(\"ANNOUNCEMENTS_PER_PAGE\", \"5\"))\n\n# Logging Configuration\nLOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\")\nLOG_FILE = os.getenv(\"LOG_FILE\", \"bot.log\")\n\n# Rate Limiting Configuration\nUSER_RATE_LIMIT = int(os.getenv(\"USER_RATE_LIMIT\", \"5\"))  # requests per minute\nADMIN_RATE_LIMIT = int(os.getenv(\"ADMIN_RATE_LIMIT\", \"30\"))  # requests per minute\n\n# Validation\ndef validate_config():\n    \"\"\"Validate configuration settings\"\"\"\n    errors = []\n    \n    if not BOT_TOKEN or len(BOT_TOKEN) < 40:\n        errors.append(\"Invalid BOT_TOKEN format\")\n    \n    if not ADMIN_USER_IDS:\n        errors.append(\"No valid admin user IDs configured\")\n    \n    if BROADCAST_RATE_LIMIT > 30:\n        errors.append(\"BROADCAST_RATE_LIMIT cannot exceed 30 messages/second (Telegram limit)\")\n    \n    if errors:\n        raise ValueError(\"Configuration errors: \" + \"; \".join(errors))\n\n# Validate configuration on import\nvalidate_config()\n","size_bytes":2685},"backup_server_files/main.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMain entry point for the LangSense Telegram Bot\nHandles database initialization and starts the bot\n\"\"\"\n\nimport asyncio\nimport logging\nimport sys\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker\nfrom sqlalchemy.pool import StaticPool\n\nfrom config import DATABASE_URL\nfrom models import Base\nimport bot\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[\n        logging.FileHandler('bot.log'),\n        logging.StreamHandler(sys.stdout)\n    ]\n)\nlogger = logging.getLogger(__name__)\n\nasync def init_database():\n    \"\"\"Initialize database and create tables\"\"\"\n    try:\n        # Convert PostgreSQL URL to asyncpg if needed\n        db_url = DATABASE_URL\n        if db_url.startswith(\"postgresql://\"):\n            db_url = db_url.replace(\"postgresql://\", \"postgresql+asyncpg://\")\n        \n        # Create async engine\n        if \"sqlite\" in db_url:\n            # SQLite specific configuration\n            engine = create_async_engine(\n                db_url,\n                poolclass=StaticPool,\n                connect_args={\"check_same_thread\": False},\n                echo=False\n            )\n        else:\n            # PostgreSQL configuration\n            engine = create_async_engine(db_url, echo=False)\n        \n        # Create tables\n        async with engine.begin() as conn:\n            await conn.run_sync(Base.metadata.create_all)\n        \n        logger.info(\"Database initialized successfully\")\n        return engine\n        \n    except Exception as e:\n        logger.error(f\"Database initialization failed: {e}\")\n        raise\n\nasync def main():\n    \"\"\"Main application entry point\"\"\"\n    try:\n        logger.info(\"Starting LangSense Bot...\")\n        \n        # Initialize database\n        engine = await init_database()\n        \n        # Create session maker\n        async_session = async_sessionmaker(engine, expire_on_commit=False)\n        \n        # Start the bot\n        await bot.main(async_session)\n        \n    except KeyboardInterrupt:\n        logger.info(\"Bot stopped by user\")\n    except Exception as e:\n        logger.error(f\"Fatal error: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n","size_bytes":2328},"backup_server_files/models.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSQLAlchemy models for the LangSense Bot\nDefines database schema for users, languages, countries, announcements, and messaging\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom enum import Enum as PyEnum\nfrom typing import Optional\n\nfrom sqlalchemy import (\n    Boolean, Column, DateTime, Enum, ForeignKey, Integer, String, Text, \n    UniqueConstraint, Index, BigInteger\n)\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship, Mapped, mapped_column\n\nBase = declarative_base(cls=AsyncAttrs)\n\nclass OutboxType(PyEnum):\n    \"\"\"Types of outbox messages\"\"\"\n    DEPOSIT = \"deposit\"\n    WITHDRAWAL = \"withdrawal\" \n    COMPLAINT = \"complaint\"\n    SUPPORT = \"support\"\n    BROADCAST = \"broadcast\"\n    ANNOUNCEMENT = \"announcement\"\n\nclass OutboxStatus(PyEnum):\n    \"\"\"Status of outbox messages\"\"\"\n    PENDING = \"pending\"\n    APPROVED = \"approved\"\n    REJECTED = \"rejected\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n\nclass DeliveryStatus(PyEnum):\n    \"\"\"Status of message delivery\"\"\"\n    PENDING = \"pending\"\n    SENT = \"sent\"\n    DELIVERED = \"delivered\"\n    FAILED = \"failed\"\n    BLOCKED = \"blocked\"\n\nclass User(Base):\n    \"\"\"User model for storing Telegram user information\"\"\"\n    __tablename__ = 'users'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True, nullable=False, index=True)\n    username: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    first_name: Mapped[str] = mapped_column(String(255), nullable=False)\n    last_name: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    phone_number: Mapped[Optional[str]] = mapped_column(String(20), nullable=True)\n    customer_code: Mapped[Optional[str]] = mapped_column(String(50), unique=True, nullable=True, index=True)\n    \n    # Preferences\n    language_code: Mapped[str] = mapped_column(String(5), nullable=False, default='ar')\n    country_code: Mapped[str] = mapped_column(String(5), nullable=False, default='SA')\n    notifications_enabled: Mapped[bool] = mapped_column(Boolean, default=True)\n    \n    # Status\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    is_banned: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_admin: Mapped[bool] = mapped_column(Boolean, default=False)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    last_activity: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    outbox_messages = relationship(\"Outbox\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    announcement_deliveries = relationship(\"AnnouncementDelivery\", back_populates=\"user\", cascade=\"all, delete-orphan\")\n    \n    def __repr__(self):\n        return f\"<User(id={self.id}, telegram_id={self.telegram_id}, username={self.username})>\"\n\nclass Language(Base):\n    \"\"\"Language model for multi-language support\"\"\"\n    __tablename__ = 'languages'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    code: Mapped[str] = mapped_column(String(5), unique=True, nullable=False, index=True)\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    native_name: Mapped[str] = mapped_column(String(100), nullable=False)\n    rtl: Mapped[bool] = mapped_column(Boolean, default=False)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    \n    def __repr__(self):\n        return f\"<Language(code={self.code}, name={self.name})>\"\n\nclass Country(Base):\n    \"\"\"Country model for regional settings\"\"\"\n    __tablename__ = 'countries'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    code: Mapped[str] = mapped_column(String(5), unique=True, nullable=False, index=True)\n    name: Mapped[str] = mapped_column(String(100), nullable=False)\n    native_name: Mapped[str] = mapped_column(String(100), nullable=False)\n    phone_prefix: Mapped[str] = mapped_column(String(10), nullable=False)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    \n    def __repr__(self):\n        return f\"<Country(code={self.code}, name={self.name})>\"\n\nclass Announcement(Base):\n    \"\"\"Announcement model for system announcements\"\"\"\n    __tablename__ = 'announcements'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    title_ar: Mapped[str] = mapped_column(String(255), nullable=False)\n    title_en: Mapped[str] = mapped_column(String(255), nullable=False)\n    content_ar: Mapped[str] = mapped_column(Text, nullable=False)\n    content_en: Mapped[str] = mapped_column(Text, nullable=False)\n    image_url: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)\n    \n    # Display settings\n    display_duration: Mapped[int] = mapped_column(Integer, default=0)  # 0 = permanent\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n    priority: Mapped[int] = mapped_column(Integer, default=0)\n    \n    # Filtering\n    target_language: Mapped[Optional[str]] = mapped_column(String(5), nullable=True)\n    target_country: Mapped[Optional[str]] = mapped_column(String(5), nullable=True)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    scheduled_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    expires_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    \n    # Relationships\n    deliveries = relationship(\"AnnouncementDelivery\", back_populates=\"announcement\", cascade=\"all, delete-orphan\")\n    \n    def __repr__(self):\n        return f\"<Announcement(id={self.id}, title_ar={self.title_ar[:50]})>\"\n\nclass AnnouncementDelivery(Base):\n    \"\"\"Track announcement delivery to users\"\"\"\n    __tablename__ = 'announcement_deliveries'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    announcement_id: Mapped[int] = mapped_column(Integer, ForeignKey('announcements.id'), nullable=False)\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id'), nullable=False)\n    \n    status: Mapped[DeliveryStatus] = mapped_column(Enum(DeliveryStatus), default=DeliveryStatus.PENDING)\n    delivered_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    read_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    \n    # Relationships\n    announcement = relationship(\"Announcement\", back_populates=\"deliveries\")\n    user = relationship(\"User\", back_populates=\"announcement_deliveries\")\n    \n    # Unique constraint\n    __table_args__ = (UniqueConstraint('announcement_id', 'user_id', name='uq_announcement_user'),)\n    \n    def __repr__(self):\n        return f\"<AnnouncementDelivery(announcement_id={self.announcement_id}, user_id={self.user_id}, status={self.status})>\"\n\nclass Outbox(Base):\n    \"\"\"Outbox for user requests and system messages\"\"\"\n    __tablename__ = 'outbox'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id'), nullable=False)\n    type: Mapped[OutboxType] = mapped_column(Enum(OutboxType), nullable=False)\n    status: Mapped[OutboxStatus] = mapped_column(Enum(OutboxStatus), default=OutboxStatus.PENDING)\n    \n    # Content\n    subject: Mapped[Optional[str]] = mapped_column(String(255), nullable=True)\n    content: Mapped[str] = mapped_column(Text, nullable=False)\n    attachment_url: Mapped[Optional[str]] = mapped_column(String(500), nullable=True)\n    \n    # Processing\n    processed_by: Mapped[Optional[int]] = mapped_column(BigInteger, nullable=True)  # Admin telegram_id\n    processed_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    admin_comment: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    \n    # Timestamps\n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))\n    \n    # Relationships\n    user = relationship(\"User\", back_populates=\"outbox_messages\")\n    recipients = relationship(\"OutboxRecipient\", back_populates=\"outbox\", cascade=\"all, delete-orphan\")\n    \n    # Indexes\n    __table_args__ = (\n        Index('idx_outbox_type_status', 'type', 'status'),\n        Index('idx_outbox_created', 'created_at'),\n    )\n    \n    def __repr__(self):\n        return f\"<Outbox(id={self.id}, type={self.type}, status={self.status})>\"\n\nclass OutboxRecipient(Base):\n    \"\"\"Track individual message recipients for broadcasts\"\"\"\n    __tablename__ = 'outbox_recipients'\n    \n    id: Mapped[int] = mapped_column(Integer, primary_key=True, autoincrement=True)\n    outbox_id: Mapped[int] = mapped_column(Integer, ForeignKey('outbox.id'), nullable=False)\n    user_id: Mapped[int] = mapped_column(Integer, ForeignKey('users.id'), nullable=False)\n    \n    status: Mapped[DeliveryStatus] = mapped_column(Enum(DeliveryStatus), default=DeliveryStatus.PENDING)\n    attempts: Mapped[int] = mapped_column(Integer, default=0)\n    last_attempt: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    delivered_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), nullable=True)\n    error_message: Mapped[Optional[str]] = mapped_column(Text, nullable=True)\n    \n    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))\n    \n    # Relationships\n    outbox = relationship(\"Outbox\", back_populates=\"recipients\")\n    \n    # Unique constraint\n    __table_args__ = (UniqueConstraint('outbox_id', 'user_id', name='uq_outbox_user'),)\n    \n    def __repr__(self):\n        return f\"<OutboxRecipient(outbox_id={self.outbox_id}, user_id={self.user_id}, status={self.status})>\"\n","size_bytes":11331},"handlers/admin.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAdmin handler for administrative functions\nHandles admin panel, user management, language/country management\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func, desc\n\nfrom models import User, Language, Country, Outbox, OutboxType, OutboxStatus\nfrom services.i18n import get_text, get_user_language\nfrom utils.auth import admin_required\nfrom utils.keyboards import (\n    get_admin_panel_keyboard, get_admin_users_keyboard,\n    get_admin_languages_keyboard, get_admin_countries_keyboard,\n    get_user_management_keyboard, get_pagination_keyboard\n)\nfrom config import USERS_PER_PAGE\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass AdminStates(StatesGroup):\n    managing_user = State()\n    adding_language = State()\n    adding_country = State()\n    viewing_outbox = State()\n\n@router.message(Command(\"admin\"))\n@admin_required\nasync def show_admin_panel(message: Message, session_maker):\n    \"\"\"Show admin panel\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get statistics\n            total_users = await session.scalar(select(func.count(User.id)))\n            active_users = await session.scalar(\n                select(func.count(User.id)).where(User.is_active == True)\n            )\n            pending_requests = await session.scalar(\n                select(func.count(Outbox.id)).where(Outbox.status == OutboxStatus.PENDING)\n            )\n            \n            admin_text = get_text(\"admin_panel\", \"ar\").format(\n                total_users=total_users,\n                active_users=active_users,\n                pending_requests=pending_requests\n            )\n            \n            await message.answer(\n                admin_text,\n                reply_markup=get_admin_panel_keyboard(\"ar\")\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error showing admin panel: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_users\")\n@admin_required\nasync def show_users_list(callback: CallbackQuery, session_maker):\n    \"\"\"Show users list with pagination\"\"\"\n    await show_users_page(callback, session_maker, 0)\n\n@router.callback_query(F.data.startswith(\"admin_users_page_\"))\n@admin_required\nasync def show_users_page(callback: CallbackQuery, session_maker, page: int = None):\n    \"\"\"Show specific page of users\"\"\"\n    async with session_maker() as session:\n        try:\n            if page is None:\n                page = int(callback.data.split(\"_\")[-1])\n            \n            offset = page * USERS_PER_PAGE\n            \n            # Get users with pagination\n            result = await session.execute(\n                select(User)\n                .order_by(desc(User.created_at))\n                .offset(offset)\n                .limit(USERS_PER_PAGE)\n            )\n            users = result.scalars().all()\n            \n            # Get total count for pagination\n            total_users = await session.scalar(select(func.count(User.id)))\n            total_pages = (total_users + USERS_PER_PAGE - 1) // USERS_PER_PAGE\n            \n            if not users:\n                await callback.message.edit_text(\n                    get_text(\"no_users_found\", \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format users list\n            users_text = get_text(\"users_list_header\", \"ar\").format(\n                page=page + 1,\n                total_pages=total_pages,\n                total_users=total_users\n            )\n            \n            for user in users:\n                status = \"🟢\" if user.is_active else \"🔴\"\n                banned = \"🚫\" if user.is_banned else \"\"\n                admin_mark = \"👑\" if user.is_admin else \"\"\n                \n                users_text += f\"\\n\\n{status} {admin_mark} {banned}\\n\"\n                users_text += f\"ID: {user.telegram_id}\\n\"\n                users_text += f\"Name: {user.first_name}\"\n                if user.last_name:\n                    users_text += f\" {user.last_name}\"\n                if user.username:\n                    users_text += f\" (@{user.username})\"\n                users_text += f\"\\nCustomer: {user.customer_code or 'N/A'}\"\n                users_text += f\"\\nLang: {user.language_code} | Country: {user.country_code}\"\n                users_text += f\"\\nJoined: {user.created_at.strftime('%Y-%m-%d')}\"\n            \n            keyboard = get_pagination_keyboard(\"admin_users\", page, total_pages, \"ar\")\n            \n            await callback.message.edit_text(\n                users_text,\n                reply_markup=keyboard\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing users page: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_languages\")\n@admin_required\nasync def show_languages_management(callback: CallbackQuery, session_maker):\n    \"\"\"Show languages management\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get all languages\n            result = await session.execute(\n                select(Language).order_by(Language.name)\n            )\n            languages = result.scalars().all()\n            \n            if not languages:\n                await callback.message.edit_text(\n                    get_text(\"no_languages_found\", \"ar\"),\n                    reply_markup=get_admin_languages_keyboard([], \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format languages list\n            languages_text = get_text(\"languages_list\", \"ar\")\n            \n            for lang in languages:\n                status = \"✅\" if lang.is_active else \"❌\"\n                rtl_mark = \"🔄\" if lang.rtl else \"\"\n                \n                languages_text += f\"\\n\\n{status} {rtl_mark}\\n\"\n                languages_text += f\"Code: {lang.code}\\n\"\n                languages_text += f\"Name: {lang.name}\\n\"\n                languages_text += f\"Native: {lang.native_name}\\n\"\n                languages_text += f\"RTL: {'Yes' if lang.rtl else 'No'}\\n\"\n                languages_text += f\"Created: {lang.created_at.strftime('%Y-%m-%d')}\"\n            \n            await callback.message.edit_text(\n                languages_text,\n                reply_markup=get_admin_languages_keyboard(languages, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing languages: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_countries\")\n@admin_required\nasync def show_countries_management(callback: CallbackQuery, session_maker):\n    \"\"\"Show countries management\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get all countries\n            result = await session.execute(\n                select(Country).order_by(Country.name)\n            )\n            countries = result.scalars().all()\n            \n            if not countries:\n                await callback.message.edit_text(\n                    get_text(\"no_countries_found\", \"ar\"),\n                    reply_markup=get_admin_countries_keyboard([], \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format countries list\n            countries_text = get_text(\"countries_list\", \"ar\")\n            \n            for country in countries:\n                status = \"✅\" if country.is_active else \"❌\"\n                \n                countries_text += f\"\\n\\n{status}\\n\"\n                countries_text += f\"Code: {country.code}\\n\"\n                countries_text += f\"Name: {country.name}\\n\"\n                countries_text += f\"Native: {country.native_name}\\n\"\n                countries_text += f\"Phone: {country.phone_prefix}\\n\"\n                countries_text += f\"Created: {country.created_at.strftime('%Y-%m-%d')}\"\n            \n            await callback.message.edit_text(\n                countries_text,\n                reply_markup=get_admin_countries_keyboard(countries, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing countries: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_outbox\")\n@admin_required\nasync def show_outbox_management(callback: CallbackQuery, session_maker):\n    \"\"\"Show outbox/requests management\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get pending requests\n            result = await session.execute(\n                select(Outbox)\n                .where(Outbox.status == OutboxStatus.PENDING)\n                .order_by(desc(Outbox.created_at))\n                .limit(10)\n            )\n            requests = result.scalars().all()\n            \n            if not requests:\n                await callback.message.edit_text(\n                    get_text(\"no_pending_requests\", \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format requests list\n            requests_text = get_text(\"pending_requests_header\", \"ar\")\n            \n            for req in requests:\n                type_emoji = {\n                    OutboxType.DEPOSIT: \"💰\",\n                    OutboxType.WITHDRAWAL: \"💸\", \n                    OutboxType.COMPLAINT: \"📨\",\n                    OutboxType.SUPPORT: \"🆘\"\n                }.get(req.type, \"📄\")\n                \n                requests_text += f\"\\n\\n{type_emoji} ID: {req.id}\\n\"\n                requests_text += f\"Type: {req.type.value.title()}\\n\"\n                requests_text += f\"User ID: {req.user_id}\\n\"\n                if req.subject:\n                    requests_text += f\"Subject: {req.subject}\\n\"\n                requests_text += f\"Content: {req.content[:100]}...\\n\" if len(req.content) > 100 else f\"Content: {req.content}\\n\"\n                requests_text += f\"Created: {req.created_at.strftime('%Y-%m-%d %H:%M')}\"\n            \n            await callback.message.edit_text(requests_text)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing outbox: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"toggle_lang_\"))\n@admin_required\nasync def toggle_language_status(callback: CallbackQuery, session_maker):\n    \"\"\"Toggle language active status\"\"\"\n    async with session_maker() as session:\n        try:\n            lang_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get language\n            result = await session.execute(\n                select(Language).where(Language.id == lang_id)\n            )\n            language = result.scalar_one_or_none()\n            \n            if not language:\n                await callback.answer(get_text(\"language_not_found\", \"ar\"))\n                return\n            \n            # Toggle status\n            language.is_active = not language.is_active\n            language.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            status = \"activated\" if language.is_active else \"deactivated\"\n            await callback.answer(f\"Language {language.name} {status}\")\n            \n            # Refresh the languages list\n            await show_languages_management(callback, session_maker)\n            \n        except Exception as e:\n            logger.error(f\"Error toggling language: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"toggle_country_\"))\n@admin_required\nasync def toggle_country_status(callback: CallbackQuery, session_maker):\n    \"\"\"Toggle country active status\"\"\"\n    async with session_maker() as session:\n        try:\n            country_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get country\n            result = await session.execute(\n                select(Country).where(Country.id == country_id)\n            )\n            country = result.scalar_one_or_none()\n            \n            if not country:\n                await callback.answer(get_text(\"country_not_found\", \"ar\"))\n                return\n            \n            # Toggle status\n            country.is_active = not country.is_active\n            country.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            status = \"activated\" if country.is_active else \"deactivated\"\n            await callback.answer(f\"Country {country.name} {status}\")\n            \n            # Refresh the countries list\n            await show_countries_management(callback, session_maker)\n            \n        except Exception as e:\n            logger.error(f\"Error toggling country: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"back_to_admin\")\n@admin_required\nasync def back_to_admin_panel(callback: CallbackQuery, session_maker):\n    \"\"\"Go back to admin panel\"\"\"\n    await show_admin_panel(callback.message, session_maker)\n    await callback.answer()\n","size_bytes":13605},"handlers/announcements.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAnnouncements handler for system announcements\nHandles announcement creation, scheduling, and delivery\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone, timedelta\nfrom aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\n\nfrom models import Announcement, AnnouncementDelivery, User\nfrom services.i18n import get_text\nfrom utils.auth import admin_required\nfrom utils.keyboards import (\n    get_announcement_menu_keyboard, get_announcement_targeting_keyboard,\n    get_announcement_duration_keyboard, get_announcement_confirmation_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass AnnouncementStates(StatesGroup):\n    entering_title_ar = State()\n    entering_title_en = State()\n    entering_content_ar = State()\n    entering_content_en = State()\n    adding_image = State()\n    selecting_target = State()\n    setting_duration = State()\n    confirming = State()\n\n@router.message(F.text == \"/announce_new\")\n@admin_required\nasync def start_announcement_creation(message: Message, state: FSMContext):\n    \"\"\"Start announcement creation process\"\"\"\n    await message.answer(\n        get_text(\"announcement_enter_title_ar\", \"ar\")\n    )\n    await state.set_state(AnnouncementStates.entering_title_ar)\n\n@router.message(AnnouncementStates.entering_title_ar)\n@admin_required\nasync def receive_title_arabic(message: Message, state: FSMContext):\n    \"\"\"Receive Arabic title\"\"\"\n    title_ar = message.text.strip()\n    \n    if not title_ar:\n        await message.answer(get_text(\"title_required\", \"ar\"))\n        return\n    \n    await state.update_data(title_ar=title_ar)\n    await message.answer(get_text(\"announcement_enter_title_en\", \"ar\"))\n    await state.set_state(AnnouncementStates.entering_title_en)\n\n@router.message(AnnouncementStates.entering_title_en)\n@admin_required\nasync def receive_title_english(message: Message, state: FSMContext):\n    \"\"\"Receive English title\"\"\"\n    title_en = message.text.strip()\n    \n    if not title_en:\n        await message.answer(get_text(\"title_required\", \"ar\"))\n        return\n    \n    await state.update_data(title_en=title_en)\n    await message.answer(get_text(\"announcement_enter_content_ar\", \"ar\"))\n    await state.set_state(AnnouncementStates.entering_content_ar)\n\n@router.message(AnnouncementStates.entering_content_ar)\n@admin_required\nasync def receive_content_arabic(message: Message, state: FSMContext):\n    \"\"\"Receive Arabic content\"\"\"\n    content_ar = message.text.strip()\n    \n    if not content_ar:\n        await message.answer(get_text(\"content_required\", \"ar\"))\n        return\n    \n    await state.update_data(content_ar=content_ar)\n    await message.answer(get_text(\"announcement_enter_content_en\", \"ar\"))\n    await state.set_state(AnnouncementStates.entering_content_en)\n\n@router.message(AnnouncementStates.entering_content_en)\n@admin_required\nasync def receive_content_english(message: Message, state: FSMContext):\n    \"\"\"Receive English content\"\"\"\n    content_en = message.text.strip()\n    \n    if not content_en:\n        await message.answer(get_text(\"content_required\", \"ar\"))\n        return\n    \n    await state.update_data(content_en=content_en)\n    \n    # Ask for optional image\n    await message.answer(\n        get_text(\"announcement_add_image_optional\", \"ar\"),\n        reply_markup=get_announcement_menu_keyboard(\"ar\")\n    )\n    await state.set_state(AnnouncementStates.adding_image)\n\n@router.callback_query(AnnouncementStates.adding_image, F.data == \"skip_image\")\n@admin_required\nasync def skip_image(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Skip image and proceed to targeting\"\"\"\n    await callback.message.edit_text(\n        get_text(\"announcement_select_target\", \"ar\"),\n        reply_markup=get_announcement_targeting_keyboard(\"ar\")\n    )\n    await state.set_state(AnnouncementStates.selecting_target)\n    await callback.answer()\n\n@router.message(AnnouncementStates.adding_image, F.photo)\n@admin_required\nasync def receive_announcement_image(message: Message, state: FSMContext):\n    \"\"\"Receive announcement image\"\"\"\n    try:\n        # Get the largest photo\n        photo = message.photo[-1]\n        file_id = photo.file_id\n        \n        await state.update_data(image_file_id=file_id)\n        \n        await message.answer(\n            get_text(\"image_added_successfully\", \"ar\"),\n            reply_markup=get_announcement_targeting_keyboard(\"ar\")\n        )\n        await state.set_state(AnnouncementStates.selecting_target)\n        \n    except Exception as e:\n        logger.error(f\"Error receiving image: {e}\")\n        await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.selecting_target, F.data == \"announce_all\")\n@admin_required\nasync def target_all_users(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Target all users for announcement\"\"\"\n    async with session_maker() as session:\n        try:\n            total_users = await session.scalar(\n                select(func.count(User.id)).where(User.is_active == True)\n            )\n            \n            await state.update_data(target_type=\"all\", target_value=None)\n            \n            await callback.message.edit_text(\n                get_text(\"announcement_set_duration\", \"ar\").format(\n                    target=f\"All users ({total_users})\"\n                ),\n                reply_markup=get_announcement_duration_keyboard(\"ar\")\n            )\n            await state.set_state(AnnouncementStates.setting_duration)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error targeting all users: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.selecting_target, F.data == \"announce_by_language\")\n@admin_required\nasync def target_by_language(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Target by language selection (simplified - you can expand this)\"\"\"\n    await state.update_data(target_type=\"language\", target_value=\"ar\")  # Default to Arabic\n    \n    await callback.message.edit_text(\n        get_text(\"announcement_set_duration\", \"ar\").format(\n            target=\"Arabic speakers\"\n        ),\n        reply_markup=get_announcement_duration_keyboard(\"ar\")\n    )\n    await state.set_state(AnnouncementStates.setting_duration)\n    await callback.answer()\n\n@router.callback_query(AnnouncementStates.setting_duration, F.data.startswith(\"duration_\"))\n@admin_required\nasync def set_announcement_duration(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Set announcement duration\"\"\"\n    duration_str = callback.data.split(\"_\")[1]\n    \n    # Convert duration to hours\n    duration_mapping = {\n        \"1h\": 1,\n        \"6h\": 6,\n        \"24h\": 24,\n        \"7d\": 168,  # 7 days in hours\n        \"permanent\": 0  # 0 means permanent\n    }\n    \n    duration_hours = duration_mapping.get(duration_str, 0)\n    await state.update_data(duration_hours=duration_hours)\n    \n    # Show confirmation\n    await show_announcement_confirmation(callback, state)\n\nasync def show_announcement_confirmation(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Show announcement confirmation\"\"\"\n    try:\n        data = await state.get_data()\n        \n        duration_text = \"\"\n        if data[\"duration_hours\"] == 0:\n            duration_text = \"Permanent\"\n        else:\n            duration_text = f\"{data['duration_hours']} hours\"\n        \n        target_text = \"\"\n        if data[\"target_type\"] == \"all\":\n            target_text = \"All active users\"\n        elif data[\"target_type\"] == \"language\":\n            target_text = f\"Language: {data.get('target_value', 'N/A')}\"\n        \n        confirmation_text = get_text(\"announcement_confirmation\", \"ar\").format(\n            title_ar=data[\"title_ar\"],\n            title_en=data[\"title_en\"],\n            content_ar=data[\"content_ar\"][:100] + \"...\" if len(data[\"content_ar\"]) > 100 else data[\"content_ar\"],\n            content_en=data[\"content_en\"][:100] + \"...\" if len(data[\"content_en\"]) > 100 else data[\"content_en\"],\n            target=target_text,\n            duration=duration_text,\n            has_image=\"Yes\" if data.get(\"image_file_id\") else \"No\"\n        )\n        \n        await callback.message.edit_text(\n            confirmation_text,\n            reply_markup=get_announcement_confirmation_keyboard(\"ar\")\n        )\n        await state.set_state(AnnouncementStates.confirming)\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error showing confirmation: {e}\")\n        await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.confirming, F.data == \"confirm_announcement\")\n@admin_required\nasync def confirm_announcement(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Confirm and create announcement\"\"\"\n    async with session_maker() as session:\n        try:\n            data = await state.get_data()\n            \n            # Calculate expiration time\n            expires_at = None\n            if data[\"duration_hours\"] > 0:\n                expires_at = datetime.now(timezone.utc) + timedelta(hours=data[\"duration_hours\"])\n            \n            # Create announcement\n            announcement = Announcement(\n                title_ar=data[\"title_ar\"],\n                title_en=data[\"title_en\"],\n                content_ar=data[\"content_ar\"],\n                content_en=data[\"content_en\"],\n                image_url=data.get(\"image_file_id\"),  # Store file_id as URL for simplicity\n                display_duration=data[\"duration_hours\"],\n                target_language=data.get(\"target_value\") if data[\"target_type\"] == \"language\" else None,\n                expires_at=expires_at,\n                scheduled_at=datetime.now(timezone.utc)\n            )\n            \n            session.add(announcement)\n            await session.flush()  # Get the ID\n            \n            # Create delivery records for target users\n            if data[\"target_type\"] == \"all\":\n                # Get all active users\n                result = await session.execute(\n                    select(User.id).where(User.is_active == True)\n                )\n                user_ids = [row[0] for row in result.fetchall()]\n            elif data[\"target_type\"] == \"language\":\n                # Get users by language\n                result = await session.execute(\n                    select(User.id).where(\n                        User.is_active == True,\n                        User.language_code == data[\"target_value\"]\n                    )\n                )\n                user_ids = [row[0] for row in result.fetchall()]\n            else:\n                user_ids = []\n            \n            # Create delivery records\n            for user_id in user_ids:\n                delivery = AnnouncementDelivery(\n                    announcement_id=announcement.id,\n                    user_id=user_id\n                )\n                session.add(delivery)\n            \n            await session.commit()\n            \n            await callback.message.edit_text(\n                get_text(\"announcement_created\", \"ar\").format(\n                    announcement_id=announcement.id,\n                    target_count=len(user_ids)\n                )\n            )\n            \n            await state.clear()\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error creating announcement: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.confirming, F.data == \"cancel_announcement\")\n@admin_required\nasync def cancel_announcement(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Cancel announcement creation\"\"\"\n    await callback.message.edit_text(\n        get_text(\"announcement_cancelled\", \"ar\")\n    )\n    await state.clear()\n    await callback.answer()\n","size_bytes":12080},"handlers/broadcast.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBroadcast handler for mass messaging\nHandles broadcast creation, targeting, and delivery management\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery, InputMediaPhoto\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\n\nfrom models import User, Outbox, OutboxType, OutboxStatus, Language, Country\nfrom services.i18n import get_text\nfrom utils.auth import admin_required\nfrom utils.keyboards import (\n    get_broadcast_targeting_keyboard, get_broadcast_confirmation_keyboard,\n    get_language_filter_keyboard, get_country_filter_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass BroadcastStates(StatesGroup):\n    selecting_target = State()\n    entering_message = State()\n    adding_media = State()\n    confirming = State()\n\n@router.message(F.text == \"/broadcast\")\n@admin_required\nasync def start_broadcast(message: Message, state: FSMContext, session_maker):\n    \"\"\"Start broadcast creation process\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get statistics for targeting options\n            total_users = await session.scalar(\n                select(func.count(User.id)).where(User.is_active == True)\n            )\n            \n            # Get language distribution\n            lang_result = await session.execute(\n                select(User.language_code, func.count(User.id))\n                .where(User.is_active == True)\n                .group_by(User.language_code)\n            )\n            lang_stats = dict(lang_result.fetchall())\n            \n            # Get country distribution\n            country_result = await session.execute(\n                select(User.country_code, func.count(User.id))\n                .where(User.is_active == True)\n                .group_by(User.country_code)\n            )\n            country_stats = dict(country_result.fetchall())\n            \n            # Format targeting options\n            stats_text = get_text(\"broadcast_targeting_stats\", \"ar\").format(\n                total_users=total_users,\n                lang_stats=\", \".join([f\"{k}: {v}\" for k, v in lang_stats.items()]),\n                country_stats=\", \".join([f\"{k}: {v}\" for k, v in country_stats.items()])\n            )\n            \n            await message.answer(\n                stats_text,\n                reply_markup=get_broadcast_targeting_keyboard(\"ar\")\n            )\n            \n            await state.set_state(BroadcastStates.selecting_target)\n            await state.update_data(\n                total_users=total_users,\n                lang_stats=lang_stats,\n                country_stats=country_stats\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error starting broadcast: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.selecting_target, F.data == \"broadcast_all\")\n@admin_required\nasync def select_broadcast_all(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Select broadcast to all users\"\"\"\n    await state.update_data(target_type=\"all\")\n    await callback.message.edit_text(\n        get_text(\"broadcast_enter_message\", \"ar\")\n    )\n    await state.set_state(BroadcastStates.entering_message)\n    await callback.answer()\n\n@router.callback_query(BroadcastStates.selecting_target, F.data == \"broadcast_by_language\")\n@admin_required\nasync def select_broadcast_by_language(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Select broadcast by language\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get available languages with user counts\n            result = await session.execute(\n                select(Language.code, Language.native_name, func.count(User.id))\n                .join(User, User.language_code == Language.code)\n                .where(Language.is_active == True, User.is_active == True)\n                .group_by(Language.code, Language.native_name)\n            )\n            languages = result.fetchall()\n            \n            if not languages:\n                await callback.answer(get_text(\"no_languages_with_users\", \"ar\"))\n                return\n            \n            await callback.message.edit_text(\n                get_text(\"select_target_language\", \"ar\"),\n                reply_markup=get_language_filter_keyboard(languages, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing language selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.selecting_target, F.data == \"broadcast_by_country\")\n@admin_required\nasync def select_broadcast_by_country(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Select broadcast by country\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get available countries with user counts\n            result = await session.execute(\n                select(Country.code, Country.native_name, func.count(User.id))\n                .join(User, User.country_code == Country.code)\n                .where(Country.is_active == True, User.is_active == True)\n                .group_by(Country.code, Country.native_name)\n            )\n            countries = result.fetchall()\n            \n            if not countries:\n                await callback.answer(get_text(\"no_countries_with_users\", \"ar\"))\n                return\n            \n            await callback.message.edit_text(\n                get_text(\"select_target_country\", \"ar\"),\n                reply_markup=get_country_filter_keyboard(countries, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing country selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.selecting_target, F.data.startswith(\"lang_filter_\"))\n@admin_required\nasync def select_language_filter(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select specific language for broadcast\"\"\"\n    language_code = callback.data.split(\"_\")[-1]\n    await state.update_data(target_type=\"language\", target_value=language_code)\n    \n    await callback.message.edit_text(\n        get_text(\"broadcast_enter_message\", \"ar\").format(\n            target=f\"Language: {language_code.upper()}\"\n        )\n    )\n    await state.set_state(BroadcastStates.entering_message)\n    await callback.answer()\n\n@router.callback_query(BroadcastStates.selecting_target, F.data.startswith(\"country_filter_\"))\n@admin_required\nasync def select_country_filter(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select specific country for broadcast\"\"\"\n    country_code = callback.data.split(\"_\")[-1]\n    await state.update_data(target_type=\"country\", target_value=country_code)\n    \n    await callback.message.edit_text(\n        get_text(\"broadcast_enter_message\", \"ar\").format(\n            target=f\"Country: {country_code.upper()}\"\n        )\n    )\n    await state.set_state(BroadcastStates.entering_message)\n    await callback.answer()\n\n@router.message(BroadcastStates.entering_message)\n@admin_required\nasync def receive_broadcast_message(message: Message, state: FSMContext):\n    \"\"\"Receive broadcast message text\"\"\"\n    try:\n        broadcast_text = message.text or message.caption or \"\"\n        \n        if not broadcast_text.strip():\n            await message.answer(get_text(\"broadcast_message_required\", \"ar\"))\n            return\n        \n        # Store message data\n        await state.update_data(\n            message_text=broadcast_text,\n            message_entities=message.entities,\n            message_type=\"text\"\n        )\n        \n        # Check if message has media\n        if message.photo or message.video or message.document:\n            if message.photo:\n                file_id = message.photo[-1].file_id\n                await state.update_data(message_type=\"photo\", file_id=file_id)\n            elif message.video:\n                await state.update_data(message_type=\"video\", file_id=message.video.file_id)\n            elif message.document:\n                await state.update_data(message_type=\"document\", file_id=message.document.file_id)\n        \n        # Show confirmation\n        await show_broadcast_confirmation(message, state)\n        \n    except Exception as e:\n        logger.error(f\"Error receiving broadcast message: {e}\")\n        await message.answer(get_text(\"error_occurred\", \"ar\"))\n\nasync def show_broadcast_confirmation(message: Message, state: FSMContext):\n    \"\"\"Show broadcast confirmation with preview\"\"\"\n    try:\n        data = await state.get_data()\n        \n        # Calculate target audience\n        target_info = \"\"\n        if data[\"target_type\"] == \"all\":\n            target_info = f\"All active users ({data.get('total_users', '?')} users)\"\n        elif data[\"target_type\"] == \"language\":\n            lang_code = data[\"target_value\"]\n            user_count = data.get(\"lang_stats\", {}).get(lang_code, \"?\")\n            target_info = f\"Language: {lang_code.upper()} ({user_count} users)\"\n        elif data[\"target_type\"] == \"country\":\n            country_code = data[\"target_value\"]\n            user_count = data.get(\"country_stats\", {}).get(country_code, \"?\")\n            target_info = f\"Country: {country_code.upper()} ({user_count} users)\"\n        \n        confirmation_text = get_text(\"broadcast_confirmation\", \"ar\").format(\n            target=target_info,\n            message_preview=data[\"message_text\"][:200] + \"...\" if len(data[\"message_text\"]) > 200 else data[\"message_text\"]\n        )\n        \n        await message.answer(\n            confirmation_text,\n            reply_markup=get_broadcast_confirmation_keyboard(\"ar\")\n        )\n        \n        await state.set_state(BroadcastStates.confirming)\n        \n    except Exception as e:\n        logger.error(f\"Error showing confirmation: {e}\")\n        await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.confirming, F.data == \"confirm_broadcast\")\n@admin_required\nasync def confirm_broadcast(callback: CallbackQuery, state: FSMContext, session_maker, broadcast_service):\n    \"\"\"Confirm and start broadcast\"\"\"\n    async with session_maker() as session:\n        try:\n            data = await state.get_data()\n            \n            # Create outbox entry for broadcast\n            outbox = Outbox(\n                user_id=1,  # System user for broadcasts\n                type=OutboxType.BROADCAST,\n                status=OutboxStatus.PROCESSING,\n                subject=f\"Broadcast to {data['target_type']}\",\n                content=data[\"message_text\"]\n            )\n            session.add(outbox)\n            await session.flush()\n            \n            # Queue broadcast for delivery\n            await broadcast_service.queue_broadcast(\n                outbox_id=outbox.id,\n                target_type=data[\"target_type\"],\n                target_value=data.get(\"target_value\"),\n                message_text=data[\"message_text\"],\n                message_type=data.get(\"message_type\", \"text\"),\n                file_id=data.get(\"file_id\"),\n                message_entities=data.get(\"message_entities\")\n            )\n            \n            await session.commit()\n            \n            await callback.message.edit_text(\n                get_text(\"broadcast_queued\", \"ar\").format(\n                    broadcast_id=outbox.id\n                )\n            )\n            \n            await state.clear()\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error confirming broadcast: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.confirming, F.data == \"cancel_broadcast\")\n@admin_required\nasync def cancel_broadcast(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Cancel broadcast\"\"\"\n    await callback.message.edit_text(\n        get_text(\"broadcast_cancelled\", \"ar\")\n    )\n    await state.clear()\n    await callback.answer()\n","size_bytes":12292},"handlers/start.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nStart handler for user registration, phone verification, and main menu\nHandles /start command, phone number collection, and customer code generation\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.filters import Command, CommandStart\nfrom aiogram.types import Message, CallbackQuery, Contact\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom models import User\nfrom services.i18n import get_text, get_user_language\nfrom services.customer_id import generate_customer_code\nfrom utils.keyboards import (\n    get_main_menu_keyboard, get_phone_share_keyboard, \n    get_contact_confirmation_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass RegistrationStates(StatesGroup):\n    waiting_for_phone = State()\n    confirming_phone = State()\n\n@router.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext, session_maker):\n    \"\"\"Handle /start command and user registration\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get or create user\n            user = await get_or_create_user(session, message.from_user)\n            await session.commit()\n            \n            # Get user's language for responses\n            lang = get_user_language(user.language_code)\n            \n            if not user.phone_number:\n                # First time user - request phone number\n                await message.answer(\n                    get_text(\"welcome_new_user\", lang).format(\n                        first_name=user.first_name\n                    ),\n                    reply_markup=get_phone_share_keyboard(lang)\n                )\n                await state.set_state(RegistrationStates.waiting_for_phone)\n            else:\n                # Returning user - show main menu\n                await show_main_menu(message, user, session)\n                \n        except Exception as e:\n            logger.error(f\"Error in start command: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(RegistrationStates.waiting_for_phone, F.contact)\nasync def handle_phone_contact(message: Message, state: FSMContext, session_maker):\n    \"\"\"Handle phone number shared via contact\"\"\"\n    async with session_maker() as session:\n        try:\n            contact: Contact = message.contact\n            \n            # Verify it's the user's own contact\n            if contact.user_id != message.from_user.id:\n                user = await get_user_by_telegram_id(session, message.from_user.id)\n                lang = get_user_language(user.language_code if user else \"ar\")\n                await message.answer(get_text(\"phone_must_be_yours\", lang))\n                return\n            \n            # Update user with phone number\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if user:\n                user.phone_number = contact.phone_number\n                user.updated_at = datetime.now(timezone.utc)\n                \n                # Generate customer code if not exists\n                if not user.customer_code:\n                    user.customer_code = await generate_customer_code(session)\n                \n                await session.commit()\n                \n                lang = get_user_language(user.language_code)\n                \n                # Show confirmation\n                await message.answer(\n                    get_text(\"phone_registered_success\", lang).format(\n                        phone=contact.phone_number,\n                        customer_code=user.customer_code\n                    ),\n                    reply_markup=get_contact_confirmation_keyboard(lang)\n                )\n                \n                await state.set_state(RegistrationStates.confirming_phone)\n            \n        except Exception as e:\n            logger.error(f\"Error handling phone contact: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(RegistrationStates.confirming_phone, F.data == \"confirm_phone\")\nasync def confirm_phone_registration(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Confirm phone registration and show main menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if user:\n                await callback.answer()\n                await callback.message.delete()\n                await show_main_menu(callback.message, user, session)\n                await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error confirming phone: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"💰 إيداع\", \"💰 Deposit\"]))\nasync def handle_deposit(message: Message, session_maker):\n    \"\"\"Handle deposit request\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            await message.answer(get_text(\"deposit_instructions\", lang))\n            \n        except Exception as e:\n            logger.error(f\"Error handling deposit: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"💸 سحب\", \"💸 Withdraw\"]))\nasync def handle_withdraw(message: Message, session_maker):\n    \"\"\"Handle withdrawal request\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            await message.answer(get_text(\"withdraw_instructions\", lang))\n            \n        except Exception as e:\n            logger.error(f\"Error handling withdraw: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"📨 شكاوى\", \"📨 Complaints\"]))\nasync def handle_complaints(message: Message, session_maker):\n    \"\"\"Handle complaints submission\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            await message.answer(get_text(\"complaints_instructions\", lang))\n            \n        except Exception as e:\n            logger.error(f\"Error handling complaints: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"👤 حسابي\", \"👤 My Account\"]))\nasync def handle_my_account(message: Message, session_maker):\n    \"\"\"Show user account information\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            \n            # Format account information\n            account_info = get_text(\"account_info\", lang).format(\n                first_name=user.first_name,\n                last_name=user.last_name or \"\",\n                username=f\"@{user.username}\" if user.username else get_text(\"not_set\", lang),\n                phone=user.phone_number or get_text(\"not_set\", lang),\n                customer_code=user.customer_code,\n                language=user.language_code.upper(),\n                country=user.country_code.upper(),\n                notifications=get_text(\"enabled\", lang) if user.notifications_enabled else get_text(\"disabled\", lang)\n            )\n            \n            await message.answer(account_info)\n            \n        except Exception as e:\n            logger.error(f\"Error showing account: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\nasync def get_or_create_user(session: AsyncSession, telegram_user) -> User:\n    \"\"\"Get existing user or create new one\"\"\"\n    # Try to get existing user\n    result = await session.execute(\n        select(User).where(User.telegram_id == telegram_user.id)\n    )\n    user = result.scalar_one_or_none()\n    \n    if user:\n        # Update user information\n        user.username = telegram_user.username\n        user.first_name = telegram_user.first_name\n        user.last_name = telegram_user.last_name\n        user.last_activity = datetime.now(timezone.utc)\n        user.updated_at = datetime.now(timezone.utc)\n    else:\n        # Create new user\n        user = User(\n            telegram_id=telegram_user.id,\n            username=telegram_user.username,\n            first_name=telegram_user.first_name,\n            last_name=telegram_user.last_name,\n            language_code=telegram_user.language_code or \"ar\",\n            last_activity=datetime.now(timezone.utc)\n        )\n        session.add(user)\n    \n    return user\n\nasync def get_user_by_telegram_id(session: AsyncSession, telegram_id: int) -> User:\n    \"\"\"Get user by telegram ID\"\"\"\n    result = await session.execute(\n        select(User).where(User.telegram_id == telegram_id)\n    )\n    return result.scalar_one_or_none()\n\nasync def show_main_menu(message: Message, user: User, session: AsyncSession):\n    \"\"\"Show main menu to user\"\"\"\n    lang = get_user_language(user.language_code)\n    \n    welcome_back_text = get_text(\"welcome_back\", lang).format(\n        first_name=user.first_name,\n        customer_code=user.customer_code\n    )\n    \n    await message.answer(\n        welcome_back_text,\n        reply_markup=get_main_menu_keyboard(lang)\n    )\n","size_bytes":9884},"handlers/user_settings.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nUser settings handler for language and country selection\nHandles user preference changes and localization updates\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom models import User, Language, Country\nfrom services.i18n import get_text, get_user_language, load_translations\nfrom utils.keyboards import (\n    get_language_selection_keyboard, get_country_selection_keyboard,\n    get_settings_keyboard, get_main_menu_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n@router.message(F.text.in_([\"🌐 اللغة\", \"🌐 Language\", \"⚙️ الإعدادات\", \"⚙️ Settings\"]))\nasync def show_settings_menu(message: Message, session_maker):\n    \"\"\"Show settings menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            \n            await message.answer(\n                get_text(\"settings_menu\", lang),\n                reply_markup=get_settings_keyboard(lang)\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error showing settings menu: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"change_language\")\nasync def show_language_selection(callback: CallbackQuery, session_maker):\n    \"\"\"Show language selection menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Get available languages\n            result = await session.execute(\n                select(Language).where(Language.is_active == True).order_by(Language.name)\n            )\n            languages = result.scalars().all()\n            \n            lang = get_user_language(user.language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"select_language\", lang),\n                reply_markup=get_language_selection_keyboard(languages, user.language_code, lang)\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing language selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"lang_\"))\nasync def change_language(callback: CallbackQuery, session_maker):\n    \"\"\"Change user language\"\"\"\n    async with session_maker() as session:\n        try:\n            language_code = callback.data.split(\"_\")[1]\n            \n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Verify language exists and is active\n            result = await session.execute(\n                select(Language).where(\n                    Language.code == language_code,\n                    Language.is_active == True\n                )\n            )\n            language = result.scalar_one_or_none()\n            \n            if not language:\n                await callback.answer(get_text(\"language_not_available\", \"ar\"))\n                return\n            \n            # Update user language\n            old_lang = user.language_code\n            user.language_code = language_code\n            user.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            # Get new language text\n            new_lang = get_user_language(language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"language_changed\", new_lang).format(\n                    language_name=language.native_name\n                )\n            )\n            \n            # Show updated main menu\n            await callback.message.answer(\n                get_text(\"main_menu_updated\", new_lang),\n                reply_markup=get_main_menu_keyboard(new_lang)\n            )\n            \n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error changing language: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"change_country\")\nasync def show_country_selection(callback: CallbackQuery, session_maker):\n    \"\"\"Show country selection menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Get available countries\n            result = await session.execute(\n                select(Country).where(Country.is_active == True).order_by(Country.name)\n            )\n            countries = result.scalars().all()\n            \n            lang = get_user_language(user.language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"select_country\", lang),\n                reply_markup=get_country_selection_keyboard(countries, user.country_code, lang)\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing country selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"country_\"))\nasync def change_country(callback: CallbackQuery, session_maker):\n    \"\"\"Change user country\"\"\"\n    async with session_maker() as session:\n        try:\n            country_code = callback.data.split(\"_\")[1]\n            \n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Verify country exists and is active\n            result = await session.execute(\n                select(Country).where(\n                    Country.code == country_code,\n                    Country.is_active == True\n                )\n            )\n            country = result.scalar_one_or_none()\n            \n            if not country:\n                lang = get_user_language(user.language_code)\n                await callback.answer(get_text(\"country_not_available\", lang))\n                return\n            \n            # Update user country\n            user.country_code = country_code\n            user.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            lang = get_user_language(user.language_code)\n            \n            country_name = country.native_name if lang == \"ar\" else country.name\n            \n            await callback.message.edit_text(\n                get_text(\"country_changed\", lang).format(\n                    country_name=country_name\n                )\n            )\n            \n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error changing country: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"toggle_notifications\")\nasync def toggle_notifications(callback: CallbackQuery, session_maker):\n    \"\"\"Toggle user notifications\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Toggle notifications\n            user.notifications_enabled = not user.notifications_enabled\n            user.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            lang = get_user_language(user.language_code)\n            \n            status = get_text(\"enabled\", lang) if user.notifications_enabled else get_text(\"disabled\", lang)\n            \n            await callback.message.edit_text(\n                get_text(\"notifications_toggled\", lang).format(status=status)\n            )\n            \n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error toggling notifications: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"back_to_settings\")\nasync def back_to_settings(callback: CallbackQuery, session_maker):\n    \"\"\"Go back to settings menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            lang = get_user_language(user.language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"settings_menu\", lang),\n                reply_markup=get_settings_keyboard(lang)\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error going back to settings: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\nasync def get_user_by_telegram_id(session: AsyncSession, telegram_id: int) -> User:\n    \"\"\"Get user by telegram ID\"\"\"\n    result = await session.execute(\n        select(User).where(User.telegram_id == telegram_id)\n    )\n    return result.scalar_one_or_none()\n","size_bytes":9720},"services/broadcast_service.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBroadcast service for handling mass messaging\nManages broadcast queues, rate limiting, and delivery tracking\n\"\"\"\n\nimport asyncio\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Optional, List, Dict, Any\nfrom aiogram import Bot\nfrom aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError\nfrom aiogram.types import InputMediaPhoto, InputMediaVideo, InputMediaDocument\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker\nfrom sqlalchemy import select, and_\n\nfrom models import (\n    User, Outbox, OutboxRecipient, OutboxStatus, \n    DeliveryStatus, OutboxType\n)\nfrom config import (\n    BROADCAST_RATE_LIMIT, BROADCAST_CHUNK_SIZE, \n    BROADCAST_RETRY_ATTEMPTS, BROADCAST_RETRY_DELAY\n)\n\nlogger = logging.getLogger(__name__)\n\nclass BroadcastService:\n    \"\"\"Service for handling broadcast operations\"\"\"\n    \n    def __init__(self, bot: Bot, session_maker: async_sessionmaker):\n        self.bot = bot\n        self.session_maker = session_maker\n        self.broadcast_queue = asyncio.Queue()\n        self.is_running = False\n        \n    async def queue_broadcast(self, outbox_id: int, target_type: str, \n                            target_value: Optional[str], message_text: str,\n                            message_type: str = \"text\", file_id: Optional[str] = None,\n                            message_entities: Optional[List] = None):\n        \"\"\"Queue a broadcast for delivery\"\"\"\n        broadcast_data = {\n            \"outbox_id\": outbox_id,\n            \"target_type\": target_type,\n            \"target_value\": target_value,\n            \"message_text\": message_text,\n            \"message_type\": message_type,\n            \"file_id\": file_id,\n            \"message_entities\": message_entities\n        }\n        \n        await self.broadcast_queue.put(broadcast_data)\n        logger.info(f\"Queued broadcast {outbox_id} for delivery\")\n    \n    async def worker(self):\n        \"\"\"Background worker for processing broadcast queue\"\"\"\n        self.is_running = True\n        logger.info(\"Broadcast service worker started\")\n        \n        while self.is_running:\n            try:\n                # Get broadcast from queue with timeout\n                try:\n                    broadcast = await asyncio.wait_for(\n                        self.broadcast_queue.get(), timeout=5.0\n                    )\n                except asyncio.TimeoutError:\n                    continue\n                \n                await self.process_broadcast(broadcast)\n                \n            except Exception as e:\n                logger.error(f\"Error in broadcast worker: {e}\")\n                await asyncio.sleep(1)\n    \n    async def process_broadcast(self, broadcast: Dict[str, Any]):\n        \"\"\"Process a single broadcast\"\"\"\n        outbox_id = broadcast[\"outbox_id\"]\n        \n        try:\n            async with self.session_maker() as session:\n                # Get target users\n                users = await self.get_target_users(\n                    session, broadcast[\"target_type\"], broadcast.get(\"target_value\")\n                )\n                \n                if not users:\n                    logger.warning(f\"No target users found for broadcast {outbox_id}\")\n                    await self.update_broadcast_status(session, outbox_id, OutboxStatus.COMPLETED)\n                    return\n                \n                # Create recipient records\n                await self.create_recipient_records(session, outbox_id, users)\n                await session.commit()\n                \n                logger.info(f\"Starting delivery for broadcast {outbox_id} to {len(users)} users\")\n                \n                # Process in chunks\n                for chunk in self.chunk_list(users, BROADCAST_CHUNK_SIZE):\n                    await self.send_to_chunk(session, outbox_id, chunk, broadcast)\n                    \n                    # Rate limiting\n                    sleep_time = len(chunk) / BROADCAST_RATE_LIMIT\n                    await asyncio.sleep(sleep_time)\n                \n                # Update broadcast status\n                await self.update_broadcast_status(session, outbox_id, OutboxStatus.COMPLETED)\n                logger.info(f\"Completed broadcast {outbox_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Error processing broadcast {outbox_id}: {e}\")\n            async with self.session_maker() as session:\n                await self.update_broadcast_status(session, outbox_id, OutboxStatus.FAILED)\n    \n    async def get_target_users(self, session: AsyncSession, target_type: str, \n                             target_value: Optional[str]) -> List[User]:\n        \"\"\"Get target users based on targeting criteria\"\"\"\n        base_query = select(User).where(\n            and_(User.is_active == True, User.is_banned == False)\n        )\n        \n        if target_type == \"all\":\n            result = await session.execute(base_query)\n        elif target_type == \"language\":\n            result = await session.execute(\n                base_query.where(User.language_code == target_value)\n            )\n        elif target_type == \"country\":\n            result = await session.execute(\n                base_query.where(User.country_code == target_value)\n            )\n        else:\n            logger.warning(f\"Unknown target type: {target_type}\")\n            return []\n        \n        return list(result.scalars().all())\n    \n    async def create_recipient_records(self, session: AsyncSession, \n                                     outbox_id: int, users: List[User]):\n        \"\"\"Create recipient tracking records\"\"\"\n        for user in users:\n            recipient = OutboxRecipient(\n                outbox_id=outbox_id,\n                user_id=user.id,\n                status=DeliveryStatus.PENDING\n            )\n            session.add(recipient)\n    \n    async def send_to_chunk(self, session: AsyncSession, outbox_id: int, \n                          users: List[User], broadcast: Dict[str, Any]):\n        \"\"\"Send broadcast to a chunk of users\"\"\"\n        for user in users:\n            try:\n                success = await self.send_to_user(user, broadcast)\n                \n                # Update recipient status\n                await self.update_recipient_status(\n                    session, outbox_id, user.id,\n                    DeliveryStatus.SENT if success else DeliveryStatus.FAILED\n                )\n                \n            except Exception as e:\n                logger.error(f\"Error sending to user {user.telegram_id}: {e}\")\n                await self.update_recipient_status(\n                    session, outbox_id, user.id, DeliveryStatus.FAILED, str(e)\n                )\n        \n        await session.commit()\n    \n    async def send_to_user(self, user: User, broadcast: Dict[str, Any]) -> bool:\n        \"\"\"Send broadcast message to a single user\"\"\"\n        try:\n            message_text = broadcast[\"message_text\"]\n            message_type = broadcast.get(\"message_type\", \"text\")\n            file_id = broadcast.get(\"file_id\")\n            \n            if message_type == \"text\":\n                await self.bot.send_message(\n                    chat_id=user.telegram_id,\n                    text=message_text,\n                    entities=broadcast.get(\"message_entities\")\n                )\n            elif message_type == \"photo\" and file_id:\n                await self.bot.send_photo(\n                    chat_id=user.telegram_id,\n                    photo=file_id,\n                    caption=message_text,\n                    caption_entities=broadcast.get(\"message_entities\")\n                )\n            elif message_type == \"video\" and file_id:\n                await self.bot.send_video(\n                    chat_id=user.telegram_id,\n                    video=file_id,\n                    caption=message_text,\n                    caption_entities=broadcast.get(\"message_entities\")\n                )\n            elif message_type == \"document\" and file_id:\n                await self.bot.send_document(\n                    chat_id=user.telegram_id,\n                    document=file_id,\n                    caption=message_text,\n                    caption_entities=broadcast.get(\"message_entities\")\n                )\n            \n            return True\n            \n        except TelegramForbiddenError:\n            # User blocked the bot\n            logger.info(f\"User {user.telegram_id} blocked the bot\")\n            return False\n        except TelegramBadRequest as e:\n            # Invalid user or other API error\n            logger.warning(f\"Bad request for user {user.telegram_id}: {e}\")\n            return False\n        except Exception as e:\n            logger.error(f\"Unexpected error sending to user {user.telegram_id}: {e}\")\n            return False\n    \n    async def update_broadcast_status(self, session: AsyncSession, \n                                    outbox_id: int, status: OutboxStatus):\n        \"\"\"Update broadcast status\"\"\"\n        result = await session.execute(\n            select(Outbox).where(Outbox.id == outbox_id)\n        )\n        outbox = result.scalar_one_or_none()\n        \n        if outbox:\n            outbox.status = status\n            outbox.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n    \n    async def update_recipient_status(self, session: AsyncSession, outbox_id: int,\n                                    user_id: int, status: DeliveryStatus,\n                                    error_message: Optional[str] = None):\n        \"\"\"Update recipient delivery status\"\"\"\n        result = await session.execute(\n            select(OutboxRecipient).where(\n                and_(\n                    OutboxRecipient.outbox_id == outbox_id,\n                    OutboxRecipient.user_id == user_id\n                )\n            )\n        )\n        recipient = result.scalar_one_or_none()\n        \n        if recipient:\n            recipient.status = status\n            recipient.last_attempt = datetime.now(timezone.utc)\n            recipient.attempts += 1\n            \n            if status == DeliveryStatus.SENT:\n                recipient.delivered_at = datetime.now(timezone.utc)\n            elif error_message:\n                recipient.error_message = error_message\n    \n    @staticmethod\n    def chunk_list(lst: List, chunk_size: int) -> List[List]:\n        \"\"\"Split list into chunks\"\"\"\n        return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]\n    \n    async def stop(self):\n        \"\"\"Stop the broadcast service\"\"\"\n        self.is_running = False\n        logger.info(\"Broadcast service stopping...\")\n","size_bytes":10646},"services/customer_id.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nCustomer ID generation service\nGenerates unique customer codes for new users\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\nfrom models import User\nfrom config import CUSTOMER_ID_PREFIX, CUSTOMER_ID_YEAR_FORMAT\n\nlogger = logging.getLogger(__name__)\n\nasync def generate_customer_code(session: AsyncSession) -> str:\n    \"\"\"Generate unique customer code\"\"\"\n    try:\n        # Get current year\n        current_year = datetime.now().year\n        year_str = CUSTOMER_ID_YEAR_FORMAT or str(current_year)\n        \n        # Get the highest existing number for this year\n        pattern = f\"{CUSTOMER_ID_PREFIX}-{year_str}-%\"\n        \n        result = await session.execute(\n            select(func.max(User.customer_code))\n            .where(User.customer_code.like(pattern))\n        )\n        \n        max_code = result.scalar_one_or_none()\n        \n        if max_code:\n            try:\n                # Extract the number part and increment\n                parts = max_code.split('-')\n                if len(parts) >= 3:\n                    last_number = int(parts[-1])\n                    next_number = last_number + 1\n                else:\n                    next_number = 1\n            except (ValueError, IndexError):\n                next_number = 1\n        else:\n            next_number = 1\n        \n        # Format with leading zeros (6 digits)\n        customer_code = f\"{CUSTOMER_ID_PREFIX}-{year_str}-{next_number:06d}\"\n        \n        # Verify uniqueness (double-check)\n        existing = await session.execute(\n            select(User).where(User.customer_code == customer_code)\n        )\n        \n        if existing.scalar_one_or_none():\n            # If somehow exists, try with incremented number\n            next_number += 1\n            customer_code = f\"{CUSTOMER_ID_PREFIX}-{year_str}-{next_number:06d}\"\n        \n        logger.info(f\"Generated customer code: {customer_code}\")\n        return customer_code\n        \n    except Exception as e:\n        logger.error(f\"Error generating customer code: {e}\")\n        # Fallback: use timestamp-based code\n        timestamp = int(datetime.now().timestamp())\n        fallback_code = f\"{CUSTOMER_ID_PREFIX}-{year_str}-T{timestamp}\"\n        logger.warning(f\"Using fallback customer code: {fallback_code}\")\n        return fallback_code\n\nasync def is_customer_code_unique(session: AsyncSession, customer_code: str) -> bool:\n    \"\"\"Check if customer code is unique\"\"\"\n    try:\n        result = await session.execute(\n            select(User).where(User.customer_code == customer_code)\n        )\n        return result.scalar_one_or_none() is None\n    except Exception as e:\n        logger.error(f\"Error checking customer code uniqueness: {e}\")\n        return False\n\nasync def get_user_by_customer_code(session: AsyncSession, customer_code: str) -> User:\n    \"\"\"Get user by customer code\"\"\"\n    try:\n        result = await session.execute(\n            select(User).where(User.customer_code == customer_code)\n        )\n        return result.scalar_one_or_none()\n    except Exception as e:\n        logger.error(f\"Error getting user by customer code: {e}\")\n        return None\n","size_bytes":3239},"services/i18n.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nInternationalization service for multi-language support\nLoads and manages translation files for Arabic and English\n\"\"\"\n\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nlogger = logging.getLogger(__name__)\n\n# Global translations storage\ntranslations: Dict[str, Dict[str, str]] = {}\n\ndef load_translations():\n    \"\"\"Load translation files\"\"\"\n    global translations\n    \n    translations_dir = Path(\"translations\")\n    \n    try:\n        # Load Arabic translations\n        ar_file = translations_dir / \"ar.json\"\n        if ar_file.exists():\n            with open(ar_file, 'r', encoding='utf-8') as f:\n                translations['ar'] = json.load(f)\n        else:\n            logger.warning(\"Arabic translations file not found\")\n            translations['ar'] = {}\n        \n        # Load English translations\n        en_file = translations_dir / \"en.json\"\n        if en_file.exists():\n            with open(en_file, 'r', encoding='utf-8') as f:\n                translations['en'] = json.load(f)\n        else:\n            logger.warning(\"English translations file not found\")\n            translations['en'] = {}\n        \n        logger.info(f\"Loaded translations for {len(translations)} languages\")\n        \n    except Exception as e:\n        logger.error(f\"Error loading translations: {e}\")\n        # Initialize with empty dictionaries to prevent crashes\n        translations = {'ar': {}, 'en': {}}\n\ndef get_text(key: str, language: str = \"ar\", **kwargs) -> str:\n    \"\"\"Get translated text by key and language\"\"\"\n    if not translations:\n        load_translations()\n    \n    # Get translation for the language or fall back to Arabic\n    lang_dict = translations.get(language, {})\n    \n    # Get the text or fall back to Arabic, then to the key itself\n    text = lang_dict.get(key)\n    if text is None and language != \"ar\":\n        text = translations.get(\"ar\", {}).get(key)\n    if text is None:\n        text = f\"[{key}]\"  # Fallback to show missing translation\n    \n    # Format with provided arguments\n    try:\n        return text.format(**kwargs)\n    except (KeyError, ValueError) as e:\n        logger.warning(f\"Error formatting text '{key}' for language '{language}': {e}\")\n        return text\n\ndef get_user_language(language_code: str = None) -> str:\n    \"\"\"Get user's language code with fallback\"\"\"\n    if language_code and language_code in translations:\n        return language_code\n    return \"ar\"  # Default to Arabic\n\ndef get_available_languages() -> list:\n    \"\"\"Get list of available languages\"\"\"\n    if not translations:\n        load_translations()\n    return list(translations.keys())\n\ndef is_rtl_language(language_code: str) -> bool:\n    \"\"\"Check if language is right-to-left\"\"\"\n    rtl_languages = ['ar', 'he', 'fa', 'ur']\n    return language_code in rtl_languages\n\n# Load translations on module import\nload_translations()\n","size_bytes":2898},"utils/auth.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAuthentication utilities for admin verification\nHandles admin permission checks and decorators\n\"\"\"\n\nimport logging\nfrom functools import wraps\nfrom typing import Callable, Any\nfrom aiogram.types import Message, CallbackQuery\n\nfrom config import ADMIN_USER_IDS\nfrom services.i18n import get_text\n\nlogger = logging.getLogger(__name__)\n\ndef is_admin(user_id: int) -> bool:\n    \"\"\"Check if user is an admin\"\"\"\n    return user_id in ADMIN_USER_IDS\n\ndef admin_required(func: Callable) -> Callable:\n    \"\"\"Decorator to require admin privileges\"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Extract user from message or callback\n        user_id = None\n        message_obj = None\n        \n        for arg in args:\n            if isinstance(arg, Message):\n                user_id = arg.from_user.id\n                message_obj = arg\n                break\n            elif isinstance(arg, CallbackQuery):\n                user_id = arg.from_user.id\n                message_obj = arg.message if hasattr(arg, 'message') else arg\n                break\n        \n        if not user_id:\n            logger.warning(\"Could not extract user ID from arguments\")\n            return\n        \n        if not is_admin(user_id):\n            logger.warning(f\"Unauthorized admin access attempt by user {user_id}\")\n            \n            # Send unauthorized message\n            error_text = get_text(\"unauthorized_access\", \"ar\")\n            \n            if isinstance(message_obj, Message):\n                await message_obj.answer(error_text)\n            elif hasattr(message_obj, 'answer'):\n                await message_obj.answer(error_text)\n            elif hasattr(message_obj, 'message') and hasattr(message_obj.message, 'answer'):\n                await message_obj.message.answer(error_text)\n            \n            return\n        \n        # User is admin, proceed with function\n        return await func(*args, **kwargs)\n    \n    return wrapper\n\nasync def check_admin_permissions(user_id: int, required_level: str = \"basic\") -> bool:\n    \"\"\"Check admin permissions with different levels\"\"\"\n    if not is_admin(user_id):\n        return False\n    \n    # For now, all admins have the same level\n    # You can extend this to have different admin levels\n    return True\n\ndef get_admin_level(user_id: int) -> str:\n    \"\"\"Get admin level for user\"\"\"\n    if not is_admin(user_id):\n        return \"none\"\n    \n    # For now, all admins are \"super_admin\"\n    # You can extend this based on your needs\n    return \"super_admin\"\n\nasync def log_admin_action(user_id: int, action: str, details: str = \"\"):\n    \"\"\"Log admin actions for audit trail\"\"\"\n    logger.info(f\"Admin action - User: {user_id}, Action: {action}, Details: {details}\")\n    \n    # You can extend this to save to database for audit trail\n    # Example:\n    # async with session_maker() as session:\n    #     audit_log = AdminAuditLog(\n    #         admin_user_id=user_id,\n    #         action=action,\n    #         details=details,\n    #         timestamp=datetime.now(timezone.utc)\n    #     )\n    #     session.add(audit_log)\n    #     await session.commit()\n\nclass AdminContext:\n    \"\"\"Context manager for admin operations\"\"\"\n    \n    def __init__(self, user_id: int, action: str):\n        self.user_id = user_id\n        self.action = action\n        self.start_time = None\n    \n    async def __aenter__(self):\n        if not is_admin(self.user_id):\n            raise PermissionError(f\"User {self.user_id} is not an admin\")\n        \n        await log_admin_action(self.user_id, f\"Started: {self.action}\")\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await log_admin_action(\n                self.user_id, \n                f\"Failed: {self.action}\",\n                f\"Error: {exc_val}\"\n            )\n        else:\n            await log_admin_action(self.user_id, f\"Completed: {self.action}\")\n\n# Example usage of AdminContext:\n# async with AdminContext(user_id, \"broadcast_creation\"):\n#     # Perform admin operation\n#     pass\n","size_bytes":4083},"utils/keyboards.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nKeyboard utilities for creating inline and reply keyboards\nHandles all keyboard layouts for different bot functions\n\"\"\"\n\nfrom typing import List, Optional\nfrom aiogram.types import (\n    ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, \n    InlineKeyboardButton\n)\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\n\nfrom services.i18n import get_text\n\ndef get_main_menu_keyboard(language: str = \"ar\") -> ReplyKeyboardMarkup:\n    \"\"\"Create main menu reply keyboard\"\"\"\n    builder = ReplyKeyboardBuilder()\n    \n    # Main action buttons - 2 per row\n    builder.row(\n        KeyboardButton(text=get_text(\"deposit\", language)),\n        KeyboardButton(text=get_text(\"withdraw\", language))\n    )\n    \n    builder.row(\n        KeyboardButton(text=get_text(\"complaints\", language)),\n        KeyboardButton(text=get_text(\"support\", language))\n    )\n    \n    builder.row(\n        KeyboardButton(text=get_text(\"manager\", language)),\n        KeyboardButton(text=get_text(\"plans\", language))\n    )\n    \n    builder.row(\n        KeyboardButton(text=get_text(\"sales\", language)),\n        KeyboardButton(text=get_text(\"settings\", language))\n    )\n    \n    # Bottom navigation buttons\n    builder.row(\n        KeyboardButton(text=get_text(\"back\", language)),\n        KeyboardButton(text=get_text(\"forward\", language)),\n        KeyboardButton(text=get_text(\"my_account\", language))\n    )\n    \n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=False)\n\ndef get_phone_share_keyboard(language: str = \"ar\") -> ReplyKeyboardMarkup:\n    \"\"\"Create phone sharing keyboard\"\"\"\n    builder = ReplyKeyboardBuilder()\n    \n    builder.row(\n        KeyboardButton(\n            text=get_text(\"share_phone\", language),\n            request_contact=True\n        )\n    )\n    \n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)\n\ndef get_contact_confirmation_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create contact confirmation keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"confirm\", language),\n            callback_data=\"confirm_phone\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_settings_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create settings menu keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"change_language\", language),\n            callback_data=\"change_language\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"change_country\", language),\n            callback_data=\"change_country\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"toggle_notifications\", language),\n            callback_data=\"toggle_notifications\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_language_selection_keyboard(languages, current_language: str, \n                                  ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create language selection keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for lang in languages:\n        # Add checkmark for current language\n        text = lang.native_name\n        if lang.code == current_language:\n            text = f\"✅ {text}\"\n        \n        builder.row(\n            InlineKeyboardButton(\n                text=text,\n                callback_data=f\"lang_{lang.code}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", ui_language),\n            callback_data=\"back_to_settings\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_country_selection_keyboard(countries, current_country: str,\n                                 ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create country selection keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for country in countries:\n        # Add checkmark for current country\n        text = country.native_name\n        if country.code == current_country:\n            text = f\"✅ {text}\"\n        \n        builder.row(\n            InlineKeyboardButton(\n                text=text,\n                callback_data=f\"country_{country.code}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", ui_language),\n            callback_data=\"back_to_settings\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_panel_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin panel keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_users\", language),\n            callback_data=\"admin_users\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_languages\", language),\n            callback_data=\"admin_languages\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"admin_countries\", language),\n            callback_data=\"admin_countries\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_broadcast\", language),\n            callback_data=\"admin_broadcast\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_outbox\", language),\n            callback_data=\"admin_outbox\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_users_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin users management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"search_users\", language),\n            callback_data=\"search_users\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"user_statistics\", language),\n            callback_data=\"user_statistics\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_languages_keyboard(languages, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin languages management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    # Show toggle buttons for each language\n    for lang in languages[:5]:  # Limit to 5 to avoid too long keyboards\n        status_text = \"✅\" if lang.is_active else \"❌\"\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{status_text} {lang.native_name}\",\n                callback_data=f\"toggle_lang_{lang.id}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"add_language\", language),\n            callback_data=\"add_language\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_countries_keyboard(countries, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin countries management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    # Show toggle buttons for each country\n    for country in countries[:5]:  # Limit to 5 to avoid too long keyboards\n        status_text = \"✅\" if country.is_active else \"❌\"\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{status_text} {country.native_name}\",\n                callback_data=f\"toggle_country_{country.id}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"add_country\", language),\n            callback_data=\"add_country\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_user_management_keyboard(user_id: int, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create user management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"ban_user\", language),\n            callback_data=f\"ban_user_{user_id}\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"unban_user\", language),\n            callback_data=f\"unban_user_{user_id}\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"promote_admin\", language),\n            callback_data=f\"promote_admin_{user_id}\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"admin_users\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_pagination_keyboard(base_callback: str, current_page: int, \n                          total_pages: int, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create pagination keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    buttons = []\n    \n    # Previous button\n    if current_page > 0:\n        buttons.append(\n            InlineKeyboardButton(\n                text=\"◀️\",\n                callback_data=f\"{base_callback}_page_{current_page - 1}\"\n            )\n        )\n    \n    # Current page indicator\n    buttons.append(\n        InlineKeyboardButton(\n            text=f\"{current_page + 1}/{total_pages}\",\n            callback_data=\"noop\"\n        )\n    )\n    \n    # Next button\n    if current_page < total_pages - 1:\n        buttons.append(\n            InlineKeyboardButton(\n                text=\"▶️\",\n                callback_data=f\"{base_callback}_page_{current_page + 1}\"\n            )\n        )\n    \n    builder.row(*buttons)\n    \n    # Back button\n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_broadcast_targeting_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create broadcast targeting keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"broadcast_all\", language),\n            callback_data=\"broadcast_all\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"broadcast_by_language\", language),\n            callback_data=\"broadcast_by_language\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"broadcast_by_country\", language),\n            callback_data=\"broadcast_by_country\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_broadcast_confirmation_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create broadcast confirmation keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"confirm_broadcast\", language),\n            callback_data=\"confirm_broadcast\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"cancel_broadcast\", language),\n            callback_data=\"cancel_broadcast\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_language_filter_keyboard(languages, ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create language filter keyboard for broadcasts\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for lang_code, lang_name, user_count in languages:\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{lang_name} ({user_count})\",\n                callback_data=f\"lang_filter_{lang_code}\"\n            )\n        )\n    \n    return builder.as_markup()\n\ndef get_country_filter_keyboard(countries, ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create country filter keyboard for broadcasts\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for country_code, country_name, user_count in countries:\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{country_name} ({user_count})\",\n                callback_data=f\"country_filter_{country_code}\"\n            )\n        )\n    \n    return builder.as_markup()\n\ndef get_announcement_menu_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement menu keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"skip_image\", language),\n            callback_data=\"skip_image\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_announcement_targeting_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement targeting keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"announce_all\", language),\n            callback_data=\"announce_all\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"announce_by_language\", language),\n            callback_data=\"announce_by_language\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_announcement_duration_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement duration keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"duration_1h\", language),\n            callback_data=\"duration_1h\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"duration_6h\", language),\n            callback_data=\"duration_6h\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"duration_24h\", language),\n            callback_data=\"duration_24h\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"duration_7d\", language),\n            callback_data=\"duration_7d\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"duration_permanent\", language),\n            callback_data=\"duration_permanent\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_announcement_confirmation_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement confirmation keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"confirm_announcement\", language),\n            callback_data=\"confirm_announcement\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"cancel_announcement\", language),\n            callback_data=\"cancel_announcement\"\n        )\n    )\n    \n    return builder.as_markup()\n","size_bytes":14747},"backup_server_files/handlers/admin.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAdmin handler for administrative functions\nHandles admin panel, user management, language/country management\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.filters import Command\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func, desc\n\nfrom models import User, Language, Country, Outbox, OutboxType, OutboxStatus\nfrom services.i18n import get_text, get_user_language\nfrom utils.auth import admin_required\nfrom utils.keyboards import (\n    get_admin_panel_keyboard, get_admin_users_keyboard,\n    get_admin_languages_keyboard, get_admin_countries_keyboard,\n    get_user_management_keyboard, get_pagination_keyboard\n)\nfrom config import USERS_PER_PAGE\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass AdminStates(StatesGroup):\n    managing_user = State()\n    adding_language = State()\n    adding_country = State()\n    viewing_outbox = State()\n\n@router.message(Command(\"admin\"))\n@admin_required\nasync def show_admin_panel(message: Message, session_maker):\n    \"\"\"Show admin panel\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get statistics\n            total_users = await session.scalar(select(func.count(User.id)))\n            active_users = await session.scalar(\n                select(func.count(User.id)).where(User.is_active == True)\n            )\n            pending_requests = await session.scalar(\n                select(func.count(Outbox.id)).where(Outbox.status == OutboxStatus.PENDING)\n            )\n            \n            admin_text = get_text(\"admin_panel\", \"ar\").format(\n                total_users=total_users,\n                active_users=active_users,\n                pending_requests=pending_requests\n            )\n            \n            await message.answer(\n                admin_text,\n                reply_markup=get_admin_panel_keyboard(\"ar\")\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error showing admin panel: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_users\")\n@admin_required\nasync def show_users_list(callback: CallbackQuery, session_maker):\n    \"\"\"Show users list with pagination\"\"\"\n    await show_users_page(callback, session_maker, 0)\n\n@router.callback_query(F.data.startswith(\"admin_users_page_\"))\n@admin_required\nasync def show_users_page(callback: CallbackQuery, session_maker, page: int = None):\n    \"\"\"Show specific page of users\"\"\"\n    async with session_maker() as session:\n        try:\n            if page is None:\n                page = int(callback.data.split(\"_\")[-1])\n            \n            offset = page * USERS_PER_PAGE\n            \n            # Get users with pagination\n            result = await session.execute(\n                select(User)\n                .order_by(desc(User.created_at))\n                .offset(offset)\n                .limit(USERS_PER_PAGE)\n            )\n            users = result.scalars().all()\n            \n            # Get total count for pagination\n            total_users = await session.scalar(select(func.count(User.id)))\n            total_pages = (total_users + USERS_PER_PAGE - 1) // USERS_PER_PAGE\n            \n            if not users:\n                await callback.message.edit_text(\n                    get_text(\"no_users_found\", \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format users list\n            users_text = get_text(\"users_list_header\", \"ar\").format(\n                page=page + 1,\n                total_pages=total_pages,\n                total_users=total_users\n            )\n            \n            for user in users:\n                status = \"🟢\" if user.is_active else \"🔴\"\n                banned = \"🚫\" if user.is_banned else \"\"\n                admin_mark = \"👑\" if user.is_admin else \"\"\n                \n                users_text += f\"\\n\\n{status} {admin_mark} {banned}\\n\"\n                users_text += f\"ID: {user.telegram_id}\\n\"\n                users_text += f\"Name: {user.first_name}\"\n                if user.last_name:\n                    users_text += f\" {user.last_name}\"\n                if user.username:\n                    users_text += f\" (@{user.username})\"\n                users_text += f\"\\nCustomer: {user.customer_code or 'N/A'}\"\n                users_text += f\"\\nLang: {user.language_code} | Country: {user.country_code}\"\n                users_text += f\"\\nJoined: {user.created_at.strftime('%Y-%m-%d')}\"\n            \n            keyboard = get_pagination_keyboard(\"admin_users\", page, total_pages, \"ar\")\n            \n            await callback.message.edit_text(\n                users_text,\n                reply_markup=keyboard\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing users page: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_languages\")\n@admin_required\nasync def show_languages_management(callback: CallbackQuery, session_maker):\n    \"\"\"Show languages management\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get all languages\n            result = await session.execute(\n                select(Language).order_by(Language.name)\n            )\n            languages = result.scalars().all()\n            \n            if not languages:\n                await callback.message.edit_text(\n                    get_text(\"no_languages_found\", \"ar\"),\n                    reply_markup=get_admin_languages_keyboard([], \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format languages list\n            languages_text = get_text(\"languages_list\", \"ar\")\n            \n            for lang in languages:\n                status = \"✅\" if lang.is_active else \"❌\"\n                rtl_mark = \"🔄\" if lang.rtl else \"\"\n                \n                languages_text += f\"\\n\\n{status} {rtl_mark}\\n\"\n                languages_text += f\"Code: {lang.code}\\n\"\n                languages_text += f\"Name: {lang.name}\\n\"\n                languages_text += f\"Native: {lang.native_name}\\n\"\n                languages_text += f\"RTL: {'Yes' if lang.rtl else 'No'}\\n\"\n                languages_text += f\"Created: {lang.created_at.strftime('%Y-%m-%d')}\"\n            \n            await callback.message.edit_text(\n                languages_text,\n                reply_markup=get_admin_languages_keyboard(languages, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing languages: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_countries\")\n@admin_required\nasync def show_countries_management(callback: CallbackQuery, session_maker):\n    \"\"\"Show countries management\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get all countries\n            result = await session.execute(\n                select(Country).order_by(Country.name)\n            )\n            countries = result.scalars().all()\n            \n            if not countries:\n                await callback.message.edit_text(\n                    get_text(\"no_countries_found\", \"ar\"),\n                    reply_markup=get_admin_countries_keyboard([], \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format countries list\n            countries_text = get_text(\"countries_list\", \"ar\")\n            \n            for country in countries:\n                status = \"✅\" if country.is_active else \"❌\"\n                \n                countries_text += f\"\\n\\n{status}\\n\"\n                countries_text += f\"Code: {country.code}\\n\"\n                countries_text += f\"Name: {country.name}\\n\"\n                countries_text += f\"Native: {country.native_name}\\n\"\n                countries_text += f\"Phone: {country.phone_prefix}\\n\"\n                countries_text += f\"Created: {country.created_at.strftime('%Y-%m-%d')}\"\n            \n            await callback.message.edit_text(\n                countries_text,\n                reply_markup=get_admin_countries_keyboard(countries, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing countries: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"admin_outbox\")\n@admin_required\nasync def show_outbox_management(callback: CallbackQuery, session_maker):\n    \"\"\"Show outbox/requests management\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get pending requests\n            result = await session.execute(\n                select(Outbox)\n                .where(Outbox.status == OutboxStatus.PENDING)\n                .order_by(desc(Outbox.created_at))\n                .limit(10)\n            )\n            requests = result.scalars().all()\n            \n            if not requests:\n                await callback.message.edit_text(\n                    get_text(\"no_pending_requests\", \"ar\")\n                )\n                await callback.answer()\n                return\n            \n            # Format requests list\n            requests_text = get_text(\"pending_requests_header\", \"ar\")\n            \n            for req in requests:\n                type_emoji = {\n                    OutboxType.DEPOSIT: \"💰\",\n                    OutboxType.WITHDRAWAL: \"💸\", \n                    OutboxType.COMPLAINT: \"📨\",\n                    OutboxType.SUPPORT: \"🆘\"\n                }.get(req.type, \"📄\")\n                \n                requests_text += f\"\\n\\n{type_emoji} ID: {req.id}\\n\"\n                requests_text += f\"Type: {req.type.value.title()}\\n\"\n                requests_text += f\"User ID: {req.user_id}\\n\"\n                if req.subject:\n                    requests_text += f\"Subject: {req.subject}\\n\"\n                requests_text += f\"Content: {req.content[:100]}...\\n\" if len(req.content) > 100 else f\"Content: {req.content}\\n\"\n                requests_text += f\"Created: {req.created_at.strftime('%Y-%m-%d %H:%M')}\"\n            \n            await callback.message.edit_text(requests_text)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing outbox: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"toggle_lang_\"))\n@admin_required\nasync def toggle_language_status(callback: CallbackQuery, session_maker):\n    \"\"\"Toggle language active status\"\"\"\n    async with session_maker() as session:\n        try:\n            lang_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get language\n            result = await session.execute(\n                select(Language).where(Language.id == lang_id)\n            )\n            language = result.scalar_one_or_none()\n            \n            if not language:\n                await callback.answer(get_text(\"language_not_found\", \"ar\"))\n                return\n            \n            # Toggle status\n            language.is_active = not language.is_active\n            language.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            status = \"activated\" if language.is_active else \"deactivated\"\n            await callback.answer(f\"Language {language.name} {status}\")\n            \n            # Refresh the languages list\n            await show_languages_management(callback, session_maker)\n            \n        except Exception as e:\n            logger.error(f\"Error toggling language: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"toggle_country_\"))\n@admin_required\nasync def toggle_country_status(callback: CallbackQuery, session_maker):\n    \"\"\"Toggle country active status\"\"\"\n    async with session_maker() as session:\n        try:\n            country_id = int(callback.data.split(\"_\")[-1])\n            \n            # Get country\n            result = await session.execute(\n                select(Country).where(Country.id == country_id)\n            )\n            country = result.scalar_one_or_none()\n            \n            if not country:\n                await callback.answer(get_text(\"country_not_found\", \"ar\"))\n                return\n            \n            # Toggle status\n            country.is_active = not country.is_active\n            country.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            status = \"activated\" if country.is_active else \"deactivated\"\n            await callback.answer(f\"Country {country.name} {status}\")\n            \n            # Refresh the countries list\n            await show_countries_management(callback, session_maker)\n            \n        except Exception as e:\n            logger.error(f\"Error toggling country: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"back_to_admin\")\n@admin_required\nasync def back_to_admin_panel(callback: CallbackQuery, session_maker):\n    \"\"\"Go back to admin panel\"\"\"\n    await show_admin_panel(callback.message, session_maker)\n    await callback.answer()\n","size_bytes":13605},"backup_server_files/handlers/announcements.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAnnouncements handler for system announcements\nHandles announcement creation, scheduling, and delivery\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone, timedelta\nfrom aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\n\nfrom models import Announcement, AnnouncementDelivery, User\nfrom services.i18n import get_text\nfrom utils.auth import admin_required\nfrom utils.keyboards import (\n    get_announcement_menu_keyboard, get_announcement_targeting_keyboard,\n    get_announcement_duration_keyboard, get_announcement_confirmation_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass AnnouncementStates(StatesGroup):\n    entering_title_ar = State()\n    entering_title_en = State()\n    entering_content_ar = State()\n    entering_content_en = State()\n    adding_image = State()\n    selecting_target = State()\n    setting_duration = State()\n    confirming = State()\n\n@router.message(F.text == \"/announce_new\")\n@admin_required\nasync def start_announcement_creation(message: Message, state: FSMContext):\n    \"\"\"Start announcement creation process\"\"\"\n    await message.answer(\n        get_text(\"announcement_enter_title_ar\", \"ar\")\n    )\n    await state.set_state(AnnouncementStates.entering_title_ar)\n\n@router.message(AnnouncementStates.entering_title_ar)\n@admin_required\nasync def receive_title_arabic(message: Message, state: FSMContext):\n    \"\"\"Receive Arabic title\"\"\"\n    title_ar = message.text.strip()\n    \n    if not title_ar:\n        await message.answer(get_text(\"title_required\", \"ar\"))\n        return\n    \n    await state.update_data(title_ar=title_ar)\n    await message.answer(get_text(\"announcement_enter_title_en\", \"ar\"))\n    await state.set_state(AnnouncementStates.entering_title_en)\n\n@router.message(AnnouncementStates.entering_title_en)\n@admin_required\nasync def receive_title_english(message: Message, state: FSMContext):\n    \"\"\"Receive English title\"\"\"\n    title_en = message.text.strip()\n    \n    if not title_en:\n        await message.answer(get_text(\"title_required\", \"ar\"))\n        return\n    \n    await state.update_data(title_en=title_en)\n    await message.answer(get_text(\"announcement_enter_content_ar\", \"ar\"))\n    await state.set_state(AnnouncementStates.entering_content_ar)\n\n@router.message(AnnouncementStates.entering_content_ar)\n@admin_required\nasync def receive_content_arabic(message: Message, state: FSMContext):\n    \"\"\"Receive Arabic content\"\"\"\n    content_ar = message.text.strip()\n    \n    if not content_ar:\n        await message.answer(get_text(\"content_required\", \"ar\"))\n        return\n    \n    await state.update_data(content_ar=content_ar)\n    await message.answer(get_text(\"announcement_enter_content_en\", \"ar\"))\n    await state.set_state(AnnouncementStates.entering_content_en)\n\n@router.message(AnnouncementStates.entering_content_en)\n@admin_required\nasync def receive_content_english(message: Message, state: FSMContext):\n    \"\"\"Receive English content\"\"\"\n    content_en = message.text.strip()\n    \n    if not content_en:\n        await message.answer(get_text(\"content_required\", \"ar\"))\n        return\n    \n    await state.update_data(content_en=content_en)\n    \n    # Ask for optional image\n    await message.answer(\n        get_text(\"announcement_add_image_optional\", \"ar\"),\n        reply_markup=get_announcement_menu_keyboard(\"ar\")\n    )\n    await state.set_state(AnnouncementStates.adding_image)\n\n@router.callback_query(AnnouncementStates.adding_image, F.data == \"skip_image\")\n@admin_required\nasync def skip_image(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Skip image and proceed to targeting\"\"\"\n    await callback.message.edit_text(\n        get_text(\"announcement_select_target\", \"ar\"),\n        reply_markup=get_announcement_targeting_keyboard(\"ar\")\n    )\n    await state.set_state(AnnouncementStates.selecting_target)\n    await callback.answer()\n\n@router.message(AnnouncementStates.adding_image, F.photo)\n@admin_required\nasync def receive_announcement_image(message: Message, state: FSMContext):\n    \"\"\"Receive announcement image\"\"\"\n    try:\n        # Get the largest photo\n        photo = message.photo[-1]\n        file_id = photo.file_id\n        \n        await state.update_data(image_file_id=file_id)\n        \n        await message.answer(\n            get_text(\"image_added_successfully\", \"ar\"),\n            reply_markup=get_announcement_targeting_keyboard(\"ar\")\n        )\n        await state.set_state(AnnouncementStates.selecting_target)\n        \n    except Exception as e:\n        logger.error(f\"Error receiving image: {e}\")\n        await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.selecting_target, F.data == \"announce_all\")\n@admin_required\nasync def target_all_users(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Target all users for announcement\"\"\"\n    async with session_maker() as session:\n        try:\n            total_users = await session.scalar(\n                select(func.count(User.id)).where(User.is_active == True)\n            )\n            \n            await state.update_data(target_type=\"all\", target_value=None)\n            \n            await callback.message.edit_text(\n                get_text(\"announcement_set_duration\", \"ar\").format(\n                    target=f\"All users ({total_users})\"\n                ),\n                reply_markup=get_announcement_duration_keyboard(\"ar\")\n            )\n            await state.set_state(AnnouncementStates.setting_duration)\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error targeting all users: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.selecting_target, F.data == \"announce_by_language\")\n@admin_required\nasync def target_by_language(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Target by language selection (simplified - you can expand this)\"\"\"\n    await state.update_data(target_type=\"language\", target_value=\"ar\")  # Default to Arabic\n    \n    await callback.message.edit_text(\n        get_text(\"announcement_set_duration\", \"ar\").format(\n            target=\"Arabic speakers\"\n        ),\n        reply_markup=get_announcement_duration_keyboard(\"ar\")\n    )\n    await state.set_state(AnnouncementStates.setting_duration)\n    await callback.answer()\n\n@router.callback_query(AnnouncementStates.setting_duration, F.data.startswith(\"duration_\"))\n@admin_required\nasync def set_announcement_duration(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Set announcement duration\"\"\"\n    duration_str = callback.data.split(\"_\")[1]\n    \n    # Convert duration to hours\n    duration_mapping = {\n        \"1h\": 1,\n        \"6h\": 6,\n        \"24h\": 24,\n        \"7d\": 168,  # 7 days in hours\n        \"permanent\": 0  # 0 means permanent\n    }\n    \n    duration_hours = duration_mapping.get(duration_str, 0)\n    await state.update_data(duration_hours=duration_hours)\n    \n    # Show confirmation\n    await show_announcement_confirmation(callback, state)\n\nasync def show_announcement_confirmation(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Show announcement confirmation\"\"\"\n    try:\n        data = await state.get_data()\n        \n        duration_text = \"\"\n        if data[\"duration_hours\"] == 0:\n            duration_text = \"Permanent\"\n        else:\n            duration_text = f\"{data['duration_hours']} hours\"\n        \n        target_text = \"\"\n        if data[\"target_type\"] == \"all\":\n            target_text = \"All active users\"\n        elif data[\"target_type\"] == \"language\":\n            target_text = f\"Language: {data.get('target_value', 'N/A')}\"\n        \n        confirmation_text = get_text(\"announcement_confirmation\", \"ar\").format(\n            title_ar=data[\"title_ar\"],\n            title_en=data[\"title_en\"],\n            content_ar=data[\"content_ar\"][:100] + \"...\" if len(data[\"content_ar\"]) > 100 else data[\"content_ar\"],\n            content_en=data[\"content_en\"][:100] + \"...\" if len(data[\"content_en\"]) > 100 else data[\"content_en\"],\n            target=target_text,\n            duration=duration_text,\n            has_image=\"Yes\" if data.get(\"image_file_id\") else \"No\"\n        )\n        \n        await callback.message.edit_text(\n            confirmation_text,\n            reply_markup=get_announcement_confirmation_keyboard(\"ar\")\n        )\n        await state.set_state(AnnouncementStates.confirming)\n        await callback.answer()\n        \n    except Exception as e:\n        logger.error(f\"Error showing confirmation: {e}\")\n        await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.confirming, F.data == \"confirm_announcement\")\n@admin_required\nasync def confirm_announcement(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Confirm and create announcement\"\"\"\n    async with session_maker() as session:\n        try:\n            data = await state.get_data()\n            \n            # Calculate expiration time\n            expires_at = None\n            if data[\"duration_hours\"] > 0:\n                expires_at = datetime.now(timezone.utc) + timedelta(hours=data[\"duration_hours\"])\n            \n            # Create announcement\n            announcement = Announcement(\n                title_ar=data[\"title_ar\"],\n                title_en=data[\"title_en\"],\n                content_ar=data[\"content_ar\"],\n                content_en=data[\"content_en\"],\n                image_url=data.get(\"image_file_id\"),  # Store file_id as URL for simplicity\n                display_duration=data[\"duration_hours\"],\n                target_language=data.get(\"target_value\") if data[\"target_type\"] == \"language\" else None,\n                expires_at=expires_at,\n                scheduled_at=datetime.now(timezone.utc)\n            )\n            \n            session.add(announcement)\n            await session.flush()  # Get the ID\n            \n            # Create delivery records for target users\n            if data[\"target_type\"] == \"all\":\n                # Get all active users\n                result = await session.execute(\n                    select(User.id).where(User.is_active == True)\n                )\n                user_ids = [row[0] for row in result.fetchall()]\n            elif data[\"target_type\"] == \"language\":\n                # Get users by language\n                result = await session.execute(\n                    select(User.id).where(\n                        User.is_active == True,\n                        User.language_code == data[\"target_value\"]\n                    )\n                )\n                user_ids = [row[0] for row in result.fetchall()]\n            else:\n                user_ids = []\n            \n            # Create delivery records\n            for user_id in user_ids:\n                delivery = AnnouncementDelivery(\n                    announcement_id=announcement.id,\n                    user_id=user_id\n                )\n                session.add(delivery)\n            \n            await session.commit()\n            \n            await callback.message.edit_text(\n                get_text(\"announcement_created\", \"ar\").format(\n                    announcement_id=announcement.id,\n                    target_count=len(user_ids)\n                )\n            )\n            \n            await state.clear()\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error creating announcement: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(AnnouncementStates.confirming, F.data == \"cancel_announcement\")\n@admin_required\nasync def cancel_announcement(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Cancel announcement creation\"\"\"\n    await callback.message.edit_text(\n        get_text(\"announcement_cancelled\", \"ar\")\n    )\n    await state.clear()\n    await callback.answer()\n","size_bytes":12080},"backup_server_files/handlers/broadcast.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBroadcast handler for mass messaging\nHandles broadcast creation, targeting, and delivery management\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery, InputMediaPhoto\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\n\nfrom models import User, Outbox, OutboxType, OutboxStatus, Language, Country\nfrom services.i18n import get_text\nfrom utils.auth import admin_required\nfrom utils.keyboards import (\n    get_broadcast_targeting_keyboard, get_broadcast_confirmation_keyboard,\n    get_language_filter_keyboard, get_country_filter_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass BroadcastStates(StatesGroup):\n    selecting_target = State()\n    entering_message = State()\n    adding_media = State()\n    confirming = State()\n\n@router.message(F.text == \"/broadcast\")\n@admin_required\nasync def start_broadcast(message: Message, state: FSMContext, session_maker):\n    \"\"\"Start broadcast creation process\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get statistics for targeting options\n            total_users = await session.scalar(\n                select(func.count(User.id)).where(User.is_active == True)\n            )\n            \n            # Get language distribution\n            lang_result = await session.execute(\n                select(User.language_code, func.count(User.id))\n                .where(User.is_active == True)\n                .group_by(User.language_code)\n            )\n            lang_stats = dict(lang_result.fetchall())\n            \n            # Get country distribution\n            country_result = await session.execute(\n                select(User.country_code, func.count(User.id))\n                .where(User.is_active == True)\n                .group_by(User.country_code)\n            )\n            country_stats = dict(country_result.fetchall())\n            \n            # Format targeting options\n            stats_text = get_text(\"broadcast_targeting_stats\", \"ar\").format(\n                total_users=total_users,\n                lang_stats=\", \".join([f\"{k}: {v}\" for k, v in lang_stats.items()]),\n                country_stats=\", \".join([f\"{k}: {v}\" for k, v in country_stats.items()])\n            )\n            \n            await message.answer(\n                stats_text,\n                reply_markup=get_broadcast_targeting_keyboard(\"ar\")\n            )\n            \n            await state.set_state(BroadcastStates.selecting_target)\n            await state.update_data(\n                total_users=total_users,\n                lang_stats=lang_stats,\n                country_stats=country_stats\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error starting broadcast: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.selecting_target, F.data == \"broadcast_all\")\n@admin_required\nasync def select_broadcast_all(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Select broadcast to all users\"\"\"\n    await state.update_data(target_type=\"all\")\n    await callback.message.edit_text(\n        get_text(\"broadcast_enter_message\", \"ar\")\n    )\n    await state.set_state(BroadcastStates.entering_message)\n    await callback.answer()\n\n@router.callback_query(BroadcastStates.selecting_target, F.data == \"broadcast_by_language\")\n@admin_required\nasync def select_broadcast_by_language(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Select broadcast by language\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get available languages with user counts\n            result = await session.execute(\n                select(Language.code, Language.native_name, func.count(User.id))\n                .join(User, User.language_code == Language.code)\n                .where(Language.is_active == True, User.is_active == True)\n                .group_by(Language.code, Language.native_name)\n            )\n            languages = result.fetchall()\n            \n            if not languages:\n                await callback.answer(get_text(\"no_languages_with_users\", \"ar\"))\n                return\n            \n            await callback.message.edit_text(\n                get_text(\"select_target_language\", \"ar\"),\n                reply_markup=get_language_filter_keyboard(languages, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing language selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.selecting_target, F.data == \"broadcast_by_country\")\n@admin_required\nasync def select_broadcast_by_country(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Select broadcast by country\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get available countries with user counts\n            result = await session.execute(\n                select(Country.code, Country.native_name, func.count(User.id))\n                .join(User, User.country_code == Country.code)\n                .where(Country.is_active == True, User.is_active == True)\n                .group_by(Country.code, Country.native_name)\n            )\n            countries = result.fetchall()\n            \n            if not countries:\n                await callback.answer(get_text(\"no_countries_with_users\", \"ar\"))\n                return\n            \n            await callback.message.edit_text(\n                get_text(\"select_target_country\", \"ar\"),\n                reply_markup=get_country_filter_keyboard(countries, \"ar\")\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing country selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.selecting_target, F.data.startswith(\"lang_filter_\"))\n@admin_required\nasync def select_language_filter(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select specific language for broadcast\"\"\"\n    language_code = callback.data.split(\"_\")[-1]\n    await state.update_data(target_type=\"language\", target_value=language_code)\n    \n    await callback.message.edit_text(\n        get_text(\"broadcast_enter_message\", \"ar\").format(\n            target=f\"Language: {language_code.upper()}\"\n        )\n    )\n    await state.set_state(BroadcastStates.entering_message)\n    await callback.answer()\n\n@router.callback_query(BroadcastStates.selecting_target, F.data.startswith(\"country_filter_\"))\n@admin_required\nasync def select_country_filter(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Select specific country for broadcast\"\"\"\n    country_code = callback.data.split(\"_\")[-1]\n    await state.update_data(target_type=\"country\", target_value=country_code)\n    \n    await callback.message.edit_text(\n        get_text(\"broadcast_enter_message\", \"ar\").format(\n            target=f\"Country: {country_code.upper()}\"\n        )\n    )\n    await state.set_state(BroadcastStates.entering_message)\n    await callback.answer()\n\n@router.message(BroadcastStates.entering_message)\n@admin_required\nasync def receive_broadcast_message(message: Message, state: FSMContext):\n    \"\"\"Receive broadcast message text\"\"\"\n    try:\n        broadcast_text = message.text or message.caption or \"\"\n        \n        if not broadcast_text.strip():\n            await message.answer(get_text(\"broadcast_message_required\", \"ar\"))\n            return\n        \n        # Store message data\n        await state.update_data(\n            message_text=broadcast_text,\n            message_entities=message.entities,\n            message_type=\"text\"\n        )\n        \n        # Check if message has media\n        if message.photo or message.video or message.document:\n            if message.photo:\n                file_id = message.photo[-1].file_id\n                await state.update_data(message_type=\"photo\", file_id=file_id)\n            elif message.video:\n                await state.update_data(message_type=\"video\", file_id=message.video.file_id)\n            elif message.document:\n                await state.update_data(message_type=\"document\", file_id=message.document.file_id)\n        \n        # Show confirmation\n        await show_broadcast_confirmation(message, state)\n        \n    except Exception as e:\n        logger.error(f\"Error receiving broadcast message: {e}\")\n        await message.answer(get_text(\"error_occurred\", \"ar\"))\n\nasync def show_broadcast_confirmation(message: Message, state: FSMContext):\n    \"\"\"Show broadcast confirmation with preview\"\"\"\n    try:\n        data = await state.get_data()\n        \n        # Calculate target audience\n        target_info = \"\"\n        if data[\"target_type\"] == \"all\":\n            target_info = f\"All active users ({data.get('total_users', '?')} users)\"\n        elif data[\"target_type\"] == \"language\":\n            lang_code = data[\"target_value\"]\n            user_count = data.get(\"lang_stats\", {}).get(lang_code, \"?\")\n            target_info = f\"Language: {lang_code.upper()} ({user_count} users)\"\n        elif data[\"target_type\"] == \"country\":\n            country_code = data[\"target_value\"]\n            user_count = data.get(\"country_stats\", {}).get(country_code, \"?\")\n            target_info = f\"Country: {country_code.upper()} ({user_count} users)\"\n        \n        confirmation_text = get_text(\"broadcast_confirmation\", \"ar\").format(\n            target=target_info,\n            message_preview=data[\"message_text\"][:200] + \"...\" if len(data[\"message_text\"]) > 200 else data[\"message_text\"]\n        )\n        \n        await message.answer(\n            confirmation_text,\n            reply_markup=get_broadcast_confirmation_keyboard(\"ar\")\n        )\n        \n        await state.set_state(BroadcastStates.confirming)\n        \n    except Exception as e:\n        logger.error(f\"Error showing confirmation: {e}\")\n        await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.confirming, F.data == \"confirm_broadcast\")\n@admin_required\nasync def confirm_broadcast(callback: CallbackQuery, state: FSMContext, session_maker, broadcast_service):\n    \"\"\"Confirm and start broadcast\"\"\"\n    async with session_maker() as session:\n        try:\n            data = await state.get_data()\n            \n            # Create outbox entry for broadcast\n            outbox = Outbox(\n                user_id=1,  # System user for broadcasts\n                type=OutboxType.BROADCAST,\n                status=OutboxStatus.PROCESSING,\n                subject=f\"Broadcast to {data['target_type']}\",\n                content=data[\"message_text\"]\n            )\n            session.add(outbox)\n            await session.flush()\n            \n            # Queue broadcast for delivery\n            await broadcast_service.queue_broadcast(\n                outbox_id=outbox.id,\n                target_type=data[\"target_type\"],\n                target_value=data.get(\"target_value\"),\n                message_text=data[\"message_text\"],\n                message_type=data.get(\"message_type\", \"text\"),\n                file_id=data.get(\"file_id\"),\n                message_entities=data.get(\"message_entities\")\n            )\n            \n            await session.commit()\n            \n            await callback.message.edit_text(\n                get_text(\"broadcast_queued\", \"ar\").format(\n                    broadcast_id=outbox.id\n                )\n            )\n            \n            await state.clear()\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error confirming broadcast: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(BroadcastStates.confirming, F.data == \"cancel_broadcast\")\n@admin_required\nasync def cancel_broadcast(callback: CallbackQuery, state: FSMContext):\n    \"\"\"Cancel broadcast\"\"\"\n    await callback.message.edit_text(\n        get_text(\"broadcast_cancelled\", \"ar\")\n    )\n    await state.clear()\n    await callback.answer()\n","size_bytes":12292},"backup_server_files/handlers/start.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nStart handler for user registration, phone verification, and main menu\nHandles /start command, phone number collection, and customer code generation\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.filters import Command, CommandStart\nfrom aiogram.types import Message, CallbackQuery, Contact\nfrom aiogram.fsm.context import FSMContext\nfrom aiogram.fsm.state import State, StatesGroup\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom models import User\nfrom services.i18n import get_text, get_user_language\nfrom services.customer_id import generate_customer_code\nfrom utils.keyboards import (\n    get_main_menu_keyboard, get_phone_share_keyboard, \n    get_contact_confirmation_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\nclass RegistrationStates(StatesGroup):\n    waiting_for_phone = State()\n    confirming_phone = State()\n\n@router.message(CommandStart())\nasync def start_command(message: Message, state: FSMContext, session_maker):\n    \"\"\"Handle /start command and user registration\"\"\"\n    async with session_maker() as session:\n        try:\n            # Get or create user\n            user = await get_or_create_user(session, message.from_user)\n            await session.commit()\n            \n            # Get user's language for responses\n            lang = get_user_language(user.language_code)\n            \n            if not user.phone_number:\n                # First time user - request phone number\n                await message.answer(\n                    get_text(\"welcome_new_user\", lang).format(\n                        first_name=user.first_name\n                    ),\n                    reply_markup=get_phone_share_keyboard(lang)\n                )\n                await state.set_state(RegistrationStates.waiting_for_phone)\n            else:\n                # Returning user - show main menu\n                await show_main_menu(message, user, session)\n                \n        except Exception as e:\n            logger.error(f\"Error in start command: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(RegistrationStates.waiting_for_phone, F.contact)\nasync def handle_phone_contact(message: Message, state: FSMContext, session_maker):\n    \"\"\"Handle phone number shared via contact\"\"\"\n    async with session_maker() as session:\n        try:\n            contact: Contact = message.contact\n            \n            # Verify it's the user's own contact\n            if contact.user_id != message.from_user.id:\n                user = await get_user_by_telegram_id(session, message.from_user.id)\n                lang = get_user_language(user.language_code if user else \"ar\")\n                await message.answer(get_text(\"phone_must_be_yours\", lang))\n                return\n            \n            # Update user with phone number\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if user:\n                user.phone_number = contact.phone_number\n                user.updated_at = datetime.now(timezone.utc)\n                \n                # Generate customer code if not exists\n                if not user.customer_code:\n                    user.customer_code = await generate_customer_code(session)\n                \n                await session.commit()\n                \n                lang = get_user_language(user.language_code)\n                \n                # Show confirmation\n                await message.answer(\n                    get_text(\"phone_registered_success\", lang).format(\n                        phone=contact.phone_number,\n                        customer_code=user.customer_code\n                    ),\n                    reply_markup=get_contact_confirmation_keyboard(lang)\n                )\n                \n                await state.set_state(RegistrationStates.confirming_phone)\n            \n        except Exception as e:\n            logger.error(f\"Error handling phone contact: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(RegistrationStates.confirming_phone, F.data == \"confirm_phone\")\nasync def confirm_phone_registration(callback: CallbackQuery, state: FSMContext, session_maker):\n    \"\"\"Confirm phone registration and show main menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if user:\n                await callback.answer()\n                await callback.message.delete()\n                await show_main_menu(callback.message, user, session)\n                await state.clear()\n            \n        except Exception as e:\n            logger.error(f\"Error confirming phone: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"💰 إيداع\", \"💰 Deposit\"]))\nasync def handle_deposit(message: Message, session_maker):\n    \"\"\"Handle deposit request\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            await message.answer(get_text(\"deposit_instructions\", lang))\n            \n        except Exception as e:\n            logger.error(f\"Error handling deposit: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"💸 سحب\", \"💸 Withdraw\"]))\nasync def handle_withdraw(message: Message, session_maker):\n    \"\"\"Handle withdrawal request\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            await message.answer(get_text(\"withdraw_instructions\", lang))\n            \n        except Exception as e:\n            logger.error(f\"Error handling withdraw: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"📨 شكاوى\", \"📨 Complaints\"]))\nasync def handle_complaints(message: Message, session_maker):\n    \"\"\"Handle complaints submission\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            await message.answer(get_text(\"complaints_instructions\", lang))\n            \n        except Exception as e:\n            logger.error(f\"Error handling complaints: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.message(F.text.in_([\"👤 حسابي\", \"👤 My Account\"]))\nasync def handle_my_account(message: Message, session_maker):\n    \"\"\"Show user account information\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            \n            # Format account information\n            account_info = get_text(\"account_info\", lang).format(\n                first_name=user.first_name,\n                last_name=user.last_name or \"\",\n                username=f\"@{user.username}\" if user.username else get_text(\"not_set\", lang),\n                phone=user.phone_number or get_text(\"not_set\", lang),\n                customer_code=user.customer_code,\n                language=user.language_code.upper(),\n                country=user.country_code.upper(),\n                notifications=get_text(\"enabled\", lang) if user.notifications_enabled else get_text(\"disabled\", lang)\n            )\n            \n            await message.answer(account_info)\n            \n        except Exception as e:\n            logger.error(f\"Error showing account: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\nasync def get_or_create_user(session: AsyncSession, telegram_user) -> User:\n    \"\"\"Get existing user or create new one\"\"\"\n    # Try to get existing user\n    result = await session.execute(\n        select(User).where(User.telegram_id == telegram_user.id)\n    )\n    user = result.scalar_one_or_none()\n    \n    if user:\n        # Update user information\n        user.username = telegram_user.username\n        user.first_name = telegram_user.first_name\n        user.last_name = telegram_user.last_name\n        user.last_activity = datetime.now(timezone.utc)\n        user.updated_at = datetime.now(timezone.utc)\n    else:\n        # Create new user\n        user = User(\n            telegram_id=telegram_user.id,\n            username=telegram_user.username,\n            first_name=telegram_user.first_name,\n            last_name=telegram_user.last_name,\n            language_code=telegram_user.language_code or \"ar\",\n            last_activity=datetime.now(timezone.utc)\n        )\n        session.add(user)\n    \n    return user\n\nasync def get_user_by_telegram_id(session: AsyncSession, telegram_id: int) -> User:\n    \"\"\"Get user by telegram ID\"\"\"\n    result = await session.execute(\n        select(User).where(User.telegram_id == telegram_id)\n    )\n    return result.scalar_one_or_none()\n\nasync def show_main_menu(message: Message, user: User, session: AsyncSession):\n    \"\"\"Show main menu to user\"\"\"\n    lang = get_user_language(user.language_code)\n    \n    welcome_back_text = get_text(\"welcome_back\", lang).format(\n        first_name=user.first_name,\n        customer_code=user.customer_code\n    )\n    \n    await message.answer(\n        welcome_back_text,\n        reply_markup=get_main_menu_keyboard(lang)\n    )\n","size_bytes":9884},"backup_server_files/handlers/user_settings.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nUser settings handler for language and country selection\nHandles user preference changes and localization updates\n\"\"\"\n\nimport logging\nfrom datetime import datetime, timezone\nfrom aiogram import Router, F\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.fsm.context import FSMContext\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\nfrom models import User, Language, Country\nfrom services.i18n import get_text, get_user_language, load_translations\nfrom utils.keyboards import (\n    get_language_selection_keyboard, get_country_selection_keyboard,\n    get_settings_keyboard, get_main_menu_keyboard\n)\n\nlogger = logging.getLogger(__name__)\nrouter = Router()\n\n@router.message(F.text.in_([\"🌐 اللغة\", \"🌐 Language\", \"⚙️ الإعدادات\", \"⚙️ Settings\"]))\nasync def show_settings_menu(message: Message, session_maker):\n    \"\"\"Show settings menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, message.from_user.id)\n            if not user:\n                return\n            \n            lang = get_user_language(user.language_code)\n            \n            await message.answer(\n                get_text(\"settings_menu\", lang),\n                reply_markup=get_settings_keyboard(lang)\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error showing settings menu: {e}\")\n            await message.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"change_language\")\nasync def show_language_selection(callback: CallbackQuery, session_maker):\n    \"\"\"Show language selection menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Get available languages\n            result = await session.execute(\n                select(Language).where(Language.is_active == True).order_by(Language.name)\n            )\n            languages = result.scalars().all()\n            \n            lang = get_user_language(user.language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"select_language\", lang),\n                reply_markup=get_language_selection_keyboard(languages, user.language_code, lang)\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing language selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"lang_\"))\nasync def change_language(callback: CallbackQuery, session_maker):\n    \"\"\"Change user language\"\"\"\n    async with session_maker() as session:\n        try:\n            language_code = callback.data.split(\"_\")[1]\n            \n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Verify language exists and is active\n            result = await session.execute(\n                select(Language).where(\n                    Language.code == language_code,\n                    Language.is_active == True\n                )\n            )\n            language = result.scalar_one_or_none()\n            \n            if not language:\n                await callback.answer(get_text(\"language_not_available\", \"ar\"))\n                return\n            \n            # Update user language\n            old_lang = user.language_code\n            user.language_code = language_code\n            user.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            # Get new language text\n            new_lang = get_user_language(language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"language_changed\", new_lang).format(\n                    language_name=language.native_name\n                )\n            )\n            \n            # Show updated main menu\n            await callback.message.answer(\n                get_text(\"main_menu_updated\", new_lang),\n                reply_markup=get_main_menu_keyboard(new_lang)\n            )\n            \n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error changing language: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"change_country\")\nasync def show_country_selection(callback: CallbackQuery, session_maker):\n    \"\"\"Show country selection menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Get available countries\n            result = await session.execute(\n                select(Country).where(Country.is_active == True).order_by(Country.name)\n            )\n            countries = result.scalars().all()\n            \n            lang = get_user_language(user.language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"select_country\", lang),\n                reply_markup=get_country_selection_keyboard(countries, user.country_code, lang)\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error showing country selection: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data.startswith(\"country_\"))\nasync def change_country(callback: CallbackQuery, session_maker):\n    \"\"\"Change user country\"\"\"\n    async with session_maker() as session:\n        try:\n            country_code = callback.data.split(\"_\")[1]\n            \n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Verify country exists and is active\n            result = await session.execute(\n                select(Country).where(\n                    Country.code == country_code,\n                    Country.is_active == True\n                )\n            )\n            country = result.scalar_one_or_none()\n            \n            if not country:\n                lang = get_user_language(user.language_code)\n                await callback.answer(get_text(\"country_not_available\", lang))\n                return\n            \n            # Update user country\n            user.country_code = country_code\n            user.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            lang = get_user_language(user.language_code)\n            \n            country_name = country.native_name if lang == \"ar\" else country.name\n            \n            await callback.message.edit_text(\n                get_text(\"country_changed\", lang).format(\n                    country_name=country_name\n                )\n            )\n            \n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error changing country: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"toggle_notifications\")\nasync def toggle_notifications(callback: CallbackQuery, session_maker):\n    \"\"\"Toggle user notifications\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            # Toggle notifications\n            user.notifications_enabled = not user.notifications_enabled\n            user.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n            \n            lang = get_user_language(user.language_code)\n            \n            status = get_text(\"enabled\", lang) if user.notifications_enabled else get_text(\"disabled\", lang)\n            \n            await callback.message.edit_text(\n                get_text(\"notifications_toggled\", lang).format(status=status)\n            )\n            \n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error toggling notifications: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\n@router.callback_query(F.data == \"back_to_settings\")\nasync def back_to_settings(callback: CallbackQuery, session_maker):\n    \"\"\"Go back to settings menu\"\"\"\n    async with session_maker() as session:\n        try:\n            user = await get_user_by_telegram_id(session, callback.from_user.id)\n            if not user:\n                await callback.answer()\n                return\n            \n            lang = get_user_language(user.language_code)\n            \n            await callback.message.edit_text(\n                get_text(\"settings_menu\", lang),\n                reply_markup=get_settings_keyboard(lang)\n            )\n            await callback.answer()\n            \n        except Exception as e:\n            logger.error(f\"Error going back to settings: {e}\")\n            await callback.answer(get_text(\"error_occurred\", \"ar\"))\n\nasync def get_user_by_telegram_id(session: AsyncSession, telegram_id: int) -> User:\n    \"\"\"Get user by telegram ID\"\"\"\n    result = await session.execute(\n        select(User).where(User.telegram_id == telegram_id)\n    )\n    return result.scalar_one_or_none()\n","size_bytes":9720},"backup_server_files/services/broadcast_service.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nBroadcast service for handling mass messaging\nManages broadcast queues, rate limiting, and delivery tracking\n\"\"\"\n\nimport asyncio\nimport logging\nfrom datetime import datetime, timezone\nfrom typing import Optional, List, Dict, Any\nfrom aiogram import Bot\nfrom aiogram.exceptions import TelegramBadRequest, TelegramForbiddenError\nfrom aiogram.types import InputMediaPhoto, InputMediaVideo, InputMediaDocument\nfrom sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker\nfrom sqlalchemy import select, and_\n\nfrom models import (\n    User, Outbox, OutboxRecipient, OutboxStatus, \n    DeliveryStatus, OutboxType\n)\nfrom config import (\n    BROADCAST_RATE_LIMIT, BROADCAST_CHUNK_SIZE, \n    BROADCAST_RETRY_ATTEMPTS, BROADCAST_RETRY_DELAY\n)\n\nlogger = logging.getLogger(__name__)\n\nclass BroadcastService:\n    \"\"\"Service for handling broadcast operations\"\"\"\n    \n    def __init__(self, bot: Bot, session_maker: async_sessionmaker):\n        self.bot = bot\n        self.session_maker = session_maker\n        self.broadcast_queue = asyncio.Queue()\n        self.is_running = False\n        \n    async def queue_broadcast(self, outbox_id: int, target_type: str, \n                            target_value: Optional[str], message_text: str,\n                            message_type: str = \"text\", file_id: Optional[str] = None,\n                            message_entities: Optional[List] = None):\n        \"\"\"Queue a broadcast for delivery\"\"\"\n        broadcast_data = {\n            \"outbox_id\": outbox_id,\n            \"target_type\": target_type,\n            \"target_value\": target_value,\n            \"message_text\": message_text,\n            \"message_type\": message_type,\n            \"file_id\": file_id,\n            \"message_entities\": message_entities\n        }\n        \n        await self.broadcast_queue.put(broadcast_data)\n        logger.info(f\"Queued broadcast {outbox_id} for delivery\")\n    \n    async def worker(self):\n        \"\"\"Background worker for processing broadcast queue\"\"\"\n        self.is_running = True\n        logger.info(\"Broadcast service worker started\")\n        \n        while self.is_running:\n            try:\n                # Get broadcast from queue with timeout\n                try:\n                    broadcast = await asyncio.wait_for(\n                        self.broadcast_queue.get(), timeout=5.0\n                    )\n                except asyncio.TimeoutError:\n                    continue\n                \n                await self.process_broadcast(broadcast)\n                \n            except Exception as e:\n                logger.error(f\"Error in broadcast worker: {e}\")\n                await asyncio.sleep(1)\n    \n    async def process_broadcast(self, broadcast: Dict[str, Any]):\n        \"\"\"Process a single broadcast\"\"\"\n        outbox_id = broadcast[\"outbox_id\"]\n        \n        try:\n            async with self.session_maker() as session:\n                # Get target users\n                users = await self.get_target_users(\n                    session, broadcast[\"target_type\"], broadcast.get(\"target_value\")\n                )\n                \n                if not users:\n                    logger.warning(f\"No target users found for broadcast {outbox_id}\")\n                    await self.update_broadcast_status(session, outbox_id, OutboxStatus.COMPLETED)\n                    return\n                \n                # Create recipient records\n                await self.create_recipient_records(session, outbox_id, users)\n                await session.commit()\n                \n                logger.info(f\"Starting delivery for broadcast {outbox_id} to {len(users)} users\")\n                \n                # Process in chunks\n                for chunk in self.chunk_list(users, BROADCAST_CHUNK_SIZE):\n                    await self.send_to_chunk(session, outbox_id, chunk, broadcast)\n                    \n                    # Rate limiting\n                    sleep_time = len(chunk) / BROADCAST_RATE_LIMIT\n                    await asyncio.sleep(sleep_time)\n                \n                # Update broadcast status\n                await self.update_broadcast_status(session, outbox_id, OutboxStatus.COMPLETED)\n                logger.info(f\"Completed broadcast {outbox_id}\")\n                \n        except Exception as e:\n            logger.error(f\"Error processing broadcast {outbox_id}: {e}\")\n            async with self.session_maker() as session:\n                await self.update_broadcast_status(session, outbox_id, OutboxStatus.FAILED)\n    \n    async def get_target_users(self, session: AsyncSession, target_type: str, \n                             target_value: Optional[str]) -> List[User]:\n        \"\"\"Get target users based on targeting criteria\"\"\"\n        base_query = select(User).where(\n            and_(User.is_active == True, User.is_banned == False)\n        )\n        \n        if target_type == \"all\":\n            result = await session.execute(base_query)\n        elif target_type == \"language\":\n            result = await session.execute(\n                base_query.where(User.language_code == target_value)\n            )\n        elif target_type == \"country\":\n            result = await session.execute(\n                base_query.where(User.country_code == target_value)\n            )\n        else:\n            logger.warning(f\"Unknown target type: {target_type}\")\n            return []\n        \n        return list(result.scalars().all())\n    \n    async def create_recipient_records(self, session: AsyncSession, \n                                     outbox_id: int, users: List[User]):\n        \"\"\"Create recipient tracking records\"\"\"\n        for user in users:\n            recipient = OutboxRecipient(\n                outbox_id=outbox_id,\n                user_id=user.id,\n                status=DeliveryStatus.PENDING\n            )\n            session.add(recipient)\n    \n    async def send_to_chunk(self, session: AsyncSession, outbox_id: int, \n                          users: List[User], broadcast: Dict[str, Any]):\n        \"\"\"Send broadcast to a chunk of users\"\"\"\n        for user in users:\n            try:\n                success = await self.send_to_user(user, broadcast)\n                \n                # Update recipient status\n                await self.update_recipient_status(\n                    session, outbox_id, user.id,\n                    DeliveryStatus.SENT if success else DeliveryStatus.FAILED\n                )\n                \n            except Exception as e:\n                logger.error(f\"Error sending to user {user.telegram_id}: {e}\")\n                await self.update_recipient_status(\n                    session, outbox_id, user.id, DeliveryStatus.FAILED, str(e)\n                )\n        \n        await session.commit()\n    \n    async def send_to_user(self, user: User, broadcast: Dict[str, Any]) -> bool:\n        \"\"\"Send broadcast message to a single user\"\"\"\n        try:\n            message_text = broadcast[\"message_text\"]\n            message_type = broadcast.get(\"message_type\", \"text\")\n            file_id = broadcast.get(\"file_id\")\n            \n            if message_type == \"text\":\n                await self.bot.send_message(\n                    chat_id=user.telegram_id,\n                    text=message_text,\n                    entities=broadcast.get(\"message_entities\")\n                )\n            elif message_type == \"photo\" and file_id:\n                await self.bot.send_photo(\n                    chat_id=user.telegram_id,\n                    photo=file_id,\n                    caption=message_text,\n                    caption_entities=broadcast.get(\"message_entities\")\n                )\n            elif message_type == \"video\" and file_id:\n                await self.bot.send_video(\n                    chat_id=user.telegram_id,\n                    video=file_id,\n                    caption=message_text,\n                    caption_entities=broadcast.get(\"message_entities\")\n                )\n            elif message_type == \"document\" and file_id:\n                await self.bot.send_document(\n                    chat_id=user.telegram_id,\n                    document=file_id,\n                    caption=message_text,\n                    caption_entities=broadcast.get(\"message_entities\")\n                )\n            \n            return True\n            \n        except TelegramForbiddenError:\n            # User blocked the bot\n            logger.info(f\"User {user.telegram_id} blocked the bot\")\n            return False\n        except TelegramBadRequest as e:\n            # Invalid user or other API error\n            logger.warning(f\"Bad request for user {user.telegram_id}: {e}\")\n            return False\n        except Exception as e:\n            logger.error(f\"Unexpected error sending to user {user.telegram_id}: {e}\")\n            return False\n    \n    async def update_broadcast_status(self, session: AsyncSession, \n                                    outbox_id: int, status: OutboxStatus):\n        \"\"\"Update broadcast status\"\"\"\n        result = await session.execute(\n            select(Outbox).where(Outbox.id == outbox_id)\n        )\n        outbox = result.scalar_one_or_none()\n        \n        if outbox:\n            outbox.status = status\n            outbox.updated_at = datetime.now(timezone.utc)\n            await session.commit()\n    \n    async def update_recipient_status(self, session: AsyncSession, outbox_id: int,\n                                    user_id: int, status: DeliveryStatus,\n                                    error_message: Optional[str] = None):\n        \"\"\"Update recipient delivery status\"\"\"\n        result = await session.execute(\n            select(OutboxRecipient).where(\n                and_(\n                    OutboxRecipient.outbox_id == outbox_id,\n                    OutboxRecipient.user_id == user_id\n                )\n            )\n        )\n        recipient = result.scalar_one_or_none()\n        \n        if recipient:\n            recipient.status = status\n            recipient.last_attempt = datetime.now(timezone.utc)\n            recipient.attempts += 1\n            \n            if status == DeliveryStatus.SENT:\n                recipient.delivered_at = datetime.now(timezone.utc)\n            elif error_message:\n                recipient.error_message = error_message\n    \n    @staticmethod\n    def chunk_list(lst: List, chunk_size: int) -> List[List]:\n        \"\"\"Split list into chunks\"\"\"\n        return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]\n    \n    async def stop(self):\n        \"\"\"Stop the broadcast service\"\"\"\n        self.is_running = False\n        logger.info(\"Broadcast service stopping...\")\n","size_bytes":10646},"backup_server_files/services/customer_id.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nCustomer ID generation service\nGenerates unique customer codes for new users\n\"\"\"\n\nimport logging\nfrom datetime import datetime\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, func\nfrom models import User\nfrom config import CUSTOMER_ID_PREFIX, CUSTOMER_ID_YEAR_FORMAT\n\nlogger = logging.getLogger(__name__)\n\nasync def generate_customer_code(session: AsyncSession) -> str:\n    \"\"\"Generate unique customer code\"\"\"\n    try:\n        # Get current year\n        current_year = datetime.now().year\n        year_str = CUSTOMER_ID_YEAR_FORMAT or str(current_year)\n        \n        # Get the highest existing number for this year\n        pattern = f\"{CUSTOMER_ID_PREFIX}-{year_str}-%\"\n        \n        result = await session.execute(\n            select(func.max(User.customer_code))\n            .where(User.customer_code.like(pattern))\n        )\n        \n        max_code = result.scalar_one_or_none()\n        \n        if max_code:\n            try:\n                # Extract the number part and increment\n                parts = max_code.split('-')\n                if len(parts) >= 3:\n                    last_number = int(parts[-1])\n                    next_number = last_number + 1\n                else:\n                    next_number = 1\n            except (ValueError, IndexError):\n                next_number = 1\n        else:\n            next_number = 1\n        \n        # Format with leading zeros (6 digits)\n        customer_code = f\"{CUSTOMER_ID_PREFIX}-{year_str}-{next_number:06d}\"\n        \n        # Verify uniqueness (double-check)\n        existing = await session.execute(\n            select(User).where(User.customer_code == customer_code)\n        )\n        \n        if existing.scalar_one_or_none():\n            # If somehow exists, try with incremented number\n            next_number += 1\n            customer_code = f\"{CUSTOMER_ID_PREFIX}-{year_str}-{next_number:06d}\"\n        \n        logger.info(f\"Generated customer code: {customer_code}\")\n        return customer_code\n        \n    except Exception as e:\n        logger.error(f\"Error generating customer code: {e}\")\n        # Fallback: use timestamp-based code\n        timestamp = int(datetime.now().timestamp())\n        fallback_code = f\"{CUSTOMER_ID_PREFIX}-{year_str}-T{timestamp}\"\n        logger.warning(f\"Using fallback customer code: {fallback_code}\")\n        return fallback_code\n\nasync def is_customer_code_unique(session: AsyncSession, customer_code: str) -> bool:\n    \"\"\"Check if customer code is unique\"\"\"\n    try:\n        result = await session.execute(\n            select(User).where(User.customer_code == customer_code)\n        )\n        return result.scalar_one_or_none() is None\n    except Exception as e:\n        logger.error(f\"Error checking customer code uniqueness: {e}\")\n        return False\n\nasync def get_user_by_customer_code(session: AsyncSession, customer_code: str) -> User:\n    \"\"\"Get user by customer code\"\"\"\n    try:\n        result = await session.execute(\n            select(User).where(User.customer_code == customer_code)\n        )\n        return result.scalar_one_or_none()\n    except Exception as e:\n        logger.error(f\"Error getting user by customer code: {e}\")\n        return None\n","size_bytes":3239},"backup_server_files/services/i18n.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nInternationalization service for multi-language support\nLoads and manages translation files for Arabic and English\n\"\"\"\n\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import Dict, Any\n\nlogger = logging.getLogger(__name__)\n\n# Global translations storage\ntranslations: Dict[str, Dict[str, str]] = {}\n\ndef load_translations():\n    \"\"\"Load translation files\"\"\"\n    global translations\n    \n    translations_dir = Path(\"translations\")\n    \n    try:\n        # Load Arabic translations\n        ar_file = translations_dir / \"ar.json\"\n        if ar_file.exists():\n            with open(ar_file, 'r', encoding='utf-8') as f:\n                translations['ar'] = json.load(f)\n        else:\n            logger.warning(\"Arabic translations file not found\")\n            translations['ar'] = {}\n        \n        # Load English translations\n        en_file = translations_dir / \"en.json\"\n        if en_file.exists():\n            with open(en_file, 'r', encoding='utf-8') as f:\n                translations['en'] = json.load(f)\n        else:\n            logger.warning(\"English translations file not found\")\n            translations['en'] = {}\n        \n        logger.info(f\"Loaded translations for {len(translations)} languages\")\n        \n    except Exception as e:\n        logger.error(f\"Error loading translations: {e}\")\n        # Initialize with empty dictionaries to prevent crashes\n        translations = {'ar': {}, 'en': {}}\n\ndef get_text(key: str, language: str = \"ar\", **kwargs) -> str:\n    \"\"\"Get translated text by key and language\"\"\"\n    if not translations:\n        load_translations()\n    \n    # Get translation for the language or fall back to Arabic\n    lang_dict = translations.get(language, {})\n    \n    # Get the text or fall back to Arabic, then to the key itself\n    text = lang_dict.get(key)\n    if text is None and language != \"ar\":\n        text = translations.get(\"ar\", {}).get(key)\n    if text is None:\n        text = f\"[{key}]\"  # Fallback to show missing translation\n    \n    # Format with provided arguments\n    try:\n        return text.format(**kwargs)\n    except (KeyError, ValueError) as e:\n        logger.warning(f\"Error formatting text '{key}' for language '{language}': {e}\")\n        return text\n\ndef get_user_language(language_code: str = None) -> str:\n    \"\"\"Get user's language code with fallback\"\"\"\n    if language_code and language_code in translations:\n        return language_code\n    return \"ar\"  # Default to Arabic\n\ndef get_available_languages() -> list:\n    \"\"\"Get list of available languages\"\"\"\n    if not translations:\n        load_translations()\n    return list(translations.keys())\n\ndef is_rtl_language(language_code: str) -> bool:\n    \"\"\"Check if language is right-to-left\"\"\"\n    rtl_languages = ['ar', 'he', 'fa', 'ur']\n    return language_code in rtl_languages\n\n# Load translations on module import\nload_translations()\n","size_bytes":2898},"backup_server_files/utils/auth.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nAuthentication utilities for admin verification\nHandles admin permission checks and decorators\n\"\"\"\n\nimport logging\nfrom functools import wraps\nfrom typing import Callable, Any\nfrom aiogram.types import Message, CallbackQuery\n\nfrom config import ADMIN_USER_IDS\nfrom services.i18n import get_text\n\nlogger = logging.getLogger(__name__)\n\ndef is_admin(user_id: int) -> bool:\n    \"\"\"Check if user is an admin\"\"\"\n    return user_id in ADMIN_USER_IDS\n\ndef admin_required(func: Callable) -> Callable:\n    \"\"\"Decorator to require admin privileges\"\"\"\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Extract user from message or callback\n        user_id = None\n        message_obj = None\n        \n        for arg in args:\n            if isinstance(arg, Message):\n                user_id = arg.from_user.id\n                message_obj = arg\n                break\n            elif isinstance(arg, CallbackQuery):\n                user_id = arg.from_user.id\n                message_obj = arg.message if hasattr(arg, 'message') else arg\n                break\n        \n        if not user_id:\n            logger.warning(\"Could not extract user ID from arguments\")\n            return\n        \n        if not is_admin(user_id):\n            logger.warning(f\"Unauthorized admin access attempt by user {user_id}\")\n            \n            # Send unauthorized message\n            error_text = get_text(\"unauthorized_access\", \"ar\")\n            \n            if isinstance(message_obj, Message):\n                await message_obj.answer(error_text)\n            elif hasattr(message_obj, 'answer'):\n                await message_obj.answer(error_text)\n            elif hasattr(message_obj, 'message') and hasattr(message_obj.message, 'answer'):\n                await message_obj.message.answer(error_text)\n            \n            return\n        \n        # User is admin, proceed with function\n        return await func(*args, **kwargs)\n    \n    return wrapper\n\nasync def check_admin_permissions(user_id: int, required_level: str = \"basic\") -> bool:\n    \"\"\"Check admin permissions with different levels\"\"\"\n    if not is_admin(user_id):\n        return False\n    \n    # For now, all admins have the same level\n    # You can extend this to have different admin levels\n    return True\n\ndef get_admin_level(user_id: int) -> str:\n    \"\"\"Get admin level for user\"\"\"\n    if not is_admin(user_id):\n        return \"none\"\n    \n    # For now, all admins are \"super_admin\"\n    # You can extend this based on your needs\n    return \"super_admin\"\n\nasync def log_admin_action(user_id: int, action: str, details: str = \"\"):\n    \"\"\"Log admin actions for audit trail\"\"\"\n    logger.info(f\"Admin action - User: {user_id}, Action: {action}, Details: {details}\")\n    \n    # You can extend this to save to database for audit trail\n    # Example:\n    # async with session_maker() as session:\n    #     audit_log = AdminAuditLog(\n    #         admin_user_id=user_id,\n    #         action=action,\n    #         details=details,\n    #         timestamp=datetime.now(timezone.utc)\n    #     )\n    #     session.add(audit_log)\n    #     await session.commit()\n\nclass AdminContext:\n    \"\"\"Context manager for admin operations\"\"\"\n    \n    def __init__(self, user_id: int, action: str):\n        self.user_id = user_id\n        self.action = action\n        self.start_time = None\n    \n    async def __aenter__(self):\n        if not is_admin(self.user_id):\n            raise PermissionError(f\"User {self.user_id} is not an admin\")\n        \n        await log_admin_action(self.user_id, f\"Started: {self.action}\")\n        return self\n    \n    async def __aexit__(self, exc_type, exc_val, exc_tb):\n        if exc_type:\n            await log_admin_action(\n                self.user_id, \n                f\"Failed: {self.action}\",\n                f\"Error: {exc_val}\"\n            )\n        else:\n            await log_admin_action(self.user_id, f\"Completed: {self.action}\")\n\n# Example usage of AdminContext:\n# async with AdminContext(user_id, \"broadcast_creation\"):\n#     # Perform admin operation\n#     pass\n","size_bytes":4083},"backup_server_files/utils/keyboards.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nKeyboard utilities for creating inline and reply keyboards\nHandles all keyboard layouts for different bot functions\n\"\"\"\n\nfrom typing import List, Optional\nfrom aiogram.types import (\n    ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, \n    InlineKeyboardButton\n)\nfrom aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder\n\nfrom services.i18n import get_text\n\ndef get_main_menu_keyboard(language: str = \"ar\") -> ReplyKeyboardMarkup:\n    \"\"\"Create main menu reply keyboard\"\"\"\n    builder = ReplyKeyboardBuilder()\n    \n    # Main action buttons - 2 per row\n    builder.row(\n        KeyboardButton(text=get_text(\"deposit\", language)),\n        KeyboardButton(text=get_text(\"withdraw\", language))\n    )\n    \n    builder.row(\n        KeyboardButton(text=get_text(\"complaints\", language)),\n        KeyboardButton(text=get_text(\"support\", language))\n    )\n    \n    builder.row(\n        KeyboardButton(text=get_text(\"manager\", language)),\n        KeyboardButton(text=get_text(\"plans\", language))\n    )\n    \n    builder.row(\n        KeyboardButton(text=get_text(\"sales\", language)),\n        KeyboardButton(text=get_text(\"settings\", language))\n    )\n    \n    # Bottom navigation buttons\n    builder.row(\n        KeyboardButton(text=get_text(\"back\", language)),\n        KeyboardButton(text=get_text(\"forward\", language)),\n        KeyboardButton(text=get_text(\"my_account\", language))\n    )\n    \n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=False)\n\ndef get_phone_share_keyboard(language: str = \"ar\") -> ReplyKeyboardMarkup:\n    \"\"\"Create phone sharing keyboard\"\"\"\n    builder = ReplyKeyboardBuilder()\n    \n    builder.row(\n        KeyboardButton(\n            text=get_text(\"share_phone\", language),\n            request_contact=True\n        )\n    )\n    \n    return builder.as_markup(resize_keyboard=True, one_time_keyboard=True)\n\ndef get_contact_confirmation_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create contact confirmation keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"confirm\", language),\n            callback_data=\"confirm_phone\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_settings_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create settings menu keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"change_language\", language),\n            callback_data=\"change_language\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"change_country\", language),\n            callback_data=\"change_country\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"toggle_notifications\", language),\n            callback_data=\"toggle_notifications\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_language_selection_keyboard(languages, current_language: str, \n                                  ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create language selection keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for lang in languages:\n        # Add checkmark for current language\n        text = lang.native_name\n        if lang.code == current_language:\n            text = f\"✅ {text}\"\n        \n        builder.row(\n            InlineKeyboardButton(\n                text=text,\n                callback_data=f\"lang_{lang.code}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", ui_language),\n            callback_data=\"back_to_settings\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_country_selection_keyboard(countries, current_country: str,\n                                 ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create country selection keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for country in countries:\n        # Add checkmark for current country\n        text = country.native_name\n        if country.code == current_country:\n            text = f\"✅ {text}\"\n        \n        builder.row(\n            InlineKeyboardButton(\n                text=text,\n                callback_data=f\"country_{country.code}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", ui_language),\n            callback_data=\"back_to_settings\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_panel_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin panel keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_users\", language),\n            callback_data=\"admin_users\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_languages\", language),\n            callback_data=\"admin_languages\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"admin_countries\", language),\n            callback_data=\"admin_countries\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_broadcast\", language),\n            callback_data=\"admin_broadcast\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"admin_outbox\", language),\n            callback_data=\"admin_outbox\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_users_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin users management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"search_users\", language),\n            callback_data=\"search_users\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"user_statistics\", language),\n            callback_data=\"user_statistics\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_languages_keyboard(languages, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin languages management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    # Show toggle buttons for each language\n    for lang in languages[:5]:  # Limit to 5 to avoid too long keyboards\n        status_text = \"✅\" if lang.is_active else \"❌\"\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{status_text} {lang.native_name}\",\n                callback_data=f\"toggle_lang_{lang.id}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"add_language\", language),\n            callback_data=\"add_language\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_admin_countries_keyboard(countries, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create admin countries management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    # Show toggle buttons for each country\n    for country in countries[:5]:  # Limit to 5 to avoid too long keyboards\n        status_text = \"✅\" if country.is_active else \"❌\"\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{status_text} {country.native_name}\",\n                callback_data=f\"toggle_country_{country.id}\"\n            )\n        )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"add_country\", language),\n            callback_data=\"add_country\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_user_management_keyboard(user_id: int, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create user management keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"ban_user\", language),\n            callback_data=f\"ban_user_{user_id}\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"unban_user\", language),\n            callback_data=f\"unban_user_{user_id}\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"promote_admin\", language),\n            callback_data=f\"promote_admin_{user_id}\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"admin_users\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_pagination_keyboard(base_callback: str, current_page: int, \n                          total_pages: int, language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create pagination keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    buttons = []\n    \n    # Previous button\n    if current_page > 0:\n        buttons.append(\n            InlineKeyboardButton(\n                text=\"◀️\",\n                callback_data=f\"{base_callback}_page_{current_page - 1}\"\n            )\n        )\n    \n    # Current page indicator\n    buttons.append(\n        InlineKeyboardButton(\n            text=f\"{current_page + 1}/{total_pages}\",\n            callback_data=\"noop\"\n        )\n    )\n    \n    # Next button\n    if current_page < total_pages - 1:\n        buttons.append(\n            InlineKeyboardButton(\n                text=\"▶️\",\n                callback_data=f\"{base_callback}_page_{current_page + 1}\"\n            )\n        )\n    \n    builder.row(*buttons)\n    \n    # Back button\n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"back\", language),\n            callback_data=\"back_to_admin\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_broadcast_targeting_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create broadcast targeting keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"broadcast_all\", language),\n            callback_data=\"broadcast_all\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"broadcast_by_language\", language),\n            callback_data=\"broadcast_by_language\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"broadcast_by_country\", language),\n            callback_data=\"broadcast_by_country\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_broadcast_confirmation_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create broadcast confirmation keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"confirm_broadcast\", language),\n            callback_data=\"confirm_broadcast\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"cancel_broadcast\", language),\n            callback_data=\"cancel_broadcast\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_language_filter_keyboard(languages, ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create language filter keyboard for broadcasts\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for lang_code, lang_name, user_count in languages:\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{lang_name} ({user_count})\",\n                callback_data=f\"lang_filter_{lang_code}\"\n            )\n        )\n    \n    return builder.as_markup()\n\ndef get_country_filter_keyboard(countries, ui_language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create country filter keyboard for broadcasts\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    for country_code, country_name, user_count in countries:\n        builder.row(\n            InlineKeyboardButton(\n                text=f\"{country_name} ({user_count})\",\n                callback_data=f\"country_filter_{country_code}\"\n            )\n        )\n    \n    return builder.as_markup()\n\ndef get_announcement_menu_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement menu keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"skip_image\", language),\n            callback_data=\"skip_image\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_announcement_targeting_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement targeting keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"announce_all\", language),\n            callback_data=\"announce_all\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"announce_by_language\", language),\n            callback_data=\"announce_by_language\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_announcement_duration_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement duration keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"duration_1h\", language),\n            callback_data=\"duration_1h\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"duration_6h\", language),\n            callback_data=\"duration_6h\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"duration_24h\", language),\n            callback_data=\"duration_24h\"\n        ),\n        InlineKeyboardButton(\n            text=get_text(\"duration_7d\", language),\n            callback_data=\"duration_7d\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"duration_permanent\", language),\n            callback_data=\"duration_permanent\"\n        )\n    )\n    \n    return builder.as_markup()\n\ndef get_announcement_confirmation_keyboard(language: str = \"ar\") -> InlineKeyboardMarkup:\n    \"\"\"Create announcement confirmation keyboard\"\"\"\n    builder = InlineKeyboardBuilder()\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"confirm_announcement\", language),\n            callback_data=\"confirm_announcement\"\n        )\n    )\n    \n    builder.row(\n        InlineKeyboardButton(\n            text=get_text(\"cancel_announcement\", language),\n            callback_data=\"cancel_announcement\"\n        )\n    )\n    \n    return builder.as_markup()\n","size_bytes":14747}},"version":1}